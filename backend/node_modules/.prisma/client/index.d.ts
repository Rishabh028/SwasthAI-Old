
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model HealthProfile
 * 
 */
export type HealthProfile = $Result.DefaultSelection<Prisma.$HealthProfilePayload>
/**
 * Model Doctor
 * 
 */
export type Doctor = $Result.DefaultSelection<Prisma.$DoctorPayload>
/**
 * Model DoctorReview
 * 
 */
export type DoctorReview = $Result.DefaultSelection<Prisma.$DoctorReviewPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model Prescription
 * 
 */
export type Prescription = $Result.DefaultSelection<Prisma.$PrescriptionPayload>
/**
 * Model CallSession
 * 
 */
export type CallSession = $Result.DefaultSelection<Prisma.$CallSessionPayload>
/**
 * Model Medicine
 * 
 */
export type Medicine = $Result.DefaultSelection<Prisma.$MedicinePayload>
/**
 * Model MedicineOrder
 * 
 */
export type MedicineOrder = $Result.DefaultSelection<Prisma.$MedicineOrderPayload>
/**
 * Model MedicineOrderItem
 * 
 */
export type MedicineOrderItem = $Result.DefaultSelection<Prisma.$MedicineOrderItemPayload>
/**
 * Model LabTest
 * 
 */
export type LabTest = $Result.DefaultSelection<Prisma.$LabTestPayload>
/**
 * Model LabBooking
 * 
 */
export type LabBooking = $Result.DefaultSelection<Prisma.$LabBookingPayload>
/**
 * Model LabBookingTest
 * 
 */
export type LabBookingTest = $Result.DefaultSelection<Prisma.$LabBookingTestPayload>
/**
 * Model LabReport
 * 
 */
export type LabReport = $Result.DefaultSelection<Prisma.$LabReportPayload>
/**
 * Model HealthRecord
 * 
 */
export type HealthRecord = $Result.DefaultSelection<Prisma.$HealthRecordPayload>
/**
 * Model ForumPost
 * 
 */
export type ForumPost = $Result.DefaultSelection<Prisma.$ForumPostPayload>
/**
 * Model ForumComment
 * 
 */
export type ForumComment = $Result.DefaultSelection<Prisma.$ForumCommentPayload>
/**
 * Model PostUpvote
 * 
 */
export type PostUpvote = $Result.DefaultSelection<Prisma.$PostUpvotePayload>
/**
 * Model CommentUpvote
 * 
 */
export type CommentUpvote = $Result.DefaultSelection<Prisma.$CommentUpvotePayload>
/**
 * Model HealthArticle
 * 
 */
export type HealthArticle = $Result.DefaultSelection<Prisma.$HealthArticlePayload>
/**
 * Model ArticleComment
 * 
 */
export type ArticleComment = $Result.DefaultSelection<Prisma.$ArticleCommentPayload>
/**
 * Model SavedArticle
 * 
 */
export type SavedArticle = $Result.DefaultSelection<Prisma.$SavedArticlePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SymptomCheckSession
 * 
 */
export type SymptomCheckSession = $Result.DefaultSelection<Prisma.$SymptomCheckSessionPayload>
/**
 * Model CoachSession
 * 
 */
export type CoachSession = $Result.DefaultSelection<Prisma.$CoachSessionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.healthProfile`: Exposes CRUD operations for the **HealthProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthProfiles
    * const healthProfiles = await prisma.healthProfile.findMany()
    * ```
    */
  get healthProfile(): Prisma.HealthProfileDelegate<ExtArgs>;

  /**
   * `prisma.doctor`: Exposes CRUD operations for the **Doctor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Doctors
    * const doctors = await prisma.doctor.findMany()
    * ```
    */
  get doctor(): Prisma.DoctorDelegate<ExtArgs>;

  /**
   * `prisma.doctorReview`: Exposes CRUD operations for the **DoctorReview** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DoctorReviews
    * const doctorReviews = await prisma.doctorReview.findMany()
    * ```
    */
  get doctorReview(): Prisma.DoctorReviewDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.prescription`: Exposes CRUD operations for the **Prescription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Prescriptions
    * const prescriptions = await prisma.prescription.findMany()
    * ```
    */
  get prescription(): Prisma.PrescriptionDelegate<ExtArgs>;

  /**
   * `prisma.callSession`: Exposes CRUD operations for the **CallSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CallSessions
    * const callSessions = await prisma.callSession.findMany()
    * ```
    */
  get callSession(): Prisma.CallSessionDelegate<ExtArgs>;

  /**
   * `prisma.medicine`: Exposes CRUD operations for the **Medicine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Medicines
    * const medicines = await prisma.medicine.findMany()
    * ```
    */
  get medicine(): Prisma.MedicineDelegate<ExtArgs>;

  /**
   * `prisma.medicineOrder`: Exposes CRUD operations for the **MedicineOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineOrders
    * const medicineOrders = await prisma.medicineOrder.findMany()
    * ```
    */
  get medicineOrder(): Prisma.MedicineOrderDelegate<ExtArgs>;

  /**
   * `prisma.medicineOrderItem`: Exposes CRUD operations for the **MedicineOrderItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicineOrderItems
    * const medicineOrderItems = await prisma.medicineOrderItem.findMany()
    * ```
    */
  get medicineOrderItem(): Prisma.MedicineOrderItemDelegate<ExtArgs>;

  /**
   * `prisma.labTest`: Exposes CRUD operations for the **LabTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabTests
    * const labTests = await prisma.labTest.findMany()
    * ```
    */
  get labTest(): Prisma.LabTestDelegate<ExtArgs>;

  /**
   * `prisma.labBooking`: Exposes CRUD operations for the **LabBooking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabBookings
    * const labBookings = await prisma.labBooking.findMany()
    * ```
    */
  get labBooking(): Prisma.LabBookingDelegate<ExtArgs>;

  /**
   * `prisma.labBookingTest`: Exposes CRUD operations for the **LabBookingTest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabBookingTests
    * const labBookingTests = await prisma.labBookingTest.findMany()
    * ```
    */
  get labBookingTest(): Prisma.LabBookingTestDelegate<ExtArgs>;

  /**
   * `prisma.labReport`: Exposes CRUD operations for the **LabReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabReports
    * const labReports = await prisma.labReport.findMany()
    * ```
    */
  get labReport(): Prisma.LabReportDelegate<ExtArgs>;

  /**
   * `prisma.healthRecord`: Exposes CRUD operations for the **HealthRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthRecords
    * const healthRecords = await prisma.healthRecord.findMany()
    * ```
    */
  get healthRecord(): Prisma.HealthRecordDelegate<ExtArgs>;

  /**
   * `prisma.forumPost`: Exposes CRUD operations for the **ForumPost** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumPosts
    * const forumPosts = await prisma.forumPost.findMany()
    * ```
    */
  get forumPost(): Prisma.ForumPostDelegate<ExtArgs>;

  /**
   * `prisma.forumComment`: Exposes CRUD operations for the **ForumComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ForumComments
    * const forumComments = await prisma.forumComment.findMany()
    * ```
    */
  get forumComment(): Prisma.ForumCommentDelegate<ExtArgs>;

  /**
   * `prisma.postUpvote`: Exposes CRUD operations for the **PostUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PostUpvotes
    * const postUpvotes = await prisma.postUpvote.findMany()
    * ```
    */
  get postUpvote(): Prisma.PostUpvoteDelegate<ExtArgs>;

  /**
   * `prisma.commentUpvote`: Exposes CRUD operations for the **CommentUpvote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CommentUpvotes
    * const commentUpvotes = await prisma.commentUpvote.findMany()
    * ```
    */
  get commentUpvote(): Prisma.CommentUpvoteDelegate<ExtArgs>;

  /**
   * `prisma.healthArticle`: Exposes CRUD operations for the **HealthArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HealthArticles
    * const healthArticles = await prisma.healthArticle.findMany()
    * ```
    */
  get healthArticle(): Prisma.HealthArticleDelegate<ExtArgs>;

  /**
   * `prisma.articleComment`: Exposes CRUD operations for the **ArticleComment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ArticleComments
    * const articleComments = await prisma.articleComment.findMany()
    * ```
    */
  get articleComment(): Prisma.ArticleCommentDelegate<ExtArgs>;

  /**
   * `prisma.savedArticle`: Exposes CRUD operations for the **SavedArticle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SavedArticles
    * const savedArticles = await prisma.savedArticle.findMany()
    * ```
    */
  get savedArticle(): Prisma.SavedArticleDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.symptomCheckSession`: Exposes CRUD operations for the **SymptomCheckSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SymptomCheckSessions
    * const symptomCheckSessions = await prisma.symptomCheckSession.findMany()
    * ```
    */
  get symptomCheckSession(): Prisma.SymptomCheckSessionDelegate<ExtArgs>;

  /**
   * `prisma.coachSession`: Exposes CRUD operations for the **CoachSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CoachSessions
    * const coachSessions = await prisma.coachSession.findMany()
    * ```
    */
  get coachSession(): Prisma.CoachSessionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    HealthProfile: 'HealthProfile',
    Doctor: 'Doctor',
    DoctorReview: 'DoctorReview',
    Appointment: 'Appointment',
    Prescription: 'Prescription',
    CallSession: 'CallSession',
    Medicine: 'Medicine',
    MedicineOrder: 'MedicineOrder',
    MedicineOrderItem: 'MedicineOrderItem',
    LabTest: 'LabTest',
    LabBooking: 'LabBooking',
    LabBookingTest: 'LabBookingTest',
    LabReport: 'LabReport',
    HealthRecord: 'HealthRecord',
    ForumPost: 'ForumPost',
    ForumComment: 'ForumComment',
    PostUpvote: 'PostUpvote',
    CommentUpvote: 'CommentUpvote',
    HealthArticle: 'HealthArticle',
    ArticleComment: 'ArticleComment',
    SavedArticle: 'SavedArticle',
    Notification: 'Notification',
    SymptomCheckSession: 'SymptomCheckSession',
    CoachSession: 'CoachSession'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "healthProfile" | "doctor" | "doctorReview" | "appointment" | "prescription" | "callSession" | "medicine" | "medicineOrder" | "medicineOrderItem" | "labTest" | "labBooking" | "labBookingTest" | "labReport" | "healthRecord" | "forumPost" | "forumComment" | "postUpvote" | "commentUpvote" | "healthArticle" | "articleComment" | "savedArticle" | "notification" | "symptomCheckSession" | "coachSession"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      HealthProfile: {
        payload: Prisma.$HealthProfilePayload<ExtArgs>
        fields: Prisma.HealthProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          findFirst: {
            args: Prisma.HealthProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          findMany: {
            args: Prisma.HealthProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>[]
          }
          create: {
            args: Prisma.HealthProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          createMany: {
            args: Prisma.HealthProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>[]
          }
          delete: {
            args: Prisma.HealthProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          update: {
            args: Prisma.HealthProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          deleteMany: {
            args: Prisma.HealthProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthProfilePayload>
          }
          aggregate: {
            args: Prisma.HealthProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthProfile>
          }
          groupBy: {
            args: Prisma.HealthProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthProfileCountArgs<ExtArgs>
            result: $Utils.Optional<HealthProfileCountAggregateOutputType> | number
          }
        }
      }
      Doctor: {
        payload: Prisma.$DoctorPayload<ExtArgs>
        fields: Prisma.DoctorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findFirst: {
            args: Prisma.DoctorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          findMany: {
            args: Prisma.DoctorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          create: {
            args: Prisma.DoctorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          createMany: {
            args: Prisma.DoctorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>[]
          }
          delete: {
            args: Prisma.DoctorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          update: {
            args: Prisma.DoctorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          deleteMany: {
            args: Prisma.DoctorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorPayload>
          }
          aggregate: {
            args: Prisma.DoctorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctor>
          }
          groupBy: {
            args: Prisma.DoctorGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorCountAggregateOutputType> | number
          }
        }
      }
      DoctorReview: {
        payload: Prisma.$DoctorReviewPayload<ExtArgs>
        fields: Prisma.DoctorReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DoctorReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DoctorReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          findFirst: {
            args: Prisma.DoctorReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DoctorReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          findMany: {
            args: Prisma.DoctorReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>[]
          }
          create: {
            args: Prisma.DoctorReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          createMany: {
            args: Prisma.DoctorReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DoctorReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>[]
          }
          delete: {
            args: Prisma.DoctorReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          update: {
            args: Prisma.DoctorReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          deleteMany: {
            args: Prisma.DoctorReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DoctorReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DoctorReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DoctorReviewPayload>
          }
          aggregate: {
            args: Prisma.DoctorReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDoctorReview>
          }
          groupBy: {
            args: Prisma.DoctorReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<DoctorReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.DoctorReviewCountArgs<ExtArgs>
            result: $Utils.Optional<DoctorReviewCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      Prescription: {
        payload: Prisma.$PrescriptionPayload<ExtArgs>
        fields: Prisma.PrescriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrescriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrescriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findFirst: {
            args: Prisma.PrescriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrescriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          findMany: {
            args: Prisma.PrescriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          create: {
            args: Prisma.PrescriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          createMany: {
            args: Prisma.PrescriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrescriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>[]
          }
          delete: {
            args: Prisma.PrescriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          update: {
            args: Prisma.PrescriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          deleteMany: {
            args: Prisma.PrescriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrescriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PrescriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrescriptionPayload>
          }
          aggregate: {
            args: Prisma.PrescriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrescription>
          }
          groupBy: {
            args: Prisma.PrescriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrescriptionCountArgs<ExtArgs>
            result: $Utils.Optional<PrescriptionCountAggregateOutputType> | number
          }
        }
      }
      CallSession: {
        payload: Prisma.$CallSessionPayload<ExtArgs>
        fields: Prisma.CallSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CallSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CallSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          findFirst: {
            args: Prisma.CallSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CallSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          findMany: {
            args: Prisma.CallSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>[]
          }
          create: {
            args: Prisma.CallSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          createMany: {
            args: Prisma.CallSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CallSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>[]
          }
          delete: {
            args: Prisma.CallSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          update: {
            args: Prisma.CallSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          deleteMany: {
            args: Prisma.CallSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CallSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CallSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CallSessionPayload>
          }
          aggregate: {
            args: Prisma.CallSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCallSession>
          }
          groupBy: {
            args: Prisma.CallSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CallSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CallSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CallSessionCountAggregateOutputType> | number
          }
        }
      }
      Medicine: {
        payload: Prisma.$MedicinePayload<ExtArgs>
        fields: Prisma.MedicineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findFirst: {
            args: Prisma.MedicineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          findMany: {
            args: Prisma.MedicineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          create: {
            args: Prisma.MedicineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          createMany: {
            args: Prisma.MedicineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>[]
          }
          delete: {
            args: Prisma.MedicineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          update: {
            args: Prisma.MedicineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          deleteMany: {
            args: Prisma.MedicineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicinePayload>
          }
          aggregate: {
            args: Prisma.MedicineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicine>
          }
          groupBy: {
            args: Prisma.MedicineGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineCountAggregateOutputType> | number
          }
        }
      }
      MedicineOrder: {
        payload: Prisma.$MedicineOrderPayload<ExtArgs>
        fields: Prisma.MedicineOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          findFirst: {
            args: Prisma.MedicineOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          findMany: {
            args: Prisma.MedicineOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>[]
          }
          create: {
            args: Prisma.MedicineOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          createMany: {
            args: Prisma.MedicineOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>[]
          }
          delete: {
            args: Prisma.MedicineOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          update: {
            args: Prisma.MedicineOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          deleteMany: {
            args: Prisma.MedicineOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicineOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderPayload>
          }
          aggregate: {
            args: Prisma.MedicineOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineOrder>
          }
          groupBy: {
            args: Prisma.MedicineOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineOrderCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineOrderCountAggregateOutputType> | number
          }
        }
      }
      MedicineOrderItem: {
        payload: Prisma.$MedicineOrderItemPayload<ExtArgs>
        fields: Prisma.MedicineOrderItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicineOrderItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicineOrderItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          findFirst: {
            args: Prisma.MedicineOrderItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicineOrderItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          findMany: {
            args: Prisma.MedicineOrderItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>[]
          }
          create: {
            args: Prisma.MedicineOrderItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          createMany: {
            args: Prisma.MedicineOrderItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicineOrderItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>[]
          }
          delete: {
            args: Prisma.MedicineOrderItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          update: {
            args: Prisma.MedicineOrderItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          deleteMany: {
            args: Prisma.MedicineOrderItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicineOrderItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicineOrderItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicineOrderItemPayload>
          }
          aggregate: {
            args: Prisma.MedicineOrderItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicineOrderItem>
          }
          groupBy: {
            args: Prisma.MedicineOrderItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicineOrderItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicineOrderItemCountArgs<ExtArgs>
            result: $Utils.Optional<MedicineOrderItemCountAggregateOutputType> | number
          }
        }
      }
      LabTest: {
        payload: Prisma.$LabTestPayload<ExtArgs>
        fields: Prisma.LabTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findFirst: {
            args: Prisma.LabTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          findMany: {
            args: Prisma.LabTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          create: {
            args: Prisma.LabTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          createMany: {
            args: Prisma.LabTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>[]
          }
          delete: {
            args: Prisma.LabTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          update: {
            args: Prisma.LabTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          deleteMany: {
            args: Prisma.LabTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabTestPayload>
          }
          aggregate: {
            args: Prisma.LabTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabTest>
          }
          groupBy: {
            args: Prisma.LabTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabTestCountAggregateOutputType> | number
          }
        }
      }
      LabBooking: {
        payload: Prisma.$LabBookingPayload<ExtArgs>
        fields: Prisma.LabBookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabBookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabBookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          findFirst: {
            args: Prisma.LabBookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabBookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          findMany: {
            args: Prisma.LabBookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>[]
          }
          create: {
            args: Prisma.LabBookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          createMany: {
            args: Prisma.LabBookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabBookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>[]
          }
          delete: {
            args: Prisma.LabBookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          update: {
            args: Prisma.LabBookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          deleteMany: {
            args: Prisma.LabBookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabBookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabBookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingPayload>
          }
          aggregate: {
            args: Prisma.LabBookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabBooking>
          }
          groupBy: {
            args: Prisma.LabBookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabBookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabBookingCountArgs<ExtArgs>
            result: $Utils.Optional<LabBookingCountAggregateOutputType> | number
          }
        }
      }
      LabBookingTest: {
        payload: Prisma.$LabBookingTestPayload<ExtArgs>
        fields: Prisma.LabBookingTestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabBookingTestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabBookingTestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          findFirst: {
            args: Prisma.LabBookingTestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabBookingTestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          findMany: {
            args: Prisma.LabBookingTestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>[]
          }
          create: {
            args: Prisma.LabBookingTestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          createMany: {
            args: Prisma.LabBookingTestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabBookingTestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>[]
          }
          delete: {
            args: Prisma.LabBookingTestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          update: {
            args: Prisma.LabBookingTestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          deleteMany: {
            args: Prisma.LabBookingTestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabBookingTestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabBookingTestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabBookingTestPayload>
          }
          aggregate: {
            args: Prisma.LabBookingTestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabBookingTest>
          }
          groupBy: {
            args: Prisma.LabBookingTestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabBookingTestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabBookingTestCountArgs<ExtArgs>
            result: $Utils.Optional<LabBookingTestCountAggregateOutputType> | number
          }
        }
      }
      LabReport: {
        payload: Prisma.$LabReportPayload<ExtArgs>
        fields: Prisma.LabReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          findFirst: {
            args: Prisma.LabReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          findMany: {
            args: Prisma.LabReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>[]
          }
          create: {
            args: Prisma.LabReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          createMany: {
            args: Prisma.LabReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>[]
          }
          delete: {
            args: Prisma.LabReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          update: {
            args: Prisma.LabReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          deleteMany: {
            args: Prisma.LabReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LabReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabReportPayload>
          }
          aggregate: {
            args: Prisma.LabReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabReport>
          }
          groupBy: {
            args: Prisma.LabReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabReportCountArgs<ExtArgs>
            result: $Utils.Optional<LabReportCountAggregateOutputType> | number
          }
        }
      }
      HealthRecord: {
        payload: Prisma.$HealthRecordPayload<ExtArgs>
        fields: Prisma.HealthRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findFirst: {
            args: Prisma.HealthRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          findMany: {
            args: Prisma.HealthRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          create: {
            args: Prisma.HealthRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          createMany: {
            args: Prisma.HealthRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>[]
          }
          delete: {
            args: Prisma.HealthRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          update: {
            args: Prisma.HealthRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          deleteMany: {
            args: Prisma.HealthRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthRecordPayload>
          }
          aggregate: {
            args: Prisma.HealthRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthRecord>
          }
          groupBy: {
            args: Prisma.HealthRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthRecordCountArgs<ExtArgs>
            result: $Utils.Optional<HealthRecordCountAggregateOutputType> | number
          }
        }
      }
      ForumPost: {
        payload: Prisma.$ForumPostPayload<ExtArgs>
        fields: Prisma.ForumPostFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumPostFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumPostFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findFirst: {
            args: Prisma.ForumPostFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumPostFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          findMany: {
            args: Prisma.ForumPostFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          create: {
            args: Prisma.ForumPostCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          createMany: {
            args: Prisma.ForumPostCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumPostCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>[]
          }
          delete: {
            args: Prisma.ForumPostDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          update: {
            args: Prisma.ForumPostUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          deleteMany: {
            args: Prisma.ForumPostDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumPostUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumPostUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumPostPayload>
          }
          aggregate: {
            args: Prisma.ForumPostAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumPost>
          }
          groupBy: {
            args: Prisma.ForumPostGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumPostGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumPostCountArgs<ExtArgs>
            result: $Utils.Optional<ForumPostCountAggregateOutputType> | number
          }
        }
      }
      ForumComment: {
        payload: Prisma.$ForumCommentPayload<ExtArgs>
        fields: Prisma.ForumCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ForumCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ForumCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findFirst: {
            args: Prisma.ForumCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ForumCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          findMany: {
            args: Prisma.ForumCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          create: {
            args: Prisma.ForumCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          createMany: {
            args: Prisma.ForumCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ForumCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>[]
          }
          delete: {
            args: Prisma.ForumCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          update: {
            args: Prisma.ForumCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          deleteMany: {
            args: Prisma.ForumCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ForumCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ForumCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ForumCommentPayload>
          }
          aggregate: {
            args: Prisma.ForumCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateForumComment>
          }
          groupBy: {
            args: Prisma.ForumCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ForumCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ForumCommentCountAggregateOutputType> | number
          }
        }
      }
      PostUpvote: {
        payload: Prisma.$PostUpvotePayload<ExtArgs>
        fields: Prisma.PostUpvoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PostUpvoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PostUpvoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          findFirst: {
            args: Prisma.PostUpvoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PostUpvoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          findMany: {
            args: Prisma.PostUpvoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>[]
          }
          create: {
            args: Prisma.PostUpvoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          createMany: {
            args: Prisma.PostUpvoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PostUpvoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>[]
          }
          delete: {
            args: Prisma.PostUpvoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          update: {
            args: Prisma.PostUpvoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          deleteMany: {
            args: Prisma.PostUpvoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PostUpvoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PostUpvoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PostUpvotePayload>
          }
          aggregate: {
            args: Prisma.PostUpvoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePostUpvote>
          }
          groupBy: {
            args: Prisma.PostUpvoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<PostUpvoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.PostUpvoteCountArgs<ExtArgs>
            result: $Utils.Optional<PostUpvoteCountAggregateOutputType> | number
          }
        }
      }
      CommentUpvote: {
        payload: Prisma.$CommentUpvotePayload<ExtArgs>
        fields: Prisma.CommentUpvoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CommentUpvoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CommentUpvoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          findFirst: {
            args: Prisma.CommentUpvoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CommentUpvoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          findMany: {
            args: Prisma.CommentUpvoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>[]
          }
          create: {
            args: Prisma.CommentUpvoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          createMany: {
            args: Prisma.CommentUpvoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CommentUpvoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>[]
          }
          delete: {
            args: Prisma.CommentUpvoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          update: {
            args: Prisma.CommentUpvoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          deleteMany: {
            args: Prisma.CommentUpvoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CommentUpvoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CommentUpvoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CommentUpvotePayload>
          }
          aggregate: {
            args: Prisma.CommentUpvoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCommentUpvote>
          }
          groupBy: {
            args: Prisma.CommentUpvoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<CommentUpvoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.CommentUpvoteCountArgs<ExtArgs>
            result: $Utils.Optional<CommentUpvoteCountAggregateOutputType> | number
          }
        }
      }
      HealthArticle: {
        payload: Prisma.$HealthArticlePayload<ExtArgs>
        fields: Prisma.HealthArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HealthArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HealthArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          findFirst: {
            args: Prisma.HealthArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HealthArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          findMany: {
            args: Prisma.HealthArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>[]
          }
          create: {
            args: Prisma.HealthArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          createMany: {
            args: Prisma.HealthArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HealthArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>[]
          }
          delete: {
            args: Prisma.HealthArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          update: {
            args: Prisma.HealthArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          deleteMany: {
            args: Prisma.HealthArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HealthArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HealthArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HealthArticlePayload>
          }
          aggregate: {
            args: Prisma.HealthArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHealthArticle>
          }
          groupBy: {
            args: Prisma.HealthArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<HealthArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.HealthArticleCountArgs<ExtArgs>
            result: $Utils.Optional<HealthArticleCountAggregateOutputType> | number
          }
        }
      }
      ArticleComment: {
        payload: Prisma.$ArticleCommentPayload<ExtArgs>
        fields: Prisma.ArticleCommentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ArticleCommentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ArticleCommentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          findFirst: {
            args: Prisma.ArticleCommentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ArticleCommentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          findMany: {
            args: Prisma.ArticleCommentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>[]
          }
          create: {
            args: Prisma.ArticleCommentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          createMany: {
            args: Prisma.ArticleCommentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ArticleCommentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>[]
          }
          delete: {
            args: Prisma.ArticleCommentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          update: {
            args: Prisma.ArticleCommentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          deleteMany: {
            args: Prisma.ArticleCommentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ArticleCommentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ArticleCommentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ArticleCommentPayload>
          }
          aggregate: {
            args: Prisma.ArticleCommentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateArticleComment>
          }
          groupBy: {
            args: Prisma.ArticleCommentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ArticleCommentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ArticleCommentCountArgs<ExtArgs>
            result: $Utils.Optional<ArticleCommentCountAggregateOutputType> | number
          }
        }
      }
      SavedArticle: {
        payload: Prisma.$SavedArticlePayload<ExtArgs>
        fields: Prisma.SavedArticleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SavedArticleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SavedArticleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          findFirst: {
            args: Prisma.SavedArticleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SavedArticleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          findMany: {
            args: Prisma.SavedArticleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>[]
          }
          create: {
            args: Prisma.SavedArticleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          createMany: {
            args: Prisma.SavedArticleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SavedArticleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>[]
          }
          delete: {
            args: Prisma.SavedArticleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          update: {
            args: Prisma.SavedArticleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          deleteMany: {
            args: Prisma.SavedArticleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SavedArticleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SavedArticleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SavedArticlePayload>
          }
          aggregate: {
            args: Prisma.SavedArticleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSavedArticle>
          }
          groupBy: {
            args: Prisma.SavedArticleGroupByArgs<ExtArgs>
            result: $Utils.Optional<SavedArticleGroupByOutputType>[]
          }
          count: {
            args: Prisma.SavedArticleCountArgs<ExtArgs>
            result: $Utils.Optional<SavedArticleCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SymptomCheckSession: {
        payload: Prisma.$SymptomCheckSessionPayload<ExtArgs>
        fields: Prisma.SymptomCheckSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SymptomCheckSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SymptomCheckSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          findFirst: {
            args: Prisma.SymptomCheckSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SymptomCheckSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          findMany: {
            args: Prisma.SymptomCheckSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>[]
          }
          create: {
            args: Prisma.SymptomCheckSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          createMany: {
            args: Prisma.SymptomCheckSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SymptomCheckSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>[]
          }
          delete: {
            args: Prisma.SymptomCheckSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          update: {
            args: Prisma.SymptomCheckSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          deleteMany: {
            args: Prisma.SymptomCheckSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SymptomCheckSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SymptomCheckSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SymptomCheckSessionPayload>
          }
          aggregate: {
            args: Prisma.SymptomCheckSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSymptomCheckSession>
          }
          groupBy: {
            args: Prisma.SymptomCheckSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SymptomCheckSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SymptomCheckSessionCountArgs<ExtArgs>
            result: $Utils.Optional<SymptomCheckSessionCountAggregateOutputType> | number
          }
        }
      }
      CoachSession: {
        payload: Prisma.$CoachSessionPayload<ExtArgs>
        fields: Prisma.CoachSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CoachSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CoachSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          findFirst: {
            args: Prisma.CoachSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CoachSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          findMany: {
            args: Prisma.CoachSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>[]
          }
          create: {
            args: Prisma.CoachSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          createMany: {
            args: Prisma.CoachSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CoachSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>[]
          }
          delete: {
            args: Prisma.CoachSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          update: {
            args: Prisma.CoachSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          deleteMany: {
            args: Prisma.CoachSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CoachSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CoachSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CoachSessionPayload>
          }
          aggregate: {
            args: Prisma.CoachSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCoachSession>
          }
          groupBy: {
            args: Prisma.CoachSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<CoachSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.CoachSessionCountArgs<ExtArgs>
            result: $Utils.Optional<CoachSessionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    appointments: number
    appointmentsAsDoctor: number
    medicineOrders: number
    labBookings: number
    healthRecords: number
    forumPosts: number
    forumComments: number
    postUpvotes: number
    commentUpvotes: number
    articles: number
    savedArticles: number
    notifications: number
    reviews: number
    symptomSessions: number
    coachSessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | UserCountOutputTypeCountAppointmentsArgs
    appointmentsAsDoctor?: boolean | UserCountOutputTypeCountAppointmentsAsDoctorArgs
    medicineOrders?: boolean | UserCountOutputTypeCountMedicineOrdersArgs
    labBookings?: boolean | UserCountOutputTypeCountLabBookingsArgs
    healthRecords?: boolean | UserCountOutputTypeCountHealthRecordsArgs
    forumPosts?: boolean | UserCountOutputTypeCountForumPostsArgs
    forumComments?: boolean | UserCountOutputTypeCountForumCommentsArgs
    postUpvotes?: boolean | UserCountOutputTypeCountPostUpvotesArgs
    commentUpvotes?: boolean | UserCountOutputTypeCountCommentUpvotesArgs
    articles?: boolean | UserCountOutputTypeCountArticlesArgs
    savedArticles?: boolean | UserCountOutputTypeCountSavedArticlesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    symptomSessions?: boolean | UserCountOutputTypeCountSymptomSessionsArgs
    coachSessions?: boolean | UserCountOutputTypeCountCoachSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppointmentsAsDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMedicineOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLabBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabBookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountHealthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountForumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPostUpvotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostUpvoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCommentUpvotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentUpvoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSavedArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedArticleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSymptomSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomCheckSessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCoachSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachSessionWhereInput
  }


  /**
   * Count Type DoctorCountOutputType
   */

  export type DoctorCountOutputType = {
    appointments: number
    reviews: number
  }

  export type DoctorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | DoctorCountOutputTypeCountAppointmentsArgs
    reviews?: boolean | DoctorCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorCountOutputType
     */
    select?: DoctorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * DoctorCountOutputType without action
   */
  export type DoctorCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorReviewWhereInput
  }


  /**
   * Count Type AppointmentCountOutputType
   */

  export type AppointmentCountOutputType = {
    reviews: number
  }

  export type AppointmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reviews?: boolean | AppointmentCountOutputTypeCountReviewsArgs
  }

  // Custom InputTypes
  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppointmentCountOutputType
     */
    select?: AppointmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppointmentCountOutputType without action
   */
  export type AppointmentCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorReviewWhereInput
  }


  /**
   * Count Type PrescriptionCountOutputType
   */

  export type PrescriptionCountOutputType = {
    appointments: number
  }

  export type PrescriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | PrescriptionCountOutputTypeCountAppointmentsArgs
  }

  // Custom InputTypes
  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrescriptionCountOutputType
     */
    select?: PrescriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrescriptionCountOutputType without action
   */
  export type PrescriptionCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }


  /**
   * Count Type MedicineCountOutputType
   */

  export type MedicineCountOutputType = {
    orderItems: number
  }

  export type MedicineCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | MedicineCountOutputTypeCountOrderItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineCountOutputType
     */
    select?: MedicineCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineCountOutputType without action
   */
  export type MedicineCountOutputTypeCountOrderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineOrderItemWhereInput
  }


  /**
   * Count Type MedicineOrderCountOutputType
   */

  export type MedicineOrderCountOutputType = {
    items: number
  }

  export type MedicineOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | MedicineOrderCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * MedicineOrderCountOutputType without action
   */
  export type MedicineOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderCountOutputType
     */
    select?: MedicineOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MedicineOrderCountOutputType without action
   */
  export type MedicineOrderCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineOrderItemWhereInput
  }


  /**
   * Count Type LabTestCountOutputType
   */

  export type LabTestCountOutputType = {
    bookings: number
  }

  export type LabTestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | LabTestCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * LabTestCountOutputType without action
   */
  export type LabTestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTestCountOutputType
     */
    select?: LabTestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabTestCountOutputType without action
   */
  export type LabTestCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabBookingTestWhereInput
  }


  /**
   * Count Type LabBookingCountOutputType
   */

  export type LabBookingCountOutputType = {
    tests: number
  }

  export type LabBookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tests?: boolean | LabBookingCountOutputTypeCountTestsArgs
  }

  // Custom InputTypes
  /**
   * LabBookingCountOutputType without action
   */
  export type LabBookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingCountOutputType
     */
    select?: LabBookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LabBookingCountOutputType without action
   */
  export type LabBookingCountOutputTypeCountTestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabBookingTestWhereInput
  }


  /**
   * Count Type ForumPostCountOutputType
   */

  export type ForumPostCountOutputType = {
    comments: number
    upvotesByUser: number
  }

  export type ForumPostCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | ForumPostCountOutputTypeCountCommentsArgs
    upvotesByUser?: boolean | ForumPostCountOutputTypeCountUpvotesByUserArgs
  }

  // Custom InputTypes
  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPostCountOutputType
     */
    select?: ForumPostCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }

  /**
   * ForumPostCountOutputType without action
   */
  export type ForumPostCountOutputTypeCountUpvotesByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostUpvoteWhereInput
  }


  /**
   * Count Type ForumCommentCountOutputType
   */

  export type ForumCommentCountOutputType = {
    replies: number
    upvotesByUser: number
  }

  export type ForumCommentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    replies?: boolean | ForumCommentCountOutputTypeCountRepliesArgs
    upvotesByUser?: boolean | ForumCommentCountOutputTypeCountUpvotesByUserArgs
  }

  // Custom InputTypes
  /**
   * ForumCommentCountOutputType without action
   */
  export type ForumCommentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumCommentCountOutputType
     */
    select?: ForumCommentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ForumCommentCountOutputType without action
   */
  export type ForumCommentCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
  }

  /**
   * ForumCommentCountOutputType without action
   */
  export type ForumCommentCountOutputTypeCountUpvotesByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentUpvoteWhereInput
  }


  /**
   * Count Type HealthArticleCountOutputType
   */

  export type HealthArticleCountOutputType = {
    comments: number
    savedBy: number
  }

  export type HealthArticleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comments?: boolean | HealthArticleCountOutputTypeCountCommentsArgs
    savedBy?: boolean | HealthArticleCountOutputTypeCountSavedByArgs
  }

  // Custom InputTypes
  /**
   * HealthArticleCountOutputType without action
   */
  export type HealthArticleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticleCountOutputType
     */
    select?: HealthArticleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HealthArticleCountOutputType without action
   */
  export type HealthArticleCountOutputTypeCountCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCommentWhereInput
  }

  /**
   * HealthArticleCountOutputType without action
   */
  export type HealthArticleCountOutputTypeCountSavedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedArticleWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    fullName: string | null
    profilePhotoUrl: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    city: string | null
    state: string | null
    country: string | null
    address: string | null
    abhaId: string | null
    isVerified: boolean | null
    isActive: boolean | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    email: string | null
    phone: string | null
    passwordHash: string | null
    fullName: string | null
    profilePhotoUrl: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    city: string | null
    state: string | null
    country: string | null
    address: string | null
    abhaId: string | null
    isVerified: boolean | null
    isActive: boolean | null
    role: string | null
    lastLogin: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    uuid: number
    email: number
    phone: number
    passwordHash: number
    fullName: number
    profilePhotoUrl: number
    dateOfBirth: number
    gender: number
    bloodGroup: number
    city: number
    state: number
    country: number
    address: number
    abhaId: number
    isVerified: number
    isActive: number
    role: number
    lastLogin: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    city?: true
    state?: true
    country?: true
    address?: true
    abhaId?: true
    isVerified?: true
    isActive?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    city?: true
    state?: true
    country?: true
    address?: true
    abhaId?: true
    isVerified?: true
    isActive?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    uuid?: true
    email?: true
    phone?: true
    passwordHash?: true
    fullName?: true
    profilePhotoUrl?: true
    dateOfBirth?: true
    gender?: true
    bloodGroup?: true
    city?: true
    state?: true
    country?: true
    address?: true
    abhaId?: true
    isVerified?: true
    isActive?: true
    role?: true
    lastLogin?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    uuid: string
    email: string
    phone: string | null
    passwordHash: string | null
    fullName: string | null
    profilePhotoUrl: string | null
    dateOfBirth: Date | null
    gender: string | null
    bloodGroup: string | null
    city: string | null
    state: string | null
    country: string | null
    address: string | null
    abhaId: string | null
    isVerified: boolean
    isActive: boolean
    role: string
    lastLogin: Date | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    address?: boolean
    abhaId?: boolean
    isVerified?: boolean
    isActive?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    healthProfile?: boolean | User$healthProfileArgs<ExtArgs>
    doctorProfile?: boolean | User$doctorProfileArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    appointmentsAsDoctor?: boolean | User$appointmentsAsDoctorArgs<ExtArgs>
    medicineOrders?: boolean | User$medicineOrdersArgs<ExtArgs>
    labBookings?: boolean | User$labBookingsArgs<ExtArgs>
    healthRecords?: boolean | User$healthRecordsArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumComments?: boolean | User$forumCommentsArgs<ExtArgs>
    postUpvotes?: boolean | User$postUpvotesArgs<ExtArgs>
    commentUpvotes?: boolean | User$commentUpvotesArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    savedArticles?: boolean | User$savedArticlesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    symptomSessions?: boolean | User$symptomSessionsArgs<ExtArgs>
    coachSessions?: boolean | User$coachSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    address?: boolean
    abhaId?: boolean
    isVerified?: boolean
    isActive?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    uuid?: boolean
    email?: boolean
    phone?: boolean
    passwordHash?: boolean
    fullName?: boolean
    profilePhotoUrl?: boolean
    dateOfBirth?: boolean
    gender?: boolean
    bloodGroup?: boolean
    city?: boolean
    state?: boolean
    country?: boolean
    address?: boolean
    abhaId?: boolean
    isVerified?: boolean
    isActive?: boolean
    role?: boolean
    lastLogin?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    healthProfile?: boolean | User$healthProfileArgs<ExtArgs>
    doctorProfile?: boolean | User$doctorProfileArgs<ExtArgs>
    appointments?: boolean | User$appointmentsArgs<ExtArgs>
    appointmentsAsDoctor?: boolean | User$appointmentsAsDoctorArgs<ExtArgs>
    medicineOrders?: boolean | User$medicineOrdersArgs<ExtArgs>
    labBookings?: boolean | User$labBookingsArgs<ExtArgs>
    healthRecords?: boolean | User$healthRecordsArgs<ExtArgs>
    forumPosts?: boolean | User$forumPostsArgs<ExtArgs>
    forumComments?: boolean | User$forumCommentsArgs<ExtArgs>
    postUpvotes?: boolean | User$postUpvotesArgs<ExtArgs>
    commentUpvotes?: boolean | User$commentUpvotesArgs<ExtArgs>
    articles?: boolean | User$articlesArgs<ExtArgs>
    savedArticles?: boolean | User$savedArticlesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    symptomSessions?: boolean | User$symptomSessionsArgs<ExtArgs>
    coachSessions?: boolean | User$coachSessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      healthProfile: Prisma.$HealthProfilePayload<ExtArgs> | null
      doctorProfile: Prisma.$DoctorPayload<ExtArgs> | null
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      appointmentsAsDoctor: Prisma.$AppointmentPayload<ExtArgs>[]
      medicineOrders: Prisma.$MedicineOrderPayload<ExtArgs>[]
      labBookings: Prisma.$LabBookingPayload<ExtArgs>[]
      healthRecords: Prisma.$HealthRecordPayload<ExtArgs>[]
      forumPosts: Prisma.$ForumPostPayload<ExtArgs>[]
      forumComments: Prisma.$ForumCommentPayload<ExtArgs>[]
      postUpvotes: Prisma.$PostUpvotePayload<ExtArgs>[]
      commentUpvotes: Prisma.$CommentUpvotePayload<ExtArgs>[]
      articles: Prisma.$HealthArticlePayload<ExtArgs>[]
      savedArticles: Prisma.$SavedArticlePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      reviews: Prisma.$DoctorReviewPayload<ExtArgs>[]
      symptomSessions: Prisma.$SymptomCheckSessionPayload<ExtArgs>[]
      coachSessions: Prisma.$CoachSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      email: string
      phone: string | null
      passwordHash: string | null
      fullName: string | null
      profilePhotoUrl: string | null
      dateOfBirth: Date | null
      gender: string | null
      bloodGroup: string | null
      city: string | null
      state: string | null
      country: string | null
      address: string | null
      abhaId: string | null
      isVerified: boolean
      isActive: boolean
      role: string
      lastLogin: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    healthProfile<T extends User$healthProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$healthProfileArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    doctorProfile<T extends User$doctorProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$doctorProfileArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    appointments<T extends User$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    appointmentsAsDoctor<T extends User$appointmentsAsDoctorArgs<ExtArgs> = {}>(args?: Subset<T, User$appointmentsAsDoctorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    medicineOrders<T extends User$medicineOrdersArgs<ExtArgs> = {}>(args?: Subset<T, User$medicineOrdersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findMany"> | Null>
    labBookings<T extends User$labBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$labBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findMany"> | Null>
    healthRecords<T extends User$healthRecordsArgs<ExtArgs> = {}>(args?: Subset<T, User$healthRecordsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany"> | Null>
    forumPosts<T extends User$forumPostsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumPostsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany"> | Null>
    forumComments<T extends User$forumCommentsArgs<ExtArgs> = {}>(args?: Subset<T, User$forumCommentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany"> | Null>
    postUpvotes<T extends User$postUpvotesArgs<ExtArgs> = {}>(args?: Subset<T, User$postUpvotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findMany"> | Null>
    commentUpvotes<T extends User$commentUpvotesArgs<ExtArgs> = {}>(args?: Subset<T, User$commentUpvotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany"> | Null>
    articles<T extends User$articlesArgs<ExtArgs> = {}>(args?: Subset<T, User$articlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findMany"> | Null>
    savedArticles<T extends User$savedArticlesArgs<ExtArgs> = {}>(args?: Subset<T, User$savedArticlesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findMany"> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    symptomSessions<T extends User$symptomSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$symptomSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findMany"> | Null>
    coachSessions<T extends User$coachSessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$coachSessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly uuid: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly profilePhotoUrl: FieldRef<"User", 'String'>
    readonly dateOfBirth: FieldRef<"User", 'DateTime'>
    readonly gender: FieldRef<"User", 'String'>
    readonly bloodGroup: FieldRef<"User", 'String'>
    readonly city: FieldRef<"User", 'String'>
    readonly state: FieldRef<"User", 'String'>
    readonly country: FieldRef<"User", 'String'>
    readonly address: FieldRef<"User", 'String'>
    readonly abhaId: FieldRef<"User", 'String'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly role: FieldRef<"User", 'String'>
    readonly lastLogin: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.healthProfile
   */
  export type User$healthProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    where?: HealthProfileWhereInput
  }

  /**
   * User.doctorProfile
   */
  export type User$doctorProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    where?: DoctorWhereInput
  }

  /**
   * User.appointments
   */
  export type User$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.appointmentsAsDoctor
   */
  export type User$appointmentsAsDoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * User.medicineOrders
   */
  export type User$medicineOrdersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    where?: MedicineOrderWhereInput
    orderBy?: MedicineOrderOrderByWithRelationInput | MedicineOrderOrderByWithRelationInput[]
    cursor?: MedicineOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineOrderScalarFieldEnum | MedicineOrderScalarFieldEnum[]
  }

  /**
   * User.labBookings
   */
  export type User$labBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    where?: LabBookingWhereInput
    orderBy?: LabBookingOrderByWithRelationInput | LabBookingOrderByWithRelationInput[]
    cursor?: LabBookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabBookingScalarFieldEnum | LabBookingScalarFieldEnum[]
  }

  /**
   * User.healthRecords
   */
  export type User$healthRecordsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    cursor?: HealthRecordWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * User.forumPosts
   */
  export type User$forumPostsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    cursor?: ForumPostWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * User.forumComments
   */
  export type User$forumCommentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * User.postUpvotes
   */
  export type User$postUpvotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    where?: PostUpvoteWhereInput
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    cursor?: PostUpvoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostUpvoteScalarFieldEnum | PostUpvoteScalarFieldEnum[]
  }

  /**
   * User.commentUpvotes
   */
  export type User$commentUpvotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    where?: CommentUpvoteWhereInput
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    cursor?: CommentUpvoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentUpvoteScalarFieldEnum | CommentUpvoteScalarFieldEnum[]
  }

  /**
   * User.articles
   */
  export type User$articlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    where?: HealthArticleWhereInput
    orderBy?: HealthArticleOrderByWithRelationInput | HealthArticleOrderByWithRelationInput[]
    cursor?: HealthArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HealthArticleScalarFieldEnum | HealthArticleScalarFieldEnum[]
  }

  /**
   * User.savedArticles
   */
  export type User$savedArticlesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    where?: SavedArticleWhereInput
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    cursor?: SavedArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedArticleScalarFieldEnum | SavedArticleScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    where?: DoctorReviewWhereInput
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    cursor?: DoctorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * User.symptomSessions
   */
  export type User$symptomSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    where?: SymptomCheckSessionWhereInput
    orderBy?: SymptomCheckSessionOrderByWithRelationInput | SymptomCheckSessionOrderByWithRelationInput[]
    cursor?: SymptomCheckSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SymptomCheckSessionScalarFieldEnum | SymptomCheckSessionScalarFieldEnum[]
  }

  /**
   * User.coachSessions
   */
  export type User$coachSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    where?: CoachSessionWhereInput
    orderBy?: CoachSessionOrderByWithRelationInput | CoachSessionOrderByWithRelationInput[]
    cursor?: CoachSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CoachSessionScalarFieldEnum | CoachSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model HealthProfile
   */

  export type AggregateHealthProfile = {
    _count: HealthProfileCountAggregateOutputType | null
    _avg: HealthProfileAvgAggregateOutputType | null
    _sum: HealthProfileSumAggregateOutputType | null
    _min: HealthProfileMinAggregateOutputType | null
    _max: HealthProfileMaxAggregateOutputType | null
  }

  export type HealthProfileAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    heightCm: number | null
    weightKg: number | null
    bmi: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    healthScore: number | null
  }

  export type HealthProfileSumAggregateOutputType = {
    id: number | null
    userId: number | null
    heightCm: number | null
    weightKg: number | null
    bmi: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    healthScore: number | null
  }

  export type HealthProfileMinAggregateOutputType = {
    id: number | null
    userId: number | null
    heightCm: number | null
    weightKg: number | null
    bmi: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    conditions: string | null
    allergies: string | null
    medications: string | null
    vaccinationRecords: string | null
    healthScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthProfileMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    heightCm: number | null
    weightKg: number | null
    bmi: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    conditions: string | null
    allergies: string | null
    medications: string | null
    vaccinationRecords: string | null
    healthScore: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthProfileCountAggregateOutputType = {
    id: number
    userId: number
    heightCm: number
    weightKg: number
    bmi: number
    bloodPressureSystolic: number
    bloodPressureDiastolic: number
    heartRate: number
    conditions: number
    allergies: number
    medications: number
    vaccinationRecords: number
    healthScore: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthProfileAvgAggregateInputType = {
    id?: true
    userId?: true
    heightCm?: true
    weightKg?: true
    bmi?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    healthScore?: true
  }

  export type HealthProfileSumAggregateInputType = {
    id?: true
    userId?: true
    heightCm?: true
    weightKg?: true
    bmi?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    healthScore?: true
  }

  export type HealthProfileMinAggregateInputType = {
    id?: true
    userId?: true
    heightCm?: true
    weightKg?: true
    bmi?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    conditions?: true
    allergies?: true
    medications?: true
    vaccinationRecords?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    heightCm?: true
    weightKg?: true
    bmi?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    conditions?: true
    allergies?: true
    medications?: true
    vaccinationRecords?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthProfileCountAggregateInputType = {
    id?: true
    userId?: true
    heightCm?: true
    weightKg?: true
    bmi?: true
    bloodPressureSystolic?: true
    bloodPressureDiastolic?: true
    heartRate?: true
    conditions?: true
    allergies?: true
    medications?: true
    vaccinationRecords?: true
    healthScore?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthProfile to aggregate.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthProfiles
    **/
    _count?: true | HealthProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthProfileMaxAggregateInputType
  }

  export type GetHealthProfileAggregateType<T extends HealthProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthProfile[P]>
      : GetScalarType<T[P], AggregateHealthProfile[P]>
  }




  export type HealthProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthProfileWhereInput
    orderBy?: HealthProfileOrderByWithAggregationInput | HealthProfileOrderByWithAggregationInput[]
    by: HealthProfileScalarFieldEnum[] | HealthProfileScalarFieldEnum
    having?: HealthProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthProfileCountAggregateInputType | true
    _avg?: HealthProfileAvgAggregateInputType
    _sum?: HealthProfileSumAggregateInputType
    _min?: HealthProfileMinAggregateInputType
    _max?: HealthProfileMaxAggregateInputType
  }

  export type HealthProfileGroupByOutputType = {
    id: number
    userId: number
    heightCm: number | null
    weightKg: number | null
    bmi: number | null
    bloodPressureSystolic: number | null
    bloodPressureDiastolic: number | null
    heartRate: number | null
    conditions: string | null
    allergies: string | null
    medications: string | null
    vaccinationRecords: string | null
    healthScore: number
    createdAt: Date
    updatedAt: Date
    _count: HealthProfileCountAggregateOutputType | null
    _avg: HealthProfileAvgAggregateOutputType | null
    _sum: HealthProfileSumAggregateOutputType | null
    _min: HealthProfileMinAggregateOutputType | null
    _max: HealthProfileMaxAggregateOutputType | null
  }

  type GetHealthProfileGroupByPayload<T extends HealthProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthProfileGroupByOutputType[P]>
            : GetScalarType<T[P], HealthProfileGroupByOutputType[P]>
        }
      >
    >


  export type HealthProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    heightCm?: boolean
    weightKg?: boolean
    bmi?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    conditions?: boolean
    allergies?: boolean
    medications?: boolean
    vaccinationRecords?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthProfile"]>

  export type HealthProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    heightCm?: boolean
    weightKg?: boolean
    bmi?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    conditions?: boolean
    allergies?: boolean
    medications?: boolean
    vaccinationRecords?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthProfile"]>

  export type HealthProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    heightCm?: boolean
    weightKg?: boolean
    bmi?: boolean
    bloodPressureSystolic?: boolean
    bloodPressureDiastolic?: boolean
    heartRate?: boolean
    conditions?: boolean
    allergies?: boolean
    medications?: boolean
    vaccinationRecords?: boolean
    healthScore?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HealthProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HealthProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      heightCm: number | null
      weightKg: number | null
      bmi: number | null
      bloodPressureSystolic: number | null
      bloodPressureDiastolic: number | null
      heartRate: number | null
      conditions: string | null
      allergies: string | null
      medications: string | null
      vaccinationRecords: string | null
      healthScore: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthProfile"]>
    composites: {}
  }

  type HealthProfileGetPayload<S extends boolean | null | undefined | HealthProfileDefaultArgs> = $Result.GetResult<Prisma.$HealthProfilePayload, S>

  type HealthProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthProfileCountAggregateInputType | true
    }

  export interface HealthProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthProfile'], meta: { name: 'HealthProfile' } }
    /**
     * Find zero or one HealthProfile that matches the filter.
     * @param {HealthProfileFindUniqueArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthProfileFindUniqueArgs>(args: SelectSubset<T, HealthProfileFindUniqueArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthProfileFindUniqueOrThrowArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindFirstArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthProfileFindFirstArgs>(args?: SelectSubset<T, HealthProfileFindFirstArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindFirstOrThrowArgs} args - Arguments to find a HealthProfile
     * @example
     * // Get one HealthProfile
     * const healthProfile = await prisma.healthProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthProfiles
     * const healthProfiles = await prisma.healthProfile.findMany()
     * 
     * // Get first 10 HealthProfiles
     * const healthProfiles = await prisma.healthProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthProfileWithIdOnly = await prisma.healthProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthProfileFindManyArgs>(args?: SelectSubset<T, HealthProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthProfile.
     * @param {HealthProfileCreateArgs} args - Arguments to create a HealthProfile.
     * @example
     * // Create one HealthProfile
     * const HealthProfile = await prisma.healthProfile.create({
     *   data: {
     *     // ... data to create a HealthProfile
     *   }
     * })
     * 
     */
    create<T extends HealthProfileCreateArgs>(args: SelectSubset<T, HealthProfileCreateArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthProfiles.
     * @param {HealthProfileCreateManyArgs} args - Arguments to create many HealthProfiles.
     * @example
     * // Create many HealthProfiles
     * const healthProfile = await prisma.healthProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthProfileCreateManyArgs>(args?: SelectSubset<T, HealthProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthProfiles and returns the data saved in the database.
     * @param {HealthProfileCreateManyAndReturnArgs} args - Arguments to create many HealthProfiles.
     * @example
     * // Create many HealthProfiles
     * const healthProfile = await prisma.healthProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthProfiles and only return the `id`
     * const healthProfileWithIdOnly = await prisma.healthProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthProfile.
     * @param {HealthProfileDeleteArgs} args - Arguments to delete one HealthProfile.
     * @example
     * // Delete one HealthProfile
     * const HealthProfile = await prisma.healthProfile.delete({
     *   where: {
     *     // ... filter to delete one HealthProfile
     *   }
     * })
     * 
     */
    delete<T extends HealthProfileDeleteArgs>(args: SelectSubset<T, HealthProfileDeleteArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthProfile.
     * @param {HealthProfileUpdateArgs} args - Arguments to update one HealthProfile.
     * @example
     * // Update one HealthProfile
     * const healthProfile = await prisma.healthProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthProfileUpdateArgs>(args: SelectSubset<T, HealthProfileUpdateArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthProfiles.
     * @param {HealthProfileDeleteManyArgs} args - Arguments to filter HealthProfiles to delete.
     * @example
     * // Delete a few HealthProfiles
     * const { count } = await prisma.healthProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthProfileDeleteManyArgs>(args?: SelectSubset<T, HealthProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthProfiles
     * const healthProfile = await prisma.healthProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthProfileUpdateManyArgs>(args: SelectSubset<T, HealthProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthProfile.
     * @param {HealthProfileUpsertArgs} args - Arguments to update or create a HealthProfile.
     * @example
     * // Update or create a HealthProfile
     * const healthProfile = await prisma.healthProfile.upsert({
     *   create: {
     *     // ... data to create a HealthProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthProfile we want to update
     *   }
     * })
     */
    upsert<T extends HealthProfileUpsertArgs>(args: SelectSubset<T, HealthProfileUpsertArgs<ExtArgs>>): Prisma__HealthProfileClient<$Result.GetResult<Prisma.$HealthProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileCountArgs} args - Arguments to filter HealthProfiles to count.
     * @example
     * // Count the number of HealthProfiles
     * const count = await prisma.healthProfile.count({
     *   where: {
     *     // ... the filter for the HealthProfiles we want to count
     *   }
     * })
    **/
    count<T extends HealthProfileCountArgs>(
      args?: Subset<T, HealthProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthProfileAggregateArgs>(args: Subset<T, HealthProfileAggregateArgs>): Prisma.PrismaPromise<GetHealthProfileAggregateType<T>>

    /**
     * Group by HealthProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthProfileGroupByArgs['orderBy'] }
        : { orderBy?: HealthProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthProfile model
   */
  readonly fields: HealthProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthProfile model
   */ 
  interface HealthProfileFieldRefs {
    readonly id: FieldRef<"HealthProfile", 'Int'>
    readonly userId: FieldRef<"HealthProfile", 'Int'>
    readonly heightCm: FieldRef<"HealthProfile", 'Float'>
    readonly weightKg: FieldRef<"HealthProfile", 'Float'>
    readonly bmi: FieldRef<"HealthProfile", 'Float'>
    readonly bloodPressureSystolic: FieldRef<"HealthProfile", 'Int'>
    readonly bloodPressureDiastolic: FieldRef<"HealthProfile", 'Int'>
    readonly heartRate: FieldRef<"HealthProfile", 'Int'>
    readonly conditions: FieldRef<"HealthProfile", 'String'>
    readonly allergies: FieldRef<"HealthProfile", 'String'>
    readonly medications: FieldRef<"HealthProfile", 'String'>
    readonly vaccinationRecords: FieldRef<"HealthProfile", 'String'>
    readonly healthScore: FieldRef<"HealthProfile", 'Int'>
    readonly createdAt: FieldRef<"HealthProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthProfile findUnique
   */
  export type HealthProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile findUniqueOrThrow
   */
  export type HealthProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile findFirst
   */
  export type HealthProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthProfiles.
     */
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile findFirstOrThrow
   */
  export type HealthProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfile to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthProfiles.
     */
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile findMany
   */
  export type HealthProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter, which HealthProfiles to fetch.
     */
    where?: HealthProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthProfiles to fetch.
     */
    orderBy?: HealthProfileOrderByWithRelationInput | HealthProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthProfiles.
     */
    cursor?: HealthProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthProfiles.
     */
    skip?: number
    distinct?: HealthProfileScalarFieldEnum | HealthProfileScalarFieldEnum[]
  }

  /**
   * HealthProfile create
   */
  export type HealthProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthProfile.
     */
    data: XOR<HealthProfileCreateInput, HealthProfileUncheckedCreateInput>
  }

  /**
   * HealthProfile createMany
   */
  export type HealthProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthProfiles.
     */
    data: HealthProfileCreateManyInput | HealthProfileCreateManyInput[]
  }

  /**
   * HealthProfile createManyAndReturn
   */
  export type HealthProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthProfiles.
     */
    data: HealthProfileCreateManyInput | HealthProfileCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthProfile update
   */
  export type HealthProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthProfile.
     */
    data: XOR<HealthProfileUpdateInput, HealthProfileUncheckedUpdateInput>
    /**
     * Choose, which HealthProfile to update.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile updateMany
   */
  export type HealthProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthProfiles.
     */
    data: XOR<HealthProfileUpdateManyMutationInput, HealthProfileUncheckedUpdateManyInput>
    /**
     * Filter which HealthProfiles to update
     */
    where?: HealthProfileWhereInput
  }

  /**
   * HealthProfile upsert
   */
  export type HealthProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthProfile to update in case it exists.
     */
    where: HealthProfileWhereUniqueInput
    /**
     * In case the HealthProfile found by the `where` argument doesn't exist, create a new HealthProfile with this data.
     */
    create: XOR<HealthProfileCreateInput, HealthProfileUncheckedCreateInput>
    /**
     * In case the HealthProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthProfileUpdateInput, HealthProfileUncheckedUpdateInput>
  }

  /**
   * HealthProfile delete
   */
  export type HealthProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
    /**
     * Filter which HealthProfile to delete.
     */
    where: HealthProfileWhereUniqueInput
  }

  /**
   * HealthProfile deleteMany
   */
  export type HealthProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthProfiles to delete
     */
    where?: HealthProfileWhereInput
  }

  /**
   * HealthProfile without action
   */
  export type HealthProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthProfile
     */
    select?: HealthProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthProfileInclude<ExtArgs> | null
  }


  /**
   * Model Doctor
   */

  export type AggregateDoctor = {
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  export type DoctorAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    experienceYears: number | null
    latitude: number | null
    longitude: number | null
    consultationFee: number | null
    averageRating: number | null
    totalRatings: number | null
  }

  export type DoctorSumAggregateOutputType = {
    id: number | null
    userId: number | null
    experienceYears: number | null
    latitude: number | null
    longitude: number | null
    consultationFee: number | null
    averageRating: number | null
    totalRatings: number | null
  }

  export type DoctorMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    specialty: string | null
    qualifications: string | null
    experienceYears: number | null
    licenseNumber: string | null
    clinicName: string | null
    clinicAddress: string | null
    latitude: number | null
    longitude: number | null
    consultationFee: number | null
    averageRating: number | null
    totalRatings: number | null
    availability: string | null
    isVerified: boolean | null
    verificationDocuments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    specialty: string | null
    qualifications: string | null
    experienceYears: number | null
    licenseNumber: string | null
    clinicName: string | null
    clinicAddress: string | null
    latitude: number | null
    longitude: number | null
    consultationFee: number | null
    averageRating: number | null
    totalRatings: number | null
    availability: string | null
    isVerified: boolean | null
    verificationDocuments: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DoctorCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    specialty: number
    qualifications: number
    experienceYears: number
    licenseNumber: number
    clinicName: number
    clinicAddress: number
    latitude: number
    longitude: number
    consultationFee: number
    averageRating: number
    totalRatings: number
    availability: number
    isVerified: number
    verificationDocuments: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DoctorAvgAggregateInputType = {
    id?: true
    userId?: true
    experienceYears?: true
    latitude?: true
    longitude?: true
    consultationFee?: true
    averageRating?: true
    totalRatings?: true
  }

  export type DoctorSumAggregateInputType = {
    id?: true
    userId?: true
    experienceYears?: true
    latitude?: true
    longitude?: true
    consultationFee?: true
    averageRating?: true
    totalRatings?: true
  }

  export type DoctorMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    specialty?: true
    qualifications?: true
    experienceYears?: true
    licenseNumber?: true
    clinicName?: true
    clinicAddress?: true
    latitude?: true
    longitude?: true
    consultationFee?: true
    averageRating?: true
    totalRatings?: true
    availability?: true
    isVerified?: true
    verificationDocuments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    specialty?: true
    qualifications?: true
    experienceYears?: true
    licenseNumber?: true
    clinicName?: true
    clinicAddress?: true
    latitude?: true
    longitude?: true
    consultationFee?: true
    averageRating?: true
    totalRatings?: true
    availability?: true
    isVerified?: true
    verificationDocuments?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DoctorCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    specialty?: true
    qualifications?: true
    experienceYears?: true
    licenseNumber?: true
    clinicName?: true
    clinicAddress?: true
    latitude?: true
    longitude?: true
    consultationFee?: true
    averageRating?: true
    totalRatings?: true
    availability?: true
    isVerified?: true
    verificationDocuments?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DoctorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctor to aggregate.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Doctors
    **/
    _count?: true | DoctorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorMaxAggregateInputType
  }

  export type GetDoctorAggregateType<T extends DoctorAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctor[P]>
      : GetScalarType<T[P], AggregateDoctor[P]>
  }




  export type DoctorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorWhereInput
    orderBy?: DoctorOrderByWithAggregationInput | DoctorOrderByWithAggregationInput[]
    by: DoctorScalarFieldEnum[] | DoctorScalarFieldEnum
    having?: DoctorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorCountAggregateInputType | true
    _avg?: DoctorAvgAggregateInputType
    _sum?: DoctorSumAggregateInputType
    _min?: DoctorMinAggregateInputType
    _max?: DoctorMaxAggregateInputType
  }

  export type DoctorGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    specialty: string
    qualifications: string | null
    experienceYears: number | null
    licenseNumber: string | null
    clinicName: string | null
    clinicAddress: string | null
    latitude: number | null
    longitude: number | null
    consultationFee: number
    averageRating: number
    totalRatings: number
    availability: string | null
    isVerified: boolean
    verificationDocuments: string | null
    createdAt: Date
    updatedAt: Date
    _count: DoctorCountAggregateOutputType | null
    _avg: DoctorAvgAggregateOutputType | null
    _sum: DoctorSumAggregateOutputType | null
    _min: DoctorMinAggregateOutputType | null
    _max: DoctorMaxAggregateOutputType | null
  }

  type GetDoctorGroupByPayload<T extends DoctorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorGroupByOutputType[P]>
        }
      >
    >


  export type DoctorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    specialty?: boolean
    qualifications?: boolean
    experienceYears?: boolean
    licenseNumber?: boolean
    clinicName?: boolean
    clinicAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    consultationFee?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    availability?: boolean
    isVerified?: boolean
    verificationDocuments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    reviews?: boolean | Doctor$reviewsArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    specialty?: boolean
    qualifications?: boolean
    experienceYears?: boolean
    licenseNumber?: boolean
    clinicName?: boolean
    clinicAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    consultationFee?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    availability?: boolean
    isVerified?: boolean
    verificationDocuments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["doctor"]>

  export type DoctorSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    specialty?: boolean
    qualifications?: boolean
    experienceYears?: boolean
    licenseNumber?: boolean
    clinicName?: boolean
    clinicAddress?: boolean
    latitude?: boolean
    longitude?: boolean
    consultationFee?: boolean
    averageRating?: boolean
    totalRatings?: boolean
    availability?: boolean
    isVerified?: boolean
    verificationDocuments?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DoctorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointments?: boolean | Doctor$appointmentsArgs<ExtArgs>
    reviews?: boolean | Doctor$reviewsArgs<ExtArgs>
    _count?: boolean | DoctorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DoctorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DoctorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Doctor"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      reviews: Prisma.$DoctorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      specialty: string
      qualifications: string | null
      experienceYears: number | null
      licenseNumber: string | null
      clinicName: string | null
      clinicAddress: string | null
      latitude: number | null
      longitude: number | null
      consultationFee: number
      averageRating: number
      totalRatings: number
      availability: string | null
      isVerified: boolean
      verificationDocuments: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["doctor"]>
    composites: {}
  }

  type DoctorGetPayload<S extends boolean | null | undefined | DoctorDefaultArgs> = $Result.GetResult<Prisma.$DoctorPayload, S>

  type DoctorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorCountAggregateInputType | true
    }

  export interface DoctorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Doctor'], meta: { name: 'Doctor' } }
    /**
     * Find zero or one Doctor that matches the filter.
     * @param {DoctorFindUniqueArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorFindUniqueArgs>(args: SelectSubset<T, DoctorFindUniqueArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Doctor that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorFindUniqueOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Doctor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorFindFirstArgs>(args?: SelectSubset<T, DoctorFindFirstArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Doctor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindFirstOrThrowArgs} args - Arguments to find a Doctor
     * @example
     * // Get one Doctor
     * const doctor = await prisma.doctor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Doctors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Doctors
     * const doctors = await prisma.doctor.findMany()
     * 
     * // Get first 10 Doctors
     * const doctors = await prisma.doctor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorWithIdOnly = await prisma.doctor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorFindManyArgs>(args?: SelectSubset<T, DoctorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Doctor.
     * @param {DoctorCreateArgs} args - Arguments to create a Doctor.
     * @example
     * // Create one Doctor
     * const Doctor = await prisma.doctor.create({
     *   data: {
     *     // ... data to create a Doctor
     *   }
     * })
     * 
     */
    create<T extends DoctorCreateArgs>(args: SelectSubset<T, DoctorCreateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Doctors.
     * @param {DoctorCreateManyArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorCreateManyArgs>(args?: SelectSubset<T, DoctorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Doctors and returns the data saved in the database.
     * @param {DoctorCreateManyAndReturnArgs} args - Arguments to create many Doctors.
     * @example
     * // Create many Doctors
     * const doctor = await prisma.doctor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Doctors and only return the `id`
     * const doctorWithIdOnly = await prisma.doctor.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Doctor.
     * @param {DoctorDeleteArgs} args - Arguments to delete one Doctor.
     * @example
     * // Delete one Doctor
     * const Doctor = await prisma.doctor.delete({
     *   where: {
     *     // ... filter to delete one Doctor
     *   }
     * })
     * 
     */
    delete<T extends DoctorDeleteArgs>(args: SelectSubset<T, DoctorDeleteArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Doctor.
     * @param {DoctorUpdateArgs} args - Arguments to update one Doctor.
     * @example
     * // Update one Doctor
     * const doctor = await prisma.doctor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorUpdateArgs>(args: SelectSubset<T, DoctorUpdateArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Doctors.
     * @param {DoctorDeleteManyArgs} args - Arguments to filter Doctors to delete.
     * @example
     * // Delete a few Doctors
     * const { count } = await prisma.doctor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorDeleteManyArgs>(args?: SelectSubset<T, DoctorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Doctors
     * const doctor = await prisma.doctor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorUpdateManyArgs>(args: SelectSubset<T, DoctorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Doctor.
     * @param {DoctorUpsertArgs} args - Arguments to update or create a Doctor.
     * @example
     * // Update or create a Doctor
     * const doctor = await prisma.doctor.upsert({
     *   create: {
     *     // ... data to create a Doctor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Doctor we want to update
     *   }
     * })
     */
    upsert<T extends DoctorUpsertArgs>(args: SelectSubset<T, DoctorUpsertArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Doctors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorCountArgs} args - Arguments to filter Doctors to count.
     * @example
     * // Count the number of Doctors
     * const count = await prisma.doctor.count({
     *   where: {
     *     // ... the filter for the Doctors we want to count
     *   }
     * })
    **/
    count<T extends DoctorCountArgs>(
      args?: Subset<T, DoctorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorAggregateArgs>(args: Subset<T, DoctorAggregateArgs>): Prisma.PrismaPromise<GetDoctorAggregateType<T>>

    /**
     * Group by Doctor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorGroupByArgs['orderBy'] }
        : { orderBy?: DoctorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Doctor model
   */
  readonly fields: DoctorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Doctor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointments<T extends Doctor$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    reviews<T extends Doctor$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Doctor$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Doctor model
   */ 
  interface DoctorFieldRefs {
    readonly id: FieldRef<"Doctor", 'Int'>
    readonly uuid: FieldRef<"Doctor", 'String'>
    readonly userId: FieldRef<"Doctor", 'Int'>
    readonly specialty: FieldRef<"Doctor", 'String'>
    readonly qualifications: FieldRef<"Doctor", 'String'>
    readonly experienceYears: FieldRef<"Doctor", 'Int'>
    readonly licenseNumber: FieldRef<"Doctor", 'String'>
    readonly clinicName: FieldRef<"Doctor", 'String'>
    readonly clinicAddress: FieldRef<"Doctor", 'String'>
    readonly latitude: FieldRef<"Doctor", 'Float'>
    readonly longitude: FieldRef<"Doctor", 'Float'>
    readonly consultationFee: FieldRef<"Doctor", 'Float'>
    readonly averageRating: FieldRef<"Doctor", 'Float'>
    readonly totalRatings: FieldRef<"Doctor", 'Int'>
    readonly availability: FieldRef<"Doctor", 'String'>
    readonly isVerified: FieldRef<"Doctor", 'Boolean'>
    readonly verificationDocuments: FieldRef<"Doctor", 'String'>
    readonly createdAt: FieldRef<"Doctor", 'DateTime'>
    readonly updatedAt: FieldRef<"Doctor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Doctor findUnique
   */
  export type DoctorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findUniqueOrThrow
   */
  export type DoctorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor findFirst
   */
  export type DoctorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findFirstOrThrow
   */
  export type DoctorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctor to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Doctors.
     */
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor findMany
   */
  export type DoctorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter, which Doctors to fetch.
     */
    where?: DoctorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Doctors to fetch.
     */
    orderBy?: DoctorOrderByWithRelationInput | DoctorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Doctors.
     */
    cursor?: DoctorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Doctors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Doctors.
     */
    skip?: number
    distinct?: DoctorScalarFieldEnum | DoctorScalarFieldEnum[]
  }

  /**
   * Doctor create
   */
  export type DoctorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to create a Doctor.
     */
    data: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
  }

  /**
   * Doctor createMany
   */
  export type DoctorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
  }

  /**
   * Doctor createManyAndReturn
   */
  export type DoctorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Doctors.
     */
    data: DoctorCreateManyInput | DoctorCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Doctor update
   */
  export type DoctorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The data needed to update a Doctor.
     */
    data: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
    /**
     * Choose, which Doctor to update.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor updateMany
   */
  export type DoctorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Doctors.
     */
    data: XOR<DoctorUpdateManyMutationInput, DoctorUncheckedUpdateManyInput>
    /**
     * Filter which Doctors to update
     */
    where?: DoctorWhereInput
  }

  /**
   * Doctor upsert
   */
  export type DoctorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * The filter to search for the Doctor to update in case it exists.
     */
    where: DoctorWhereUniqueInput
    /**
     * In case the Doctor found by the `where` argument doesn't exist, create a new Doctor with this data.
     */
    create: XOR<DoctorCreateInput, DoctorUncheckedCreateInput>
    /**
     * In case the Doctor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorUpdateInput, DoctorUncheckedUpdateInput>
  }

  /**
   * Doctor delete
   */
  export type DoctorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
    /**
     * Filter which Doctor to delete.
     */
    where: DoctorWhereUniqueInput
  }

  /**
   * Doctor deleteMany
   */
  export type DoctorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Doctors to delete
     */
    where?: DoctorWhereInput
  }

  /**
   * Doctor.appointments
   */
  export type Doctor$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Doctor.reviews
   */
  export type Doctor$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    where?: DoctorReviewWhereInput
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    cursor?: DoctorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * Doctor without action
   */
  export type DoctorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Doctor
     */
    select?: DoctorSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorInclude<ExtArgs> | null
  }


  /**
   * Model DoctorReview
   */

  export type AggregateDoctorReview = {
    _count: DoctorReviewCountAggregateOutputType | null
    _avg: DoctorReviewAvgAggregateOutputType | null
    _sum: DoctorReviewSumAggregateOutputType | null
    _min: DoctorReviewMinAggregateOutputType | null
    _max: DoctorReviewMaxAggregateOutputType | null
  }

  export type DoctorReviewAvgAggregateOutputType = {
    id: number | null
    doctorId: number | null
    userId: number | null
    appointmentId: number | null
    rating: number | null
    helpfulCount: number | null
  }

  export type DoctorReviewSumAggregateOutputType = {
    id: number | null
    doctorId: number | null
    userId: number | null
    appointmentId: number | null
    rating: number | null
    helpfulCount: number | null
  }

  export type DoctorReviewMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    doctorId: number | null
    userId: number | null
    appointmentId: number | null
    rating: number | null
    review: string | null
    verified: boolean | null
    helpfulCount: number | null
    createdAt: Date | null
  }

  export type DoctorReviewMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    doctorId: number | null
    userId: number | null
    appointmentId: number | null
    rating: number | null
    review: string | null
    verified: boolean | null
    helpfulCount: number | null
    createdAt: Date | null
  }

  export type DoctorReviewCountAggregateOutputType = {
    id: number
    uuid: number
    doctorId: number
    userId: number
    appointmentId: number
    rating: number
    review: number
    verified: number
    helpfulCount: number
    createdAt: number
    _all: number
  }


  export type DoctorReviewAvgAggregateInputType = {
    id?: true
    doctorId?: true
    userId?: true
    appointmentId?: true
    rating?: true
    helpfulCount?: true
  }

  export type DoctorReviewSumAggregateInputType = {
    id?: true
    doctorId?: true
    userId?: true
    appointmentId?: true
    rating?: true
    helpfulCount?: true
  }

  export type DoctorReviewMinAggregateInputType = {
    id?: true
    uuid?: true
    doctorId?: true
    userId?: true
    appointmentId?: true
    rating?: true
    review?: true
    verified?: true
    helpfulCount?: true
    createdAt?: true
  }

  export type DoctorReviewMaxAggregateInputType = {
    id?: true
    uuid?: true
    doctorId?: true
    userId?: true
    appointmentId?: true
    rating?: true
    review?: true
    verified?: true
    helpfulCount?: true
    createdAt?: true
  }

  export type DoctorReviewCountAggregateInputType = {
    id?: true
    uuid?: true
    doctorId?: true
    userId?: true
    appointmentId?: true
    rating?: true
    review?: true
    verified?: true
    helpfulCount?: true
    createdAt?: true
    _all?: true
  }

  export type DoctorReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorReview to aggregate.
     */
    where?: DoctorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorReviews to fetch.
     */
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DoctorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DoctorReviews
    **/
    _count?: true | DoctorReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DoctorReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DoctorReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DoctorReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DoctorReviewMaxAggregateInputType
  }

  export type GetDoctorReviewAggregateType<T extends DoctorReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateDoctorReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDoctorReview[P]>
      : GetScalarType<T[P], AggregateDoctorReview[P]>
  }




  export type DoctorReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DoctorReviewWhereInput
    orderBy?: DoctorReviewOrderByWithAggregationInput | DoctorReviewOrderByWithAggregationInput[]
    by: DoctorReviewScalarFieldEnum[] | DoctorReviewScalarFieldEnum
    having?: DoctorReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DoctorReviewCountAggregateInputType | true
    _avg?: DoctorReviewAvgAggregateInputType
    _sum?: DoctorReviewSumAggregateInputType
    _min?: DoctorReviewMinAggregateInputType
    _max?: DoctorReviewMaxAggregateInputType
  }

  export type DoctorReviewGroupByOutputType = {
    id: number
    uuid: string
    doctorId: number
    userId: number
    appointmentId: number | null
    rating: number
    review: string | null
    verified: boolean
    helpfulCount: number
    createdAt: Date
    _count: DoctorReviewCountAggregateOutputType | null
    _avg: DoctorReviewAvgAggregateOutputType | null
    _sum: DoctorReviewSumAggregateOutputType | null
    _min: DoctorReviewMinAggregateOutputType | null
    _max: DoctorReviewMaxAggregateOutputType | null
  }

  type GetDoctorReviewGroupByPayload<T extends DoctorReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DoctorReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DoctorReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DoctorReviewGroupByOutputType[P]>
            : GetScalarType<T[P], DoctorReviewGroupByOutputType[P]>
        }
      >
    >


  export type DoctorReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    doctorId?: boolean
    userId?: boolean
    appointmentId?: boolean
    rating?: boolean
    review?: boolean
    verified?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | DoctorReview$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["doctorReview"]>

  export type DoctorReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    doctorId?: boolean
    userId?: boolean
    appointmentId?: boolean
    rating?: boolean
    review?: boolean
    verified?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | DoctorReview$appointmentArgs<ExtArgs>
  }, ExtArgs["result"]["doctorReview"]>

  export type DoctorReviewSelectScalar = {
    id?: boolean
    uuid?: boolean
    doctorId?: boolean
    userId?: boolean
    appointmentId?: boolean
    rating?: boolean
    review?: boolean
    verified?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
  }

  export type DoctorReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | DoctorReview$appointmentArgs<ExtArgs>
  }
  export type DoctorReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    doctor?: boolean | DoctorDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    appointment?: boolean | DoctorReview$appointmentArgs<ExtArgs>
  }

  export type $DoctorReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DoctorReview"
    objects: {
      doctor: Prisma.$DoctorPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      appointment: Prisma.$AppointmentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      doctorId: number
      userId: number
      appointmentId: number | null
      rating: number
      review: string | null
      verified: boolean
      helpfulCount: number
      createdAt: Date
    }, ExtArgs["result"]["doctorReview"]>
    composites: {}
  }

  type DoctorReviewGetPayload<S extends boolean | null | undefined | DoctorReviewDefaultArgs> = $Result.GetResult<Prisma.$DoctorReviewPayload, S>

  type DoctorReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DoctorReviewFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DoctorReviewCountAggregateInputType | true
    }

  export interface DoctorReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DoctorReview'], meta: { name: 'DoctorReview' } }
    /**
     * Find zero or one DoctorReview that matches the filter.
     * @param {DoctorReviewFindUniqueArgs} args - Arguments to find a DoctorReview
     * @example
     * // Get one DoctorReview
     * const doctorReview = await prisma.doctorReview.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DoctorReviewFindUniqueArgs>(args: SelectSubset<T, DoctorReviewFindUniqueArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DoctorReview that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DoctorReviewFindUniqueOrThrowArgs} args - Arguments to find a DoctorReview
     * @example
     * // Get one DoctorReview
     * const doctorReview = await prisma.doctorReview.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DoctorReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, DoctorReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DoctorReview that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewFindFirstArgs} args - Arguments to find a DoctorReview
     * @example
     * // Get one DoctorReview
     * const doctorReview = await prisma.doctorReview.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DoctorReviewFindFirstArgs>(args?: SelectSubset<T, DoctorReviewFindFirstArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DoctorReview that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewFindFirstOrThrowArgs} args - Arguments to find a DoctorReview
     * @example
     * // Get one DoctorReview
     * const doctorReview = await prisma.doctorReview.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DoctorReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, DoctorReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DoctorReviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DoctorReviews
     * const doctorReviews = await prisma.doctorReview.findMany()
     * 
     * // Get first 10 DoctorReviews
     * const doctorReviews = await prisma.doctorReview.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const doctorReviewWithIdOnly = await prisma.doctorReview.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DoctorReviewFindManyArgs>(args?: SelectSubset<T, DoctorReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DoctorReview.
     * @param {DoctorReviewCreateArgs} args - Arguments to create a DoctorReview.
     * @example
     * // Create one DoctorReview
     * const DoctorReview = await prisma.doctorReview.create({
     *   data: {
     *     // ... data to create a DoctorReview
     *   }
     * })
     * 
     */
    create<T extends DoctorReviewCreateArgs>(args: SelectSubset<T, DoctorReviewCreateArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DoctorReviews.
     * @param {DoctorReviewCreateManyArgs} args - Arguments to create many DoctorReviews.
     * @example
     * // Create many DoctorReviews
     * const doctorReview = await prisma.doctorReview.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DoctorReviewCreateManyArgs>(args?: SelectSubset<T, DoctorReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DoctorReviews and returns the data saved in the database.
     * @param {DoctorReviewCreateManyAndReturnArgs} args - Arguments to create many DoctorReviews.
     * @example
     * // Create many DoctorReviews
     * const doctorReview = await prisma.doctorReview.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DoctorReviews and only return the `id`
     * const doctorReviewWithIdOnly = await prisma.doctorReview.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DoctorReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, DoctorReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a DoctorReview.
     * @param {DoctorReviewDeleteArgs} args - Arguments to delete one DoctorReview.
     * @example
     * // Delete one DoctorReview
     * const DoctorReview = await prisma.doctorReview.delete({
     *   where: {
     *     // ... filter to delete one DoctorReview
     *   }
     * })
     * 
     */
    delete<T extends DoctorReviewDeleteArgs>(args: SelectSubset<T, DoctorReviewDeleteArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DoctorReview.
     * @param {DoctorReviewUpdateArgs} args - Arguments to update one DoctorReview.
     * @example
     * // Update one DoctorReview
     * const doctorReview = await prisma.doctorReview.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DoctorReviewUpdateArgs>(args: SelectSubset<T, DoctorReviewUpdateArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DoctorReviews.
     * @param {DoctorReviewDeleteManyArgs} args - Arguments to filter DoctorReviews to delete.
     * @example
     * // Delete a few DoctorReviews
     * const { count } = await prisma.doctorReview.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DoctorReviewDeleteManyArgs>(args?: SelectSubset<T, DoctorReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DoctorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DoctorReviews
     * const doctorReview = await prisma.doctorReview.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DoctorReviewUpdateManyArgs>(args: SelectSubset<T, DoctorReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DoctorReview.
     * @param {DoctorReviewUpsertArgs} args - Arguments to update or create a DoctorReview.
     * @example
     * // Update or create a DoctorReview
     * const doctorReview = await prisma.doctorReview.upsert({
     *   create: {
     *     // ... data to create a DoctorReview
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DoctorReview we want to update
     *   }
     * })
     */
    upsert<T extends DoctorReviewUpsertArgs>(args: SelectSubset<T, DoctorReviewUpsertArgs<ExtArgs>>): Prisma__DoctorReviewClient<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DoctorReviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewCountArgs} args - Arguments to filter DoctorReviews to count.
     * @example
     * // Count the number of DoctorReviews
     * const count = await prisma.doctorReview.count({
     *   where: {
     *     // ... the filter for the DoctorReviews we want to count
     *   }
     * })
    **/
    count<T extends DoctorReviewCountArgs>(
      args?: Subset<T, DoctorReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DoctorReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DoctorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DoctorReviewAggregateArgs>(args: Subset<T, DoctorReviewAggregateArgs>): Prisma.PrismaPromise<GetDoctorReviewAggregateType<T>>

    /**
     * Group by DoctorReview.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DoctorReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DoctorReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DoctorReviewGroupByArgs['orderBy'] }
        : { orderBy?: DoctorReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DoctorReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDoctorReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DoctorReview model
   */
  readonly fields: DoctorReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DoctorReview.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DoctorReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    doctor<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    appointment<T extends DoctorReview$appointmentArgs<ExtArgs> = {}>(args?: Subset<T, DoctorReview$appointmentArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DoctorReview model
   */ 
  interface DoctorReviewFieldRefs {
    readonly id: FieldRef<"DoctorReview", 'Int'>
    readonly uuid: FieldRef<"DoctorReview", 'String'>
    readonly doctorId: FieldRef<"DoctorReview", 'Int'>
    readonly userId: FieldRef<"DoctorReview", 'Int'>
    readonly appointmentId: FieldRef<"DoctorReview", 'Int'>
    readonly rating: FieldRef<"DoctorReview", 'Int'>
    readonly review: FieldRef<"DoctorReview", 'String'>
    readonly verified: FieldRef<"DoctorReview", 'Boolean'>
    readonly helpfulCount: FieldRef<"DoctorReview", 'Int'>
    readonly createdAt: FieldRef<"DoctorReview", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DoctorReview findUnique
   */
  export type DoctorReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter, which DoctorReview to fetch.
     */
    where: DoctorReviewWhereUniqueInput
  }

  /**
   * DoctorReview findUniqueOrThrow
   */
  export type DoctorReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter, which DoctorReview to fetch.
     */
    where: DoctorReviewWhereUniqueInput
  }

  /**
   * DoctorReview findFirst
   */
  export type DoctorReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter, which DoctorReview to fetch.
     */
    where?: DoctorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorReviews to fetch.
     */
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorReviews.
     */
    cursor?: DoctorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorReviews.
     */
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * DoctorReview findFirstOrThrow
   */
  export type DoctorReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter, which DoctorReview to fetch.
     */
    where?: DoctorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorReviews to fetch.
     */
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DoctorReviews.
     */
    cursor?: DoctorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorReviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DoctorReviews.
     */
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * DoctorReview findMany
   */
  export type DoctorReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter, which DoctorReviews to fetch.
     */
    where?: DoctorReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DoctorReviews to fetch.
     */
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DoctorReviews.
     */
    cursor?: DoctorReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DoctorReviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DoctorReviews.
     */
    skip?: number
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * DoctorReview create
   */
  export type DoctorReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a DoctorReview.
     */
    data: XOR<DoctorReviewCreateInput, DoctorReviewUncheckedCreateInput>
  }

  /**
   * DoctorReview createMany
   */
  export type DoctorReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DoctorReviews.
     */
    data: DoctorReviewCreateManyInput | DoctorReviewCreateManyInput[]
  }

  /**
   * DoctorReview createManyAndReturn
   */
  export type DoctorReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many DoctorReviews.
     */
    data: DoctorReviewCreateManyInput | DoctorReviewCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DoctorReview update
   */
  export type DoctorReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a DoctorReview.
     */
    data: XOR<DoctorReviewUpdateInput, DoctorReviewUncheckedUpdateInput>
    /**
     * Choose, which DoctorReview to update.
     */
    where: DoctorReviewWhereUniqueInput
  }

  /**
   * DoctorReview updateMany
   */
  export type DoctorReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DoctorReviews.
     */
    data: XOR<DoctorReviewUpdateManyMutationInput, DoctorReviewUncheckedUpdateManyInput>
    /**
     * Filter which DoctorReviews to update
     */
    where?: DoctorReviewWhereInput
  }

  /**
   * DoctorReview upsert
   */
  export type DoctorReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the DoctorReview to update in case it exists.
     */
    where: DoctorReviewWhereUniqueInput
    /**
     * In case the DoctorReview found by the `where` argument doesn't exist, create a new DoctorReview with this data.
     */
    create: XOR<DoctorReviewCreateInput, DoctorReviewUncheckedCreateInput>
    /**
     * In case the DoctorReview was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DoctorReviewUpdateInput, DoctorReviewUncheckedUpdateInput>
  }

  /**
   * DoctorReview delete
   */
  export type DoctorReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    /**
     * Filter which DoctorReview to delete.
     */
    where: DoctorReviewWhereUniqueInput
  }

  /**
   * DoctorReview deleteMany
   */
  export type DoctorReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DoctorReviews to delete
     */
    where?: DoctorReviewWhereInput
  }

  /**
   * DoctorReview.appointment
   */
  export type DoctorReview$appointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
  }

  /**
   * DoctorReview without action
   */
  export type DoctorReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    doctorId: number | null
    prescriptionId: number | null
  }

  export type AppointmentSumAggregateOutputType = {
    id: number | null
    userId: number | null
    doctorId: number | null
    prescriptionId: number | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    doctorId: number | null
    appointmentDate: Date | null
    consultationType: string | null
    status: string | null
    reason: string | null
    notes: string | null
    meetingLink: string | null
    recordingUrl: string | null
    prescriptionId: number | null
    paymentId: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    doctorId: number | null
    appointmentDate: Date | null
    consultationType: string | null
    status: string | null
    reason: string | null
    notes: string | null
    meetingLink: string | null
    recordingUrl: string | null
    prescriptionId: number | null
    paymentId: string | null
    paymentStatus: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    doctorId: number
    appointmentDate: number
    consultationType: number
    status: number
    reason: number
    notes: number
    meetingLink: number
    recordingUrl: number
    prescriptionId: number
    paymentId: number
    paymentStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentAvgAggregateInputType = {
    id?: true
    userId?: true
    doctorId?: true
    prescriptionId?: true
  }

  export type AppointmentSumAggregateInputType = {
    id?: true
    userId?: true
    doctorId?: true
    prescriptionId?: true
  }

  export type AppointmentMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    doctorId?: true
    appointmentDate?: true
    consultationType?: true
    status?: true
    reason?: true
    notes?: true
    meetingLink?: true
    recordingUrl?: true
    prescriptionId?: true
    paymentId?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    doctorId?: true
    appointmentDate?: true
    consultationType?: true
    status?: true
    reason?: true
    notes?: true
    meetingLink?: true
    recordingUrl?: true
    prescriptionId?: true
    paymentId?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    doctorId?: true
    appointmentDate?: true
    consultationType?: true
    status?: true
    reason?: true
    notes?: true
    meetingLink?: true
    recordingUrl?: true
    prescriptionId?: true
    paymentId?: true
    paymentStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppointmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppointmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _avg?: AppointmentAvgAggregateInputType
    _sum?: AppointmentSumAggregateInputType
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    doctorId: number
    appointmentDate: Date
    consultationType: string
    status: string
    reason: string | null
    notes: string | null
    meetingLink: string | null
    recordingUrl: string | null
    prescriptionId: number | null
    paymentId: string | null
    paymentStatus: string
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _avg: AppointmentAvgAggregateOutputType | null
    _sum: AppointmentSumAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    consultationType?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    meetingLink?: boolean
    recordingUrl?: boolean
    prescriptionId?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    doctorProfile?: boolean | DoctorDefaultArgs<ExtArgs>
    prescription?: boolean | Appointment$prescriptionArgs<ExtArgs>
    callSession?: boolean | Appointment$callSessionArgs<ExtArgs>
    reviews?: boolean | Appointment$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    consultationType?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    meetingLink?: boolean
    recordingUrl?: boolean
    prescriptionId?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    doctorProfile?: boolean | DoctorDefaultArgs<ExtArgs>
    prescription?: boolean | Appointment$prescriptionArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    doctorId?: boolean
    appointmentDate?: boolean
    consultationType?: boolean
    status?: boolean
    reason?: boolean
    notes?: boolean
    meetingLink?: boolean
    recordingUrl?: boolean
    prescriptionId?: boolean
    paymentId?: boolean
    paymentStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    doctorProfile?: boolean | DoctorDefaultArgs<ExtArgs>
    prescription?: boolean | Appointment$prescriptionArgs<ExtArgs>
    callSession?: boolean | Appointment$callSessionArgs<ExtArgs>
    reviews?: boolean | Appointment$reviewsArgs<ExtArgs>
    _count?: boolean | AppointmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    doctor?: boolean | UserDefaultArgs<ExtArgs>
    doctorProfile?: boolean | DoctorDefaultArgs<ExtArgs>
    prescription?: boolean | Appointment$prescriptionArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      doctor: Prisma.$UserPayload<ExtArgs>
      doctorProfile: Prisma.$DoctorPayload<ExtArgs>
      prescription: Prisma.$PrescriptionPayload<ExtArgs> | null
      callSession: Prisma.$CallSessionPayload<ExtArgs> | null
      reviews: Prisma.$DoctorReviewPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      doctorId: number
      appointmentDate: Date
      consultationType: string
      status: string
      reason: string | null
      notes: string | null
      meetingLink: string | null
      recordingUrl: string | null
      prescriptionId: number | null
      paymentId: string | null
      paymentStatus: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctor<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    doctorProfile<T extends DoctorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DoctorDefaultArgs<ExtArgs>>): Prisma__DoctorClient<$Result.GetResult<Prisma.$DoctorPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    prescription<T extends Appointment$prescriptionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$prescriptionArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    callSession<T extends Appointment$callSessionArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$callSessionArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reviews<T extends Appointment$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Appointment$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DoctorReviewPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'Int'>
    readonly uuid: FieldRef<"Appointment", 'String'>
    readonly userId: FieldRef<"Appointment", 'Int'>
    readonly doctorId: FieldRef<"Appointment", 'Int'>
    readonly appointmentDate: FieldRef<"Appointment", 'DateTime'>
    readonly consultationType: FieldRef<"Appointment", 'String'>
    readonly status: FieldRef<"Appointment", 'String'>
    readonly reason: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly meetingLink: FieldRef<"Appointment", 'String'>
    readonly recordingUrl: FieldRef<"Appointment", 'String'>
    readonly prescriptionId: FieldRef<"Appointment", 'Int'>
    readonly paymentId: FieldRef<"Appointment", 'String'>
    readonly paymentStatus: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment.prescription
   */
  export type Appointment$prescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    where?: PrescriptionWhereInput
  }

  /**
   * Appointment.callSession
   */
  export type Appointment$callSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    where?: CallSessionWhereInput
  }

  /**
   * Appointment.reviews
   */
  export type Appointment$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DoctorReview
     */
    select?: DoctorReviewSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DoctorReviewInclude<ExtArgs> | null
    where?: DoctorReviewWhereInput
    orderBy?: DoctorReviewOrderByWithRelationInput | DoctorReviewOrderByWithRelationInput[]
    cursor?: DoctorReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DoctorReviewScalarFieldEnum | DoctorReviewScalarFieldEnum[]
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model Prescription
   */

  export type AggregatePrescription = {
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  export type PrescriptionAvgAggregateOutputType = {
    id: number | null
    appointmentId: number | null
    doctorId: number | null
    userId: number | null
    validityDays: number | null
  }

  export type PrescriptionSumAggregateOutputType = {
    id: number | null
    appointmentId: number | null
    doctorId: number | null
    userId: number | null
    validityDays: number | null
  }

  export type PrescriptionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    appointmentId: number | null
    doctorId: number | null
    userId: number | null
    medicines: string | null
    instructions: string | null
    validityDays: number | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type PrescriptionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    appointmentId: number | null
    doctorId: number | null
    userId: number | null
    medicines: string | null
    instructions: string | null
    validityDays: number | null
    issuedAt: Date | null
    createdAt: Date | null
  }

  export type PrescriptionCountAggregateOutputType = {
    id: number
    uuid: number
    appointmentId: number
    doctorId: number
    userId: number
    medicines: number
    instructions: number
    validityDays: number
    issuedAt: number
    createdAt: number
    _all: number
  }


  export type PrescriptionAvgAggregateInputType = {
    id?: true
    appointmentId?: true
    doctorId?: true
    userId?: true
    validityDays?: true
  }

  export type PrescriptionSumAggregateInputType = {
    id?: true
    appointmentId?: true
    doctorId?: true
    userId?: true
    validityDays?: true
  }

  export type PrescriptionMinAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    doctorId?: true
    userId?: true
    medicines?: true
    instructions?: true
    validityDays?: true
    issuedAt?: true
    createdAt?: true
  }

  export type PrescriptionMaxAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    doctorId?: true
    userId?: true
    medicines?: true
    instructions?: true
    validityDays?: true
    issuedAt?: true
    createdAt?: true
  }

  export type PrescriptionCountAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    doctorId?: true
    userId?: true
    medicines?: true
    instructions?: true
    validityDays?: true
    issuedAt?: true
    createdAt?: true
    _all?: true
  }

  export type PrescriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescription to aggregate.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Prescriptions
    **/
    _count?: true | PrescriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrescriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrescriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrescriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrescriptionMaxAggregateInputType
  }

  export type GetPrescriptionAggregateType<T extends PrescriptionAggregateArgs> = {
        [P in keyof T & keyof AggregatePrescription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrescription[P]>
      : GetScalarType<T[P], AggregatePrescription[P]>
  }




  export type PrescriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrescriptionWhereInput
    orderBy?: PrescriptionOrderByWithAggregationInput | PrescriptionOrderByWithAggregationInput[]
    by: PrescriptionScalarFieldEnum[] | PrescriptionScalarFieldEnum
    having?: PrescriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrescriptionCountAggregateInputType | true
    _avg?: PrescriptionAvgAggregateInputType
    _sum?: PrescriptionSumAggregateInputType
    _min?: PrescriptionMinAggregateInputType
    _max?: PrescriptionMaxAggregateInputType
  }

  export type PrescriptionGroupByOutputType = {
    id: number
    uuid: string
    appointmentId: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions: string | null
    validityDays: number
    issuedAt: Date
    createdAt: Date
    _count: PrescriptionCountAggregateOutputType | null
    _avg: PrescriptionAvgAggregateOutputType | null
    _sum: PrescriptionSumAggregateOutputType | null
    _min: PrescriptionMinAggregateOutputType | null
    _max: PrescriptionMaxAggregateOutputType | null
  }

  type GetPrescriptionGroupByPayload<T extends PrescriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrescriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrescriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
            : GetScalarType<T[P], PrescriptionGroupByOutputType[P]>
        }
      >
    >


  export type PrescriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    doctorId?: boolean
    userId?: boolean
    medicines?: boolean
    instructions?: boolean
    validityDays?: boolean
    issuedAt?: boolean
    createdAt?: boolean
    appointments?: boolean | Prescription$appointmentsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    doctorId?: boolean
    userId?: boolean
    medicines?: boolean
    instructions?: boolean
    validityDays?: boolean
    issuedAt?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["prescription"]>

  export type PrescriptionSelectScalar = {
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    doctorId?: boolean
    userId?: boolean
    medicines?: boolean
    instructions?: boolean
    validityDays?: boolean
    issuedAt?: boolean
    createdAt?: boolean
  }

  export type PrescriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointments?: boolean | Prescription$appointmentsArgs<ExtArgs>
    _count?: boolean | PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrescriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PrescriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Prescription"
    objects: {
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      appointmentId: number | null
      doctorId: number
      userId: number
      medicines: string
      instructions: string | null
      validityDays: number
      issuedAt: Date
      createdAt: Date
    }, ExtArgs["result"]["prescription"]>
    composites: {}
  }

  type PrescriptionGetPayload<S extends boolean | null | undefined | PrescriptionDefaultArgs> = $Result.GetResult<Prisma.$PrescriptionPayload, S>

  type PrescriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PrescriptionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PrescriptionCountAggregateInputType | true
    }

  export interface PrescriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Prescription'], meta: { name: 'Prescription' } }
    /**
     * Find zero or one Prescription that matches the filter.
     * @param {PrescriptionFindUniqueArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrescriptionFindUniqueArgs>(args: SelectSubset<T, PrescriptionFindUniqueArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Prescription that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PrescriptionFindUniqueOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrescriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, PrescriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Prescription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrescriptionFindFirstArgs>(args?: SelectSubset<T, PrescriptionFindFirstArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Prescription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindFirstOrThrowArgs} args - Arguments to find a Prescription
     * @example
     * // Get one Prescription
     * const prescription = await prisma.prescription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrescriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, PrescriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Prescriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Prescriptions
     * const prescriptions = await prisma.prescription.findMany()
     * 
     * // Get first 10 Prescriptions
     * const prescriptions = await prisma.prescription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrescriptionFindManyArgs>(args?: SelectSubset<T, PrescriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Prescription.
     * @param {PrescriptionCreateArgs} args - Arguments to create a Prescription.
     * @example
     * // Create one Prescription
     * const Prescription = await prisma.prescription.create({
     *   data: {
     *     // ... data to create a Prescription
     *   }
     * })
     * 
     */
    create<T extends PrescriptionCreateArgs>(args: SelectSubset<T, PrescriptionCreateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Prescriptions.
     * @param {PrescriptionCreateManyArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrescriptionCreateManyArgs>(args?: SelectSubset<T, PrescriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Prescriptions and returns the data saved in the database.
     * @param {PrescriptionCreateManyAndReturnArgs} args - Arguments to create many Prescriptions.
     * @example
     * // Create many Prescriptions
     * const prescription = await prisma.prescription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Prescriptions and only return the `id`
     * const prescriptionWithIdOnly = await prisma.prescription.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrescriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, PrescriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Prescription.
     * @param {PrescriptionDeleteArgs} args - Arguments to delete one Prescription.
     * @example
     * // Delete one Prescription
     * const Prescription = await prisma.prescription.delete({
     *   where: {
     *     // ... filter to delete one Prescription
     *   }
     * })
     * 
     */
    delete<T extends PrescriptionDeleteArgs>(args: SelectSubset<T, PrescriptionDeleteArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Prescription.
     * @param {PrescriptionUpdateArgs} args - Arguments to update one Prescription.
     * @example
     * // Update one Prescription
     * const prescription = await prisma.prescription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrescriptionUpdateArgs>(args: SelectSubset<T, PrescriptionUpdateArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Prescriptions.
     * @param {PrescriptionDeleteManyArgs} args - Arguments to filter Prescriptions to delete.
     * @example
     * // Delete a few Prescriptions
     * const { count } = await prisma.prescription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrescriptionDeleteManyArgs>(args?: SelectSubset<T, PrescriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Prescriptions
     * const prescription = await prisma.prescription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrescriptionUpdateManyArgs>(args: SelectSubset<T, PrescriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Prescription.
     * @param {PrescriptionUpsertArgs} args - Arguments to update or create a Prescription.
     * @example
     * // Update or create a Prescription
     * const prescription = await prisma.prescription.upsert({
     *   create: {
     *     // ... data to create a Prescription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Prescription we want to update
     *   }
     * })
     */
    upsert<T extends PrescriptionUpsertArgs>(args: SelectSubset<T, PrescriptionUpsertArgs<ExtArgs>>): Prisma__PrescriptionClient<$Result.GetResult<Prisma.$PrescriptionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Prescriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionCountArgs} args - Arguments to filter Prescriptions to count.
     * @example
     * // Count the number of Prescriptions
     * const count = await prisma.prescription.count({
     *   where: {
     *     // ... the filter for the Prescriptions we want to count
     *   }
     * })
    **/
    count<T extends PrescriptionCountArgs>(
      args?: Subset<T, PrescriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrescriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrescriptionAggregateArgs>(args: Subset<T, PrescriptionAggregateArgs>): Prisma.PrismaPromise<GetPrescriptionAggregateType<T>>

    /**
     * Group by Prescription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrescriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrescriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrescriptionGroupByArgs['orderBy'] }
        : { orderBy?: PrescriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrescriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrescriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Prescription model
   */
  readonly fields: PrescriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Prescription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrescriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointments<T extends Prescription$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Prescription$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Prescription model
   */ 
  interface PrescriptionFieldRefs {
    readonly id: FieldRef<"Prescription", 'Int'>
    readonly uuid: FieldRef<"Prescription", 'String'>
    readonly appointmentId: FieldRef<"Prescription", 'Int'>
    readonly doctorId: FieldRef<"Prescription", 'Int'>
    readonly userId: FieldRef<"Prescription", 'Int'>
    readonly medicines: FieldRef<"Prescription", 'String'>
    readonly instructions: FieldRef<"Prescription", 'String'>
    readonly validityDays: FieldRef<"Prescription", 'Int'>
    readonly issuedAt: FieldRef<"Prescription", 'DateTime'>
    readonly createdAt: FieldRef<"Prescription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Prescription findUnique
   */
  export type PrescriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findUniqueOrThrow
   */
  export type PrescriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription findFirst
   */
  export type PrescriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findFirstOrThrow
   */
  export type PrescriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescription to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Prescriptions.
     */
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription findMany
   */
  export type PrescriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter, which Prescriptions to fetch.
     */
    where?: PrescriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Prescriptions to fetch.
     */
    orderBy?: PrescriptionOrderByWithRelationInput | PrescriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Prescriptions.
     */
    cursor?: PrescriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Prescriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Prescriptions.
     */
    skip?: number
    distinct?: PrescriptionScalarFieldEnum | PrescriptionScalarFieldEnum[]
  }

  /**
   * Prescription create
   */
  export type PrescriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Prescription.
     */
    data: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
  }

  /**
   * Prescription createMany
   */
  export type PrescriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
  }

  /**
   * Prescription createManyAndReturn
   */
  export type PrescriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Prescriptions.
     */
    data: PrescriptionCreateManyInput | PrescriptionCreateManyInput[]
  }

  /**
   * Prescription update
   */
  export type PrescriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Prescription.
     */
    data: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
    /**
     * Choose, which Prescription to update.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription updateMany
   */
  export type PrescriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Prescriptions.
     */
    data: XOR<PrescriptionUpdateManyMutationInput, PrescriptionUncheckedUpdateManyInput>
    /**
     * Filter which Prescriptions to update
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription upsert
   */
  export type PrescriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Prescription to update in case it exists.
     */
    where: PrescriptionWhereUniqueInput
    /**
     * In case the Prescription found by the `where` argument doesn't exist, create a new Prescription with this data.
     */
    create: XOR<PrescriptionCreateInput, PrescriptionUncheckedCreateInput>
    /**
     * In case the Prescription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrescriptionUpdateInput, PrescriptionUncheckedUpdateInput>
  }

  /**
   * Prescription delete
   */
  export type PrescriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
    /**
     * Filter which Prescription to delete.
     */
    where: PrescriptionWhereUniqueInput
  }

  /**
   * Prescription deleteMany
   */
  export type PrescriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Prescriptions to delete
     */
    where?: PrescriptionWhereInput
  }

  /**
   * Prescription.appointments
   */
  export type Prescription$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Prescription without action
   */
  export type PrescriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Prescription
     */
    select?: PrescriptionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrescriptionInclude<ExtArgs> | null
  }


  /**
   * Model CallSession
   */

  export type AggregateCallSession = {
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  export type CallSessionAvgAggregateOutputType = {
    id: number | null
    appointmentId: number | null
  }

  export type CallSessionSumAggregateOutputType = {
    id: number | null
    appointmentId: number | null
  }

  export type CallSessionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    appointmentId: number | null
    roomId: string | null
    provider: string | null
    token: string | null
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    createdAt: Date | null
  }

  export type CallSessionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    appointmentId: number | null
    roomId: string | null
    provider: string | null
    token: string | null
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    createdAt: Date | null
  }

  export type CallSessionCountAggregateOutputType = {
    id: number
    uuid: number
    appointmentId: number
    roomId: number
    provider: number
    token: number
    startedAt: number
    endedAt: number
    recordingUrl: number
    createdAt: number
    _all: number
  }


  export type CallSessionAvgAggregateInputType = {
    id?: true
    appointmentId?: true
  }

  export type CallSessionSumAggregateInputType = {
    id?: true
    appointmentId?: true
  }

  export type CallSessionMinAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    roomId?: true
    provider?: true
    token?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    createdAt?: true
  }

  export type CallSessionMaxAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    roomId?: true
    provider?: true
    token?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    createdAt?: true
  }

  export type CallSessionCountAggregateInputType = {
    id?: true
    uuid?: true
    appointmentId?: true
    roomId?: true
    provider?: true
    token?: true
    startedAt?: true
    endedAt?: true
    recordingUrl?: true
    createdAt?: true
    _all?: true
  }

  export type CallSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSession to aggregate.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CallSessions
    **/
    _count?: true | CallSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CallSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CallSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CallSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CallSessionMaxAggregateInputType
  }

  export type GetCallSessionAggregateType<T extends CallSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCallSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCallSession[P]>
      : GetScalarType<T[P], AggregateCallSession[P]>
  }




  export type CallSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CallSessionWhereInput
    orderBy?: CallSessionOrderByWithAggregationInput | CallSessionOrderByWithAggregationInput[]
    by: CallSessionScalarFieldEnum[] | CallSessionScalarFieldEnum
    having?: CallSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CallSessionCountAggregateInputType | true
    _avg?: CallSessionAvgAggregateInputType
    _sum?: CallSessionSumAggregateInputType
    _min?: CallSessionMinAggregateInputType
    _max?: CallSessionMaxAggregateInputType
  }

  export type CallSessionGroupByOutputType = {
    id: number
    uuid: string
    appointmentId: number
    roomId: string | null
    provider: string | null
    token: string | null
    startedAt: Date | null
    endedAt: Date | null
    recordingUrl: string | null
    createdAt: Date
    _count: CallSessionCountAggregateOutputType | null
    _avg: CallSessionAvgAggregateOutputType | null
    _sum: CallSessionSumAggregateOutputType | null
    _min: CallSessionMinAggregateOutputType | null
    _max: CallSessionMaxAggregateOutputType | null
  }

  type GetCallSessionGroupByPayload<T extends CallSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CallSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CallSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CallSessionGroupByOutputType[P]>
        }
      >
    >


  export type CallSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    roomId?: boolean
    provider?: boolean
    token?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callSession"]>

  export type CallSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    roomId?: boolean
    provider?: boolean
    token?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["callSession"]>

  export type CallSessionSelectScalar = {
    id?: boolean
    uuid?: boolean
    appointmentId?: boolean
    roomId?: boolean
    provider?: boolean
    token?: boolean
    startedAt?: boolean
    endedAt?: boolean
    recordingUrl?: boolean
    createdAt?: boolean
  }

  export type CallSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }
  export type CallSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    appointment?: boolean | AppointmentDefaultArgs<ExtArgs>
  }

  export type $CallSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CallSession"
    objects: {
      appointment: Prisma.$AppointmentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      appointmentId: number
      roomId: string | null
      provider: string | null
      token: string | null
      startedAt: Date | null
      endedAt: Date | null
      recordingUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["callSession"]>
    composites: {}
  }

  type CallSessionGetPayload<S extends boolean | null | undefined | CallSessionDefaultArgs> = $Result.GetResult<Prisma.$CallSessionPayload, S>

  type CallSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CallSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CallSessionCountAggregateInputType | true
    }

  export interface CallSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CallSession'], meta: { name: 'CallSession' } }
    /**
     * Find zero or one CallSession that matches the filter.
     * @param {CallSessionFindUniqueArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CallSessionFindUniqueArgs>(args: SelectSubset<T, CallSessionFindUniqueArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CallSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CallSessionFindUniqueOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CallSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CallSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CallSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CallSessionFindFirstArgs>(args?: SelectSubset<T, CallSessionFindFirstArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CallSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindFirstOrThrowArgs} args - Arguments to find a CallSession
     * @example
     * // Get one CallSession
     * const callSession = await prisma.callSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CallSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CallSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CallSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CallSessions
     * const callSessions = await prisma.callSession.findMany()
     * 
     * // Get first 10 CallSessions
     * const callSessions = await prisma.callSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const callSessionWithIdOnly = await prisma.callSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CallSessionFindManyArgs>(args?: SelectSubset<T, CallSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CallSession.
     * @param {CallSessionCreateArgs} args - Arguments to create a CallSession.
     * @example
     * // Create one CallSession
     * const CallSession = await prisma.callSession.create({
     *   data: {
     *     // ... data to create a CallSession
     *   }
     * })
     * 
     */
    create<T extends CallSessionCreateArgs>(args: SelectSubset<T, CallSessionCreateArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CallSessions.
     * @param {CallSessionCreateManyArgs} args - Arguments to create many CallSessions.
     * @example
     * // Create many CallSessions
     * const callSession = await prisma.callSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CallSessionCreateManyArgs>(args?: SelectSubset<T, CallSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CallSessions and returns the data saved in the database.
     * @param {CallSessionCreateManyAndReturnArgs} args - Arguments to create many CallSessions.
     * @example
     * // Create many CallSessions
     * const callSession = await prisma.callSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CallSessions and only return the `id`
     * const callSessionWithIdOnly = await prisma.callSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CallSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CallSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CallSession.
     * @param {CallSessionDeleteArgs} args - Arguments to delete one CallSession.
     * @example
     * // Delete one CallSession
     * const CallSession = await prisma.callSession.delete({
     *   where: {
     *     // ... filter to delete one CallSession
     *   }
     * })
     * 
     */
    delete<T extends CallSessionDeleteArgs>(args: SelectSubset<T, CallSessionDeleteArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CallSession.
     * @param {CallSessionUpdateArgs} args - Arguments to update one CallSession.
     * @example
     * // Update one CallSession
     * const callSession = await prisma.callSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CallSessionUpdateArgs>(args: SelectSubset<T, CallSessionUpdateArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CallSessions.
     * @param {CallSessionDeleteManyArgs} args - Arguments to filter CallSessions to delete.
     * @example
     * // Delete a few CallSessions
     * const { count } = await prisma.callSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CallSessionDeleteManyArgs>(args?: SelectSubset<T, CallSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CallSessions
     * const callSession = await prisma.callSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CallSessionUpdateManyArgs>(args: SelectSubset<T, CallSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CallSession.
     * @param {CallSessionUpsertArgs} args - Arguments to update or create a CallSession.
     * @example
     * // Update or create a CallSession
     * const callSession = await prisma.callSession.upsert({
     *   create: {
     *     // ... data to create a CallSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CallSession we want to update
     *   }
     * })
     */
    upsert<T extends CallSessionUpsertArgs>(args: SelectSubset<T, CallSessionUpsertArgs<ExtArgs>>): Prisma__CallSessionClient<$Result.GetResult<Prisma.$CallSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CallSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionCountArgs} args - Arguments to filter CallSessions to count.
     * @example
     * // Count the number of CallSessions
     * const count = await prisma.callSession.count({
     *   where: {
     *     // ... the filter for the CallSessions we want to count
     *   }
     * })
    **/
    count<T extends CallSessionCountArgs>(
      args?: Subset<T, CallSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CallSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CallSessionAggregateArgs>(args: Subset<T, CallSessionAggregateArgs>): Prisma.PrismaPromise<GetCallSessionAggregateType<T>>

    /**
     * Group by CallSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CallSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CallSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CallSessionGroupByArgs['orderBy'] }
        : { orderBy?: CallSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CallSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCallSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CallSession model
   */
  readonly fields: CallSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CallSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CallSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    appointment<T extends AppointmentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppointmentDefaultArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CallSession model
   */ 
  interface CallSessionFieldRefs {
    readonly id: FieldRef<"CallSession", 'Int'>
    readonly uuid: FieldRef<"CallSession", 'String'>
    readonly appointmentId: FieldRef<"CallSession", 'Int'>
    readonly roomId: FieldRef<"CallSession", 'String'>
    readonly provider: FieldRef<"CallSession", 'String'>
    readonly token: FieldRef<"CallSession", 'String'>
    readonly startedAt: FieldRef<"CallSession", 'DateTime'>
    readonly endedAt: FieldRef<"CallSession", 'DateTime'>
    readonly recordingUrl: FieldRef<"CallSession", 'String'>
    readonly createdAt: FieldRef<"CallSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CallSession findUnique
   */
  export type CallSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession findUniqueOrThrow
   */
  export type CallSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession findFirst
   */
  export type CallSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     */
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession findFirstOrThrow
   */
  export type CallSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSession to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CallSessions.
     */
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession findMany
   */
  export type CallSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter, which CallSessions to fetch.
     */
    where?: CallSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CallSessions to fetch.
     */
    orderBy?: CallSessionOrderByWithRelationInput | CallSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CallSessions.
     */
    cursor?: CallSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CallSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CallSessions.
     */
    skip?: number
    distinct?: CallSessionScalarFieldEnum | CallSessionScalarFieldEnum[]
  }

  /**
   * CallSession create
   */
  export type CallSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CallSession.
     */
    data: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
  }

  /**
   * CallSession createMany
   */
  export type CallSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CallSessions.
     */
    data: CallSessionCreateManyInput | CallSessionCreateManyInput[]
  }

  /**
   * CallSession createManyAndReturn
   */
  export type CallSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CallSessions.
     */
    data: CallSessionCreateManyInput | CallSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CallSession update
   */
  export type CallSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CallSession.
     */
    data: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
    /**
     * Choose, which CallSession to update.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession updateMany
   */
  export type CallSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CallSessions.
     */
    data: XOR<CallSessionUpdateManyMutationInput, CallSessionUncheckedUpdateManyInput>
    /**
     * Filter which CallSessions to update
     */
    where?: CallSessionWhereInput
  }

  /**
   * CallSession upsert
   */
  export type CallSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CallSession to update in case it exists.
     */
    where: CallSessionWhereUniqueInput
    /**
     * In case the CallSession found by the `where` argument doesn't exist, create a new CallSession with this data.
     */
    create: XOR<CallSessionCreateInput, CallSessionUncheckedCreateInput>
    /**
     * In case the CallSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CallSessionUpdateInput, CallSessionUncheckedUpdateInput>
  }

  /**
   * CallSession delete
   */
  export type CallSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
    /**
     * Filter which CallSession to delete.
     */
    where: CallSessionWhereUniqueInput
  }

  /**
   * CallSession deleteMany
   */
  export type CallSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CallSessions to delete
     */
    where?: CallSessionWhereInput
  }

  /**
   * CallSession without action
   */
  export type CallSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CallSession
     */
    select?: CallSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CallSessionInclude<ExtArgs> | null
  }


  /**
   * Model Medicine
   */

  export type AggregateMedicine = {
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  export type MedicineAvgAggregateOutputType = {
    id: number | null
    price: number | null
    stockQty: number | null
  }

  export type MedicineSumAggregateOutputType = {
    id: number | null
    price: number | null
    stockQty: number | null
  }

  export type MedicineMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    composition: string | null
    category: string | null
    price: number | null
    manufacturer: string | null
    stockQty: number | null
    description: string | null
    sideEffects: string | null
    interactions: string | null
    requiresPrescription: boolean | null
    available: boolean | null
    createdAt: Date | null
  }

  export type MedicineMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    composition: string | null
    category: string | null
    price: number | null
    manufacturer: string | null
    stockQty: number | null
    description: string | null
    sideEffects: string | null
    interactions: string | null
    requiresPrescription: boolean | null
    available: boolean | null
    createdAt: Date | null
  }

  export type MedicineCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    composition: number
    category: number
    price: number
    manufacturer: number
    stockQty: number
    description: number
    sideEffects: number
    interactions: number
    requiresPrescription: number
    available: number
    createdAt: number
    _all: number
  }


  export type MedicineAvgAggregateInputType = {
    id?: true
    price?: true
    stockQty?: true
  }

  export type MedicineSumAggregateInputType = {
    id?: true
    price?: true
    stockQty?: true
  }

  export type MedicineMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    composition?: true
    category?: true
    price?: true
    manufacturer?: true
    stockQty?: true
    description?: true
    sideEffects?: true
    interactions?: true
    requiresPrescription?: true
    available?: true
    createdAt?: true
  }

  export type MedicineMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    composition?: true
    category?: true
    price?: true
    manufacturer?: true
    stockQty?: true
    description?: true
    sideEffects?: true
    interactions?: true
    requiresPrescription?: true
    available?: true
    createdAt?: true
  }

  export type MedicineCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    composition?: true
    category?: true
    price?: true
    manufacturer?: true
    stockQty?: true
    description?: true
    sideEffects?: true
    interactions?: true
    requiresPrescription?: true
    available?: true
    createdAt?: true
    _all?: true
  }

  export type MedicineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicine to aggregate.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Medicines
    **/
    _count?: true | MedicineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineMaxAggregateInputType
  }

  export type GetMedicineAggregateType<T extends MedicineAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicine[P]>
      : GetScalarType<T[P], AggregateMedicine[P]>
  }




  export type MedicineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineWhereInput
    orderBy?: MedicineOrderByWithAggregationInput | MedicineOrderByWithAggregationInput[]
    by: MedicineScalarFieldEnum[] | MedicineScalarFieldEnum
    having?: MedicineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineCountAggregateInputType | true
    _avg?: MedicineAvgAggregateInputType
    _sum?: MedicineSumAggregateInputType
    _min?: MedicineMinAggregateInputType
    _max?: MedicineMaxAggregateInputType
  }

  export type MedicineGroupByOutputType = {
    id: number
    uuid: string
    name: string
    composition: string | null
    category: string | null
    price: number
    manufacturer: string | null
    stockQty: number
    description: string | null
    sideEffects: string | null
    interactions: string | null
    requiresPrescription: boolean
    available: boolean
    createdAt: Date
    _count: MedicineCountAggregateOutputType | null
    _avg: MedicineAvgAggregateOutputType | null
    _sum: MedicineSumAggregateOutputType | null
    _min: MedicineMinAggregateOutputType | null
    _max: MedicineMaxAggregateOutputType | null
  }

  type GetMedicineGroupByPayload<T extends MedicineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineGroupByOutputType[P]>
        }
      >
    >


  export type MedicineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    composition?: boolean
    category?: boolean
    price?: boolean
    manufacturer?: boolean
    stockQty?: boolean
    description?: boolean
    sideEffects?: boolean
    interactions?: boolean
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: boolean
    orderItems?: boolean | Medicine$orderItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    composition?: boolean
    category?: boolean
    price?: boolean
    manufacturer?: boolean
    stockQty?: boolean
    description?: boolean
    sideEffects?: boolean
    interactions?: boolean
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["medicine"]>

  export type MedicineSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    composition?: boolean
    category?: boolean
    price?: boolean
    manufacturer?: boolean
    stockQty?: boolean
    description?: boolean
    sideEffects?: boolean
    interactions?: boolean
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: boolean
  }

  export type MedicineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    orderItems?: boolean | Medicine$orderItemsArgs<ExtArgs>
    _count?: boolean | MedicineCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $MedicinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Medicine"
    objects: {
      orderItems: Prisma.$MedicineOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      name: string
      composition: string | null
      category: string | null
      price: number
      manufacturer: string | null
      stockQty: number
      description: string | null
      sideEffects: string | null
      interactions: string | null
      requiresPrescription: boolean
      available: boolean
      createdAt: Date
    }, ExtArgs["result"]["medicine"]>
    composites: {}
  }

  type MedicineGetPayload<S extends boolean | null | undefined | MedicineDefaultArgs> = $Result.GetResult<Prisma.$MedicinePayload, S>

  type MedicineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicineFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicineCountAggregateInputType | true
    }

  export interface MedicineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Medicine'], meta: { name: 'Medicine' } }
    /**
     * Find zero or one Medicine that matches the filter.
     * @param {MedicineFindUniqueArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineFindUniqueArgs>(args: SelectSubset<T, MedicineFindUniqueArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Medicine that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicineFindUniqueOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Medicine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineFindFirstArgs>(args?: SelectSubset<T, MedicineFindFirstArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Medicine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindFirstOrThrowArgs} args - Arguments to find a Medicine
     * @example
     * // Get one Medicine
     * const medicine = await prisma.medicine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Medicines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Medicines
     * const medicines = await prisma.medicine.findMany()
     * 
     * // Get first 10 Medicines
     * const medicines = await prisma.medicine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineWithIdOnly = await prisma.medicine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineFindManyArgs>(args?: SelectSubset<T, MedicineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Medicine.
     * @param {MedicineCreateArgs} args - Arguments to create a Medicine.
     * @example
     * // Create one Medicine
     * const Medicine = await prisma.medicine.create({
     *   data: {
     *     // ... data to create a Medicine
     *   }
     * })
     * 
     */
    create<T extends MedicineCreateArgs>(args: SelectSubset<T, MedicineCreateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Medicines.
     * @param {MedicineCreateManyArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineCreateManyArgs>(args?: SelectSubset<T, MedicineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Medicines and returns the data saved in the database.
     * @param {MedicineCreateManyAndReturnArgs} args - Arguments to create many Medicines.
     * @example
     * // Create many Medicines
     * const medicine = await prisma.medicine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Medicines and only return the `id`
     * const medicineWithIdOnly = await prisma.medicine.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Medicine.
     * @param {MedicineDeleteArgs} args - Arguments to delete one Medicine.
     * @example
     * // Delete one Medicine
     * const Medicine = await prisma.medicine.delete({
     *   where: {
     *     // ... filter to delete one Medicine
     *   }
     * })
     * 
     */
    delete<T extends MedicineDeleteArgs>(args: SelectSubset<T, MedicineDeleteArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Medicine.
     * @param {MedicineUpdateArgs} args - Arguments to update one Medicine.
     * @example
     * // Update one Medicine
     * const medicine = await prisma.medicine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineUpdateArgs>(args: SelectSubset<T, MedicineUpdateArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Medicines.
     * @param {MedicineDeleteManyArgs} args - Arguments to filter Medicines to delete.
     * @example
     * // Delete a few Medicines
     * const { count } = await prisma.medicine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineDeleteManyArgs>(args?: SelectSubset<T, MedicineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Medicines
     * const medicine = await prisma.medicine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineUpdateManyArgs>(args: SelectSubset<T, MedicineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Medicine.
     * @param {MedicineUpsertArgs} args - Arguments to update or create a Medicine.
     * @example
     * // Update or create a Medicine
     * const medicine = await prisma.medicine.upsert({
     *   create: {
     *     // ... data to create a Medicine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Medicine we want to update
     *   }
     * })
     */
    upsert<T extends MedicineUpsertArgs>(args: SelectSubset<T, MedicineUpsertArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Medicines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineCountArgs} args - Arguments to filter Medicines to count.
     * @example
     * // Count the number of Medicines
     * const count = await prisma.medicine.count({
     *   where: {
     *     // ... the filter for the Medicines we want to count
     *   }
     * })
    **/
    count<T extends MedicineCountArgs>(
      args?: Subset<T, MedicineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineAggregateArgs>(args: Subset<T, MedicineAggregateArgs>): Prisma.PrismaPromise<GetMedicineAggregateType<T>>

    /**
     * Group by Medicine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineGroupByArgs['orderBy'] }
        : { orderBy?: MedicineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Medicine model
   */
  readonly fields: MedicineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Medicine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    orderItems<T extends Medicine$orderItemsArgs<ExtArgs> = {}>(args?: Subset<T, Medicine$orderItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Medicine model
   */ 
  interface MedicineFieldRefs {
    readonly id: FieldRef<"Medicine", 'Int'>
    readonly uuid: FieldRef<"Medicine", 'String'>
    readonly name: FieldRef<"Medicine", 'String'>
    readonly composition: FieldRef<"Medicine", 'String'>
    readonly category: FieldRef<"Medicine", 'String'>
    readonly price: FieldRef<"Medicine", 'Float'>
    readonly manufacturer: FieldRef<"Medicine", 'String'>
    readonly stockQty: FieldRef<"Medicine", 'Int'>
    readonly description: FieldRef<"Medicine", 'String'>
    readonly sideEffects: FieldRef<"Medicine", 'String'>
    readonly interactions: FieldRef<"Medicine", 'String'>
    readonly requiresPrescription: FieldRef<"Medicine", 'Boolean'>
    readonly available: FieldRef<"Medicine", 'Boolean'>
    readonly createdAt: FieldRef<"Medicine", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Medicine findUnique
   */
  export type MedicineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findUniqueOrThrow
   */
  export type MedicineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine findFirst
   */
  export type MedicineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findFirstOrThrow
   */
  export type MedicineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicine to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Medicines.
     */
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine findMany
   */
  export type MedicineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter, which Medicines to fetch.
     */
    where?: MedicineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Medicines to fetch.
     */
    orderBy?: MedicineOrderByWithRelationInput | MedicineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Medicines.
     */
    cursor?: MedicineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Medicines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Medicines.
     */
    skip?: number
    distinct?: MedicineScalarFieldEnum | MedicineScalarFieldEnum[]
  }

  /**
   * Medicine create
   */
  export type MedicineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to create a Medicine.
     */
    data: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
  }

  /**
   * Medicine createMany
   */
  export type MedicineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
  }

  /**
   * Medicine createManyAndReturn
   */
  export type MedicineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Medicines.
     */
    data: MedicineCreateManyInput | MedicineCreateManyInput[]
  }

  /**
   * Medicine update
   */
  export type MedicineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The data needed to update a Medicine.
     */
    data: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
    /**
     * Choose, which Medicine to update.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine updateMany
   */
  export type MedicineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Medicines.
     */
    data: XOR<MedicineUpdateManyMutationInput, MedicineUncheckedUpdateManyInput>
    /**
     * Filter which Medicines to update
     */
    where?: MedicineWhereInput
  }

  /**
   * Medicine upsert
   */
  export type MedicineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * The filter to search for the Medicine to update in case it exists.
     */
    where: MedicineWhereUniqueInput
    /**
     * In case the Medicine found by the `where` argument doesn't exist, create a new Medicine with this data.
     */
    create: XOR<MedicineCreateInput, MedicineUncheckedCreateInput>
    /**
     * In case the Medicine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineUpdateInput, MedicineUncheckedUpdateInput>
  }

  /**
   * Medicine delete
   */
  export type MedicineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
    /**
     * Filter which Medicine to delete.
     */
    where: MedicineWhereUniqueInput
  }

  /**
   * Medicine deleteMany
   */
  export type MedicineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Medicines to delete
     */
    where?: MedicineWhereInput
  }

  /**
   * Medicine.orderItems
   */
  export type Medicine$orderItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    where?: MedicineOrderItemWhereInput
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    cursor?: MedicineOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineOrderItemScalarFieldEnum | MedicineOrderItemScalarFieldEnum[]
  }

  /**
   * Medicine without action
   */
  export type MedicineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Medicine
     */
    select?: MedicineSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineInclude<ExtArgs> | null
  }


  /**
   * Model MedicineOrder
   */

  export type AggregateMedicineOrder = {
    _count: MedicineOrderCountAggregateOutputType | null
    _avg: MedicineOrderAvgAggregateOutputType | null
    _sum: MedicineOrderSumAggregateOutputType | null
    _min: MedicineOrderMinAggregateOutputType | null
    _max: MedicineOrderMaxAggregateOutputType | null
  }

  export type MedicineOrderAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
  }

  export type MedicineOrderSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
  }

  export type MedicineOrderMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    orderDate: Date | null
    deliveryAddress: string | null
    status: string | null
    totalAmount: number | null
    paymentMethod: string | null
    paymentStatus: string | null
    prescriptionUrl: string | null
    deliveryDate: Date | null
    expectedDeliveryDate: Date | null
    trackingNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineOrderMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    orderDate: Date | null
    deliveryAddress: string | null
    status: string | null
    totalAmount: number | null
    paymentMethod: string | null
    paymentStatus: string | null
    prescriptionUrl: string | null
    deliveryDate: Date | null
    expectedDeliveryDate: Date | null
    trackingNumber: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MedicineOrderCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    orderDate: number
    deliveryAddress: number
    status: number
    totalAmount: number
    paymentMethod: number
    paymentStatus: number
    prescriptionUrl: number
    deliveryDate: number
    expectedDeliveryDate: number
    trackingNumber: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MedicineOrderAvgAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
  }

  export type MedicineOrderSumAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
  }

  export type MedicineOrderMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    orderDate?: true
    deliveryAddress?: true
    status?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    prescriptionUrl?: true
    deliveryDate?: true
    expectedDeliveryDate?: true
    trackingNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineOrderMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    orderDate?: true
    deliveryAddress?: true
    status?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    prescriptionUrl?: true
    deliveryDate?: true
    expectedDeliveryDate?: true
    trackingNumber?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MedicineOrderCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    orderDate?: true
    deliveryAddress?: true
    status?: true
    totalAmount?: true
    paymentMethod?: true
    paymentStatus?: true
    prescriptionUrl?: true
    deliveryDate?: true
    expectedDeliveryDate?: true
    trackingNumber?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MedicineOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineOrder to aggregate.
     */
    where?: MedicineOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrders to fetch.
     */
    orderBy?: MedicineOrderOrderByWithRelationInput | MedicineOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineOrders
    **/
    _count?: true | MedicineOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineOrderMaxAggregateInputType
  }

  export type GetMedicineOrderAggregateType<T extends MedicineOrderAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineOrder[P]>
      : GetScalarType<T[P], AggregateMedicineOrder[P]>
  }




  export type MedicineOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineOrderWhereInput
    orderBy?: MedicineOrderOrderByWithAggregationInput | MedicineOrderOrderByWithAggregationInput[]
    by: MedicineOrderScalarFieldEnum[] | MedicineOrderScalarFieldEnum
    having?: MedicineOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineOrderCountAggregateInputType | true
    _avg?: MedicineOrderAvgAggregateInputType
    _sum?: MedicineOrderSumAggregateInputType
    _min?: MedicineOrderMinAggregateInputType
    _max?: MedicineOrderMaxAggregateInputType
  }

  export type MedicineOrderGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    orderDate: Date
    deliveryAddress: string
    status: string
    totalAmount: number
    paymentMethod: string | null
    paymentStatus: string
    prescriptionUrl: string | null
    deliveryDate: Date | null
    expectedDeliveryDate: Date | null
    trackingNumber: string | null
    createdAt: Date
    updatedAt: Date
    _count: MedicineOrderCountAggregateOutputType | null
    _avg: MedicineOrderAvgAggregateOutputType | null
    _sum: MedicineOrderSumAggregateOutputType | null
    _min: MedicineOrderMinAggregateOutputType | null
    _max: MedicineOrderMaxAggregateOutputType | null
  }

  type GetMedicineOrderGroupByPayload<T extends MedicineOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineOrderGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineOrderGroupByOutputType[P]>
        }
      >
    >


  export type MedicineOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    orderDate?: boolean
    deliveryAddress?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    prescriptionUrl?: boolean
    deliveryDate?: boolean
    expectedDeliveryDate?: boolean
    trackingNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | MedicineOrder$itemsArgs<ExtArgs>
    _count?: boolean | MedicineOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineOrder"]>

  export type MedicineOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    orderDate?: boolean
    deliveryAddress?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    prescriptionUrl?: boolean
    deliveryDate?: boolean
    expectedDeliveryDate?: boolean
    trackingNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineOrder"]>

  export type MedicineOrderSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    orderDate?: boolean
    deliveryAddress?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentMethod?: boolean
    paymentStatus?: boolean
    prescriptionUrl?: boolean
    deliveryDate?: boolean
    expectedDeliveryDate?: boolean
    trackingNumber?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MedicineOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    items?: boolean | MedicineOrder$itemsArgs<ExtArgs>
    _count?: boolean | MedicineOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MedicineOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MedicineOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineOrder"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      items: Prisma.$MedicineOrderItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      orderDate: Date
      deliveryAddress: string
      status: string
      totalAmount: number
      paymentMethod: string | null
      paymentStatus: string
      prescriptionUrl: string | null
      deliveryDate: Date | null
      expectedDeliveryDate: Date | null
      trackingNumber: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["medicineOrder"]>
    composites: {}
  }

  type MedicineOrderGetPayload<S extends boolean | null | undefined | MedicineOrderDefaultArgs> = $Result.GetResult<Prisma.$MedicineOrderPayload, S>

  type MedicineOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicineOrderFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicineOrderCountAggregateInputType | true
    }

  export interface MedicineOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineOrder'], meta: { name: 'MedicineOrder' } }
    /**
     * Find zero or one MedicineOrder that matches the filter.
     * @param {MedicineOrderFindUniqueArgs} args - Arguments to find a MedicineOrder
     * @example
     * // Get one MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineOrderFindUniqueArgs>(args: SelectSubset<T, MedicineOrderFindUniqueArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicineOrder that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicineOrderFindUniqueOrThrowArgs} args - Arguments to find a MedicineOrder
     * @example
     * // Get one MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicineOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderFindFirstArgs} args - Arguments to find a MedicineOrder
     * @example
     * // Get one MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineOrderFindFirstArgs>(args?: SelectSubset<T, MedicineOrderFindFirstArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicineOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderFindFirstOrThrowArgs} args - Arguments to find a MedicineOrder
     * @example
     * // Get one MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicineOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineOrders
     * const medicineOrders = await prisma.medicineOrder.findMany()
     * 
     * // Get first 10 MedicineOrders
     * const medicineOrders = await prisma.medicineOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineOrderWithIdOnly = await prisma.medicineOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineOrderFindManyArgs>(args?: SelectSubset<T, MedicineOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicineOrder.
     * @param {MedicineOrderCreateArgs} args - Arguments to create a MedicineOrder.
     * @example
     * // Create one MedicineOrder
     * const MedicineOrder = await prisma.medicineOrder.create({
     *   data: {
     *     // ... data to create a MedicineOrder
     *   }
     * })
     * 
     */
    create<T extends MedicineOrderCreateArgs>(args: SelectSubset<T, MedicineOrderCreateArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicineOrders.
     * @param {MedicineOrderCreateManyArgs} args - Arguments to create many MedicineOrders.
     * @example
     * // Create many MedicineOrders
     * const medicineOrder = await prisma.medicineOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineOrderCreateManyArgs>(args?: SelectSubset<T, MedicineOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineOrders and returns the data saved in the database.
     * @param {MedicineOrderCreateManyAndReturnArgs} args - Arguments to create many MedicineOrders.
     * @example
     * // Create many MedicineOrders
     * const medicineOrder = await prisma.medicineOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineOrders and only return the `id`
     * const medicineOrderWithIdOnly = await prisma.medicineOrder.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicineOrder.
     * @param {MedicineOrderDeleteArgs} args - Arguments to delete one MedicineOrder.
     * @example
     * // Delete one MedicineOrder
     * const MedicineOrder = await prisma.medicineOrder.delete({
     *   where: {
     *     // ... filter to delete one MedicineOrder
     *   }
     * })
     * 
     */
    delete<T extends MedicineOrderDeleteArgs>(args: SelectSubset<T, MedicineOrderDeleteArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicineOrder.
     * @param {MedicineOrderUpdateArgs} args - Arguments to update one MedicineOrder.
     * @example
     * // Update one MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineOrderUpdateArgs>(args: SelectSubset<T, MedicineOrderUpdateArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicineOrders.
     * @param {MedicineOrderDeleteManyArgs} args - Arguments to filter MedicineOrders to delete.
     * @example
     * // Delete a few MedicineOrders
     * const { count } = await prisma.medicineOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineOrderDeleteManyArgs>(args?: SelectSubset<T, MedicineOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineOrders
     * const medicineOrder = await prisma.medicineOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineOrderUpdateManyArgs>(args: SelectSubset<T, MedicineOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicineOrder.
     * @param {MedicineOrderUpsertArgs} args - Arguments to update or create a MedicineOrder.
     * @example
     * // Update or create a MedicineOrder
     * const medicineOrder = await prisma.medicineOrder.upsert({
     *   create: {
     *     // ... data to create a MedicineOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineOrder we want to update
     *   }
     * })
     */
    upsert<T extends MedicineOrderUpsertArgs>(args: SelectSubset<T, MedicineOrderUpsertArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicineOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderCountArgs} args - Arguments to filter MedicineOrders to count.
     * @example
     * // Count the number of MedicineOrders
     * const count = await prisma.medicineOrder.count({
     *   where: {
     *     // ... the filter for the MedicineOrders we want to count
     *   }
     * })
    **/
    count<T extends MedicineOrderCountArgs>(
      args?: Subset<T, MedicineOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineOrderAggregateArgs>(args: Subset<T, MedicineOrderAggregateArgs>): Prisma.PrismaPromise<GetMedicineOrderAggregateType<T>>

    /**
     * Group by MedicineOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineOrderGroupByArgs['orderBy'] }
        : { orderBy?: MedicineOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineOrder model
   */
  readonly fields: MedicineOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends MedicineOrder$itemsArgs<ExtArgs> = {}>(args?: Subset<T, MedicineOrder$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineOrder model
   */ 
  interface MedicineOrderFieldRefs {
    readonly id: FieldRef<"MedicineOrder", 'Int'>
    readonly uuid: FieldRef<"MedicineOrder", 'String'>
    readonly userId: FieldRef<"MedicineOrder", 'Int'>
    readonly orderDate: FieldRef<"MedicineOrder", 'DateTime'>
    readonly deliveryAddress: FieldRef<"MedicineOrder", 'String'>
    readonly status: FieldRef<"MedicineOrder", 'String'>
    readonly totalAmount: FieldRef<"MedicineOrder", 'Float'>
    readonly paymentMethod: FieldRef<"MedicineOrder", 'String'>
    readonly paymentStatus: FieldRef<"MedicineOrder", 'String'>
    readonly prescriptionUrl: FieldRef<"MedicineOrder", 'String'>
    readonly deliveryDate: FieldRef<"MedicineOrder", 'DateTime'>
    readonly expectedDeliveryDate: FieldRef<"MedicineOrder", 'DateTime'>
    readonly trackingNumber: FieldRef<"MedicineOrder", 'String'>
    readonly createdAt: FieldRef<"MedicineOrder", 'DateTime'>
    readonly updatedAt: FieldRef<"MedicineOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicineOrder findUnique
   */
  export type MedicineOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrder to fetch.
     */
    where: MedicineOrderWhereUniqueInput
  }

  /**
   * MedicineOrder findUniqueOrThrow
   */
  export type MedicineOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrder to fetch.
     */
    where: MedicineOrderWhereUniqueInput
  }

  /**
   * MedicineOrder findFirst
   */
  export type MedicineOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrder to fetch.
     */
    where?: MedicineOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrders to fetch.
     */
    orderBy?: MedicineOrderOrderByWithRelationInput | MedicineOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineOrders.
     */
    cursor?: MedicineOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineOrders.
     */
    distinct?: MedicineOrderScalarFieldEnum | MedicineOrderScalarFieldEnum[]
  }

  /**
   * MedicineOrder findFirstOrThrow
   */
  export type MedicineOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrder to fetch.
     */
    where?: MedicineOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrders to fetch.
     */
    orderBy?: MedicineOrderOrderByWithRelationInput | MedicineOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineOrders.
     */
    cursor?: MedicineOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineOrders.
     */
    distinct?: MedicineOrderScalarFieldEnum | MedicineOrderScalarFieldEnum[]
  }

  /**
   * MedicineOrder findMany
   */
  export type MedicineOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrders to fetch.
     */
    where?: MedicineOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrders to fetch.
     */
    orderBy?: MedicineOrderOrderByWithRelationInput | MedicineOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineOrders.
     */
    cursor?: MedicineOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrders.
     */
    skip?: number
    distinct?: MedicineOrderScalarFieldEnum | MedicineOrderScalarFieldEnum[]
  }

  /**
   * MedicineOrder create
   */
  export type MedicineOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineOrder.
     */
    data: XOR<MedicineOrderCreateInput, MedicineOrderUncheckedCreateInput>
  }

  /**
   * MedicineOrder createMany
   */
  export type MedicineOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineOrders.
     */
    data: MedicineOrderCreateManyInput | MedicineOrderCreateManyInput[]
  }

  /**
   * MedicineOrder createManyAndReturn
   */
  export type MedicineOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicineOrders.
     */
    data: MedicineOrderCreateManyInput | MedicineOrderCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineOrder update
   */
  export type MedicineOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineOrder.
     */
    data: XOR<MedicineOrderUpdateInput, MedicineOrderUncheckedUpdateInput>
    /**
     * Choose, which MedicineOrder to update.
     */
    where: MedicineOrderWhereUniqueInput
  }

  /**
   * MedicineOrder updateMany
   */
  export type MedicineOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineOrders.
     */
    data: XOR<MedicineOrderUpdateManyMutationInput, MedicineOrderUncheckedUpdateManyInput>
    /**
     * Filter which MedicineOrders to update
     */
    where?: MedicineOrderWhereInput
  }

  /**
   * MedicineOrder upsert
   */
  export type MedicineOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineOrder to update in case it exists.
     */
    where: MedicineOrderWhereUniqueInput
    /**
     * In case the MedicineOrder found by the `where` argument doesn't exist, create a new MedicineOrder with this data.
     */
    create: XOR<MedicineOrderCreateInput, MedicineOrderUncheckedCreateInput>
    /**
     * In case the MedicineOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineOrderUpdateInput, MedicineOrderUncheckedUpdateInput>
  }

  /**
   * MedicineOrder delete
   */
  export type MedicineOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
    /**
     * Filter which MedicineOrder to delete.
     */
    where: MedicineOrderWhereUniqueInput
  }

  /**
   * MedicineOrder deleteMany
   */
  export type MedicineOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineOrders to delete
     */
    where?: MedicineOrderWhereInput
  }

  /**
   * MedicineOrder.items
   */
  export type MedicineOrder$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    where?: MedicineOrderItemWhereInput
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    cursor?: MedicineOrderItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicineOrderItemScalarFieldEnum | MedicineOrderItemScalarFieldEnum[]
  }

  /**
   * MedicineOrder without action
   */
  export type MedicineOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrder
     */
    select?: MedicineOrderSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderInclude<ExtArgs> | null
  }


  /**
   * Model MedicineOrderItem
   */

  export type AggregateMedicineOrderItem = {
    _count: MedicineOrderItemCountAggregateOutputType | null
    _avg: MedicineOrderItemAvgAggregateOutputType | null
    _sum: MedicineOrderItemSumAggregateOutputType | null
    _min: MedicineOrderItemMinAggregateOutputType | null
    _max: MedicineOrderItemMaxAggregateOutputType | null
  }

  export type MedicineOrderItemAvgAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    quantity: number | null
    price: number | null
  }

  export type MedicineOrderItemSumAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    quantity: number | null
    price: number | null
  }

  export type MedicineOrderItemMinAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    quantity: number | null
    price: number | null
  }

  export type MedicineOrderItemMaxAggregateOutputType = {
    id: number | null
    orderId: number | null
    medicineId: number | null
    quantity: number | null
    price: number | null
  }

  export type MedicineOrderItemCountAggregateOutputType = {
    id: number
    orderId: number
    medicineId: number
    quantity: number
    price: number
    _all: number
  }


  export type MedicineOrderItemAvgAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    quantity?: true
    price?: true
  }

  export type MedicineOrderItemSumAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    quantity?: true
    price?: true
  }

  export type MedicineOrderItemMinAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    quantity?: true
    price?: true
  }

  export type MedicineOrderItemMaxAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    quantity?: true
    price?: true
  }

  export type MedicineOrderItemCountAggregateInputType = {
    id?: true
    orderId?: true
    medicineId?: true
    quantity?: true
    price?: true
    _all?: true
  }

  export type MedicineOrderItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineOrderItem to aggregate.
     */
    where?: MedicineOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrderItems to fetch.
     */
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicineOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicineOrderItems
    **/
    _count?: true | MedicineOrderItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MedicineOrderItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MedicineOrderItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicineOrderItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicineOrderItemMaxAggregateInputType
  }

  export type GetMedicineOrderItemAggregateType<T extends MedicineOrderItemAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicineOrderItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicineOrderItem[P]>
      : GetScalarType<T[P], AggregateMedicineOrderItem[P]>
  }




  export type MedicineOrderItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicineOrderItemWhereInput
    orderBy?: MedicineOrderItemOrderByWithAggregationInput | MedicineOrderItemOrderByWithAggregationInput[]
    by: MedicineOrderItemScalarFieldEnum[] | MedicineOrderItemScalarFieldEnum
    having?: MedicineOrderItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicineOrderItemCountAggregateInputType | true
    _avg?: MedicineOrderItemAvgAggregateInputType
    _sum?: MedicineOrderItemSumAggregateInputType
    _min?: MedicineOrderItemMinAggregateInputType
    _max?: MedicineOrderItemMaxAggregateInputType
  }

  export type MedicineOrderItemGroupByOutputType = {
    id: number
    orderId: number
    medicineId: number
    quantity: number
    price: number
    _count: MedicineOrderItemCountAggregateOutputType | null
    _avg: MedicineOrderItemAvgAggregateOutputType | null
    _sum: MedicineOrderItemSumAggregateOutputType | null
    _min: MedicineOrderItemMinAggregateOutputType | null
    _max: MedicineOrderItemMaxAggregateOutputType | null
  }

  type GetMedicineOrderItemGroupByPayload<T extends MedicineOrderItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicineOrderItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicineOrderItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicineOrderItemGroupByOutputType[P]>
            : GetScalarType<T[P], MedicineOrderItemGroupByOutputType[P]>
        }
      >
    >


  export type MedicineOrderItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | MedicineOrderDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineOrderItem"]>

  export type MedicineOrderItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    quantity?: boolean
    price?: boolean
    order?: boolean | MedicineOrderDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicineOrderItem"]>

  export type MedicineOrderItemSelectScalar = {
    id?: boolean
    orderId?: boolean
    medicineId?: boolean
    quantity?: boolean
    price?: boolean
  }

  export type MedicineOrderItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | MedicineOrderDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }
  export type MedicineOrderItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    order?: boolean | MedicineOrderDefaultArgs<ExtArgs>
    medicine?: boolean | MedicineDefaultArgs<ExtArgs>
  }

  export type $MedicineOrderItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicineOrderItem"
    objects: {
      order: Prisma.$MedicineOrderPayload<ExtArgs>
      medicine: Prisma.$MedicinePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      orderId: number
      medicineId: number
      quantity: number
      price: number
    }, ExtArgs["result"]["medicineOrderItem"]>
    composites: {}
  }

  type MedicineOrderItemGetPayload<S extends boolean | null | undefined | MedicineOrderItemDefaultArgs> = $Result.GetResult<Prisma.$MedicineOrderItemPayload, S>

  type MedicineOrderItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicineOrderItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicineOrderItemCountAggregateInputType | true
    }

  export interface MedicineOrderItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicineOrderItem'], meta: { name: 'MedicineOrderItem' } }
    /**
     * Find zero or one MedicineOrderItem that matches the filter.
     * @param {MedicineOrderItemFindUniqueArgs} args - Arguments to find a MedicineOrderItem
     * @example
     * // Get one MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicineOrderItemFindUniqueArgs>(args: SelectSubset<T, MedicineOrderItemFindUniqueArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicineOrderItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicineOrderItemFindUniqueOrThrowArgs} args - Arguments to find a MedicineOrderItem
     * @example
     * // Get one MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicineOrderItemFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicineOrderItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicineOrderItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemFindFirstArgs} args - Arguments to find a MedicineOrderItem
     * @example
     * // Get one MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicineOrderItemFindFirstArgs>(args?: SelectSubset<T, MedicineOrderItemFindFirstArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicineOrderItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemFindFirstOrThrowArgs} args - Arguments to find a MedicineOrderItem
     * @example
     * // Get one MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicineOrderItemFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicineOrderItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicineOrderItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicineOrderItems
     * const medicineOrderItems = await prisma.medicineOrderItem.findMany()
     * 
     * // Get first 10 MedicineOrderItems
     * const medicineOrderItems = await prisma.medicineOrderItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicineOrderItemWithIdOnly = await prisma.medicineOrderItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicineOrderItemFindManyArgs>(args?: SelectSubset<T, MedicineOrderItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicineOrderItem.
     * @param {MedicineOrderItemCreateArgs} args - Arguments to create a MedicineOrderItem.
     * @example
     * // Create one MedicineOrderItem
     * const MedicineOrderItem = await prisma.medicineOrderItem.create({
     *   data: {
     *     // ... data to create a MedicineOrderItem
     *   }
     * })
     * 
     */
    create<T extends MedicineOrderItemCreateArgs>(args: SelectSubset<T, MedicineOrderItemCreateArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicineOrderItems.
     * @param {MedicineOrderItemCreateManyArgs} args - Arguments to create many MedicineOrderItems.
     * @example
     * // Create many MedicineOrderItems
     * const medicineOrderItem = await prisma.medicineOrderItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicineOrderItemCreateManyArgs>(args?: SelectSubset<T, MedicineOrderItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicineOrderItems and returns the data saved in the database.
     * @param {MedicineOrderItemCreateManyAndReturnArgs} args - Arguments to create many MedicineOrderItems.
     * @example
     * // Create many MedicineOrderItems
     * const medicineOrderItem = await prisma.medicineOrderItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicineOrderItems and only return the `id`
     * const medicineOrderItemWithIdOnly = await prisma.medicineOrderItem.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicineOrderItemCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicineOrderItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicineOrderItem.
     * @param {MedicineOrderItemDeleteArgs} args - Arguments to delete one MedicineOrderItem.
     * @example
     * // Delete one MedicineOrderItem
     * const MedicineOrderItem = await prisma.medicineOrderItem.delete({
     *   where: {
     *     // ... filter to delete one MedicineOrderItem
     *   }
     * })
     * 
     */
    delete<T extends MedicineOrderItemDeleteArgs>(args: SelectSubset<T, MedicineOrderItemDeleteArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicineOrderItem.
     * @param {MedicineOrderItemUpdateArgs} args - Arguments to update one MedicineOrderItem.
     * @example
     * // Update one MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicineOrderItemUpdateArgs>(args: SelectSubset<T, MedicineOrderItemUpdateArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicineOrderItems.
     * @param {MedicineOrderItemDeleteManyArgs} args - Arguments to filter MedicineOrderItems to delete.
     * @example
     * // Delete a few MedicineOrderItems
     * const { count } = await prisma.medicineOrderItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicineOrderItemDeleteManyArgs>(args?: SelectSubset<T, MedicineOrderItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicineOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicineOrderItems
     * const medicineOrderItem = await prisma.medicineOrderItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicineOrderItemUpdateManyArgs>(args: SelectSubset<T, MedicineOrderItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicineOrderItem.
     * @param {MedicineOrderItemUpsertArgs} args - Arguments to update or create a MedicineOrderItem.
     * @example
     * // Update or create a MedicineOrderItem
     * const medicineOrderItem = await prisma.medicineOrderItem.upsert({
     *   create: {
     *     // ... data to create a MedicineOrderItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicineOrderItem we want to update
     *   }
     * })
     */
    upsert<T extends MedicineOrderItemUpsertArgs>(args: SelectSubset<T, MedicineOrderItemUpsertArgs<ExtArgs>>): Prisma__MedicineOrderItemClient<$Result.GetResult<Prisma.$MedicineOrderItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicineOrderItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemCountArgs} args - Arguments to filter MedicineOrderItems to count.
     * @example
     * // Count the number of MedicineOrderItems
     * const count = await prisma.medicineOrderItem.count({
     *   where: {
     *     // ... the filter for the MedicineOrderItems we want to count
     *   }
     * })
    **/
    count<T extends MedicineOrderItemCountArgs>(
      args?: Subset<T, MedicineOrderItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicineOrderItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicineOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicineOrderItemAggregateArgs>(args: Subset<T, MedicineOrderItemAggregateArgs>): Prisma.PrismaPromise<GetMedicineOrderItemAggregateType<T>>

    /**
     * Group by MedicineOrderItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicineOrderItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicineOrderItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicineOrderItemGroupByArgs['orderBy'] }
        : { orderBy?: MedicineOrderItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicineOrderItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicineOrderItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicineOrderItem model
   */
  readonly fields: MedicineOrderItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicineOrderItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicineOrderItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    order<T extends MedicineOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineOrderDefaultArgs<ExtArgs>>): Prisma__MedicineOrderClient<$Result.GetResult<Prisma.$MedicineOrderPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    medicine<T extends MedicineDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MedicineDefaultArgs<ExtArgs>>): Prisma__MedicineClient<$Result.GetResult<Prisma.$MedicinePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicineOrderItem model
   */ 
  interface MedicineOrderItemFieldRefs {
    readonly id: FieldRef<"MedicineOrderItem", 'Int'>
    readonly orderId: FieldRef<"MedicineOrderItem", 'Int'>
    readonly medicineId: FieldRef<"MedicineOrderItem", 'Int'>
    readonly quantity: FieldRef<"MedicineOrderItem", 'Int'>
    readonly price: FieldRef<"MedicineOrderItem", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * MedicineOrderItem findUnique
   */
  export type MedicineOrderItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrderItem to fetch.
     */
    where: MedicineOrderItemWhereUniqueInput
  }

  /**
   * MedicineOrderItem findUniqueOrThrow
   */
  export type MedicineOrderItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrderItem to fetch.
     */
    where: MedicineOrderItemWhereUniqueInput
  }

  /**
   * MedicineOrderItem findFirst
   */
  export type MedicineOrderItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrderItem to fetch.
     */
    where?: MedicineOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrderItems to fetch.
     */
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineOrderItems.
     */
    cursor?: MedicineOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineOrderItems.
     */
    distinct?: MedicineOrderItemScalarFieldEnum | MedicineOrderItemScalarFieldEnum[]
  }

  /**
   * MedicineOrderItem findFirstOrThrow
   */
  export type MedicineOrderItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrderItem to fetch.
     */
    where?: MedicineOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrderItems to fetch.
     */
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicineOrderItems.
     */
    cursor?: MedicineOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrderItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicineOrderItems.
     */
    distinct?: MedicineOrderItemScalarFieldEnum | MedicineOrderItemScalarFieldEnum[]
  }

  /**
   * MedicineOrderItem findMany
   */
  export type MedicineOrderItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter, which MedicineOrderItems to fetch.
     */
    where?: MedicineOrderItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicineOrderItems to fetch.
     */
    orderBy?: MedicineOrderItemOrderByWithRelationInput | MedicineOrderItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicineOrderItems.
     */
    cursor?: MedicineOrderItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicineOrderItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicineOrderItems.
     */
    skip?: number
    distinct?: MedicineOrderItemScalarFieldEnum | MedicineOrderItemScalarFieldEnum[]
  }

  /**
   * MedicineOrderItem create
   */
  export type MedicineOrderItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicineOrderItem.
     */
    data: XOR<MedicineOrderItemCreateInput, MedicineOrderItemUncheckedCreateInput>
  }

  /**
   * MedicineOrderItem createMany
   */
  export type MedicineOrderItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicineOrderItems.
     */
    data: MedicineOrderItemCreateManyInput | MedicineOrderItemCreateManyInput[]
  }

  /**
   * MedicineOrderItem createManyAndReturn
   */
  export type MedicineOrderItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicineOrderItems.
     */
    data: MedicineOrderItemCreateManyInput | MedicineOrderItemCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicineOrderItem update
   */
  export type MedicineOrderItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicineOrderItem.
     */
    data: XOR<MedicineOrderItemUpdateInput, MedicineOrderItemUncheckedUpdateInput>
    /**
     * Choose, which MedicineOrderItem to update.
     */
    where: MedicineOrderItemWhereUniqueInput
  }

  /**
   * MedicineOrderItem updateMany
   */
  export type MedicineOrderItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicineOrderItems.
     */
    data: XOR<MedicineOrderItemUpdateManyMutationInput, MedicineOrderItemUncheckedUpdateManyInput>
    /**
     * Filter which MedicineOrderItems to update
     */
    where?: MedicineOrderItemWhereInput
  }

  /**
   * MedicineOrderItem upsert
   */
  export type MedicineOrderItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicineOrderItem to update in case it exists.
     */
    where: MedicineOrderItemWhereUniqueInput
    /**
     * In case the MedicineOrderItem found by the `where` argument doesn't exist, create a new MedicineOrderItem with this data.
     */
    create: XOR<MedicineOrderItemCreateInput, MedicineOrderItemUncheckedCreateInput>
    /**
     * In case the MedicineOrderItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicineOrderItemUpdateInput, MedicineOrderItemUncheckedUpdateInput>
  }

  /**
   * MedicineOrderItem delete
   */
  export type MedicineOrderItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
    /**
     * Filter which MedicineOrderItem to delete.
     */
    where: MedicineOrderItemWhereUniqueInput
  }

  /**
   * MedicineOrderItem deleteMany
   */
  export type MedicineOrderItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicineOrderItems to delete
     */
    where?: MedicineOrderItemWhereInput
  }

  /**
   * MedicineOrderItem without action
   */
  export type MedicineOrderItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicineOrderItem
     */
    select?: MedicineOrderItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicineOrderItemInclude<ExtArgs> | null
  }


  /**
   * Model LabTest
   */

  export type AggregateLabTest = {
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  export type LabTestAvgAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type LabTestSumAggregateOutputType = {
    id: number | null
    price: number | null
  }

  export type LabTestMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    category: string | null
    price: number | null
    description: string | null
    preparation: string | null
    parameters: string | null
    turnaroundTime: string | null
    available: boolean | null
    createdAt: Date | null
  }

  export type LabTestMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    name: string | null
    category: string | null
    price: number | null
    description: string | null
    preparation: string | null
    parameters: string | null
    turnaroundTime: string | null
    available: boolean | null
    createdAt: Date | null
  }

  export type LabTestCountAggregateOutputType = {
    id: number
    uuid: number
    name: number
    category: number
    price: number
    description: number
    preparation: number
    parameters: number
    turnaroundTime: number
    available: number
    createdAt: number
    _all: number
  }


  export type LabTestAvgAggregateInputType = {
    id?: true
    price?: true
  }

  export type LabTestSumAggregateInputType = {
    id?: true
    price?: true
  }

  export type LabTestMinAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    category?: true
    price?: true
    description?: true
    preparation?: true
    parameters?: true
    turnaroundTime?: true
    available?: true
    createdAt?: true
  }

  export type LabTestMaxAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    category?: true
    price?: true
    description?: true
    preparation?: true
    parameters?: true
    turnaroundTime?: true
    available?: true
    createdAt?: true
  }

  export type LabTestCountAggregateInputType = {
    id?: true
    uuid?: true
    name?: true
    category?: true
    price?: true
    description?: true
    preparation?: true
    parameters?: true
    turnaroundTime?: true
    available?: true
    createdAt?: true
    _all?: true
  }

  export type LabTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTest to aggregate.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabTests
    **/
    _count?: true | LabTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabTestMaxAggregateInputType
  }

  export type GetLabTestAggregateType<T extends LabTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabTest[P]>
      : GetScalarType<T[P], AggregateLabTest[P]>
  }




  export type LabTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabTestWhereInput
    orderBy?: LabTestOrderByWithAggregationInput | LabTestOrderByWithAggregationInput[]
    by: LabTestScalarFieldEnum[] | LabTestScalarFieldEnum
    having?: LabTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabTestCountAggregateInputType | true
    _avg?: LabTestAvgAggregateInputType
    _sum?: LabTestSumAggregateInputType
    _min?: LabTestMinAggregateInputType
    _max?: LabTestMaxAggregateInputType
  }

  export type LabTestGroupByOutputType = {
    id: number
    uuid: string
    name: string
    category: string | null
    price: number
    description: string | null
    preparation: string | null
    parameters: string | null
    turnaroundTime: string | null
    available: boolean
    createdAt: Date
    _count: LabTestCountAggregateOutputType | null
    _avg: LabTestAvgAggregateOutputType | null
    _sum: LabTestSumAggregateOutputType | null
    _min: LabTestMinAggregateOutputType | null
    _max: LabTestMaxAggregateOutputType | null
  }

  type GetLabTestGroupByPayload<T extends LabTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabTestGroupByOutputType[P]>
        }
      >
    >


  export type LabTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    description?: boolean
    preparation?: boolean
    parameters?: boolean
    turnaroundTime?: boolean
    available?: boolean
    createdAt?: boolean
    bookings?: boolean | LabTest$bookingsArgs<ExtArgs>
    _count?: boolean | LabTestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    description?: boolean
    preparation?: boolean
    parameters?: boolean
    turnaroundTime?: boolean
    available?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["labTest"]>

  export type LabTestSelectScalar = {
    id?: boolean
    uuid?: boolean
    name?: boolean
    category?: boolean
    price?: boolean
    description?: boolean
    preparation?: boolean
    parameters?: boolean
    turnaroundTime?: boolean
    available?: boolean
    createdAt?: boolean
  }

  export type LabTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | LabTest$bookingsArgs<ExtArgs>
    _count?: boolean | LabTestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $LabTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabTest"
    objects: {
      bookings: Prisma.$LabBookingTestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      name: string
      category: string | null
      price: number
      description: string | null
      preparation: string | null
      parameters: string | null
      turnaroundTime: string | null
      available: boolean
      createdAt: Date
    }, ExtArgs["result"]["labTest"]>
    composites: {}
  }

  type LabTestGetPayload<S extends boolean | null | undefined | LabTestDefaultArgs> = $Result.GetResult<Prisma.$LabTestPayload, S>

  type LabTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabTestCountAggregateInputType | true
    }

  export interface LabTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabTest'], meta: { name: 'LabTest' } }
    /**
     * Find zero or one LabTest that matches the filter.
     * @param {LabTestFindUniqueArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabTestFindUniqueArgs>(args: SelectSubset<T, LabTestFindUniqueArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabTestFindUniqueOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabTestFindFirstArgs>(args?: SelectSubset<T, LabTestFindFirstArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindFirstOrThrowArgs} args - Arguments to find a LabTest
     * @example
     * // Get one LabTest
     * const labTest = await prisma.labTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabTests
     * const labTests = await prisma.labTest.findMany()
     * 
     * // Get first 10 LabTests
     * const labTests = await prisma.labTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labTestWithIdOnly = await prisma.labTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabTestFindManyArgs>(args?: SelectSubset<T, LabTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabTest.
     * @param {LabTestCreateArgs} args - Arguments to create a LabTest.
     * @example
     * // Create one LabTest
     * const LabTest = await prisma.labTest.create({
     *   data: {
     *     // ... data to create a LabTest
     *   }
     * })
     * 
     */
    create<T extends LabTestCreateArgs>(args: SelectSubset<T, LabTestCreateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabTests.
     * @param {LabTestCreateManyArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabTestCreateManyArgs>(args?: SelectSubset<T, LabTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabTests and returns the data saved in the database.
     * @param {LabTestCreateManyAndReturnArgs} args - Arguments to create many LabTests.
     * @example
     * // Create many LabTests
     * const labTest = await prisma.labTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabTests and only return the `id`
     * const labTestWithIdOnly = await prisma.labTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabTest.
     * @param {LabTestDeleteArgs} args - Arguments to delete one LabTest.
     * @example
     * // Delete one LabTest
     * const LabTest = await prisma.labTest.delete({
     *   where: {
     *     // ... filter to delete one LabTest
     *   }
     * })
     * 
     */
    delete<T extends LabTestDeleteArgs>(args: SelectSubset<T, LabTestDeleteArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabTest.
     * @param {LabTestUpdateArgs} args - Arguments to update one LabTest.
     * @example
     * // Update one LabTest
     * const labTest = await prisma.labTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabTestUpdateArgs>(args: SelectSubset<T, LabTestUpdateArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabTests.
     * @param {LabTestDeleteManyArgs} args - Arguments to filter LabTests to delete.
     * @example
     * // Delete a few LabTests
     * const { count } = await prisma.labTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabTestDeleteManyArgs>(args?: SelectSubset<T, LabTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabTests
     * const labTest = await prisma.labTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabTestUpdateManyArgs>(args: SelectSubset<T, LabTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabTest.
     * @param {LabTestUpsertArgs} args - Arguments to update or create a LabTest.
     * @example
     * // Update or create a LabTest
     * const labTest = await prisma.labTest.upsert({
     *   create: {
     *     // ... data to create a LabTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabTest we want to update
     *   }
     * })
     */
    upsert<T extends LabTestUpsertArgs>(args: SelectSubset<T, LabTestUpsertArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestCountArgs} args - Arguments to filter LabTests to count.
     * @example
     * // Count the number of LabTests
     * const count = await prisma.labTest.count({
     *   where: {
     *     // ... the filter for the LabTests we want to count
     *   }
     * })
    **/
    count<T extends LabTestCountArgs>(
      args?: Subset<T, LabTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabTestAggregateArgs>(args: Subset<T, LabTestAggregateArgs>): Prisma.PrismaPromise<GetLabTestAggregateType<T>>

    /**
     * Group by LabTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabTestGroupByArgs['orderBy'] }
        : { orderBy?: LabTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabTest model
   */
  readonly fields: LabTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookings<T extends LabTest$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, LabTest$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabTest model
   */ 
  interface LabTestFieldRefs {
    readonly id: FieldRef<"LabTest", 'Int'>
    readonly uuid: FieldRef<"LabTest", 'String'>
    readonly name: FieldRef<"LabTest", 'String'>
    readonly category: FieldRef<"LabTest", 'String'>
    readonly price: FieldRef<"LabTest", 'Float'>
    readonly description: FieldRef<"LabTest", 'String'>
    readonly preparation: FieldRef<"LabTest", 'String'>
    readonly parameters: FieldRef<"LabTest", 'String'>
    readonly turnaroundTime: FieldRef<"LabTest", 'String'>
    readonly available: FieldRef<"LabTest", 'Boolean'>
    readonly createdAt: FieldRef<"LabTest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabTest findUnique
   */
  export type LabTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findUniqueOrThrow
   */
  export type LabTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest findFirst
   */
  export type LabTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findFirstOrThrow
   */
  export type LabTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTest to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabTests.
     */
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest findMany
   */
  export type LabTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter, which LabTests to fetch.
     */
    where?: LabTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabTests to fetch.
     */
    orderBy?: LabTestOrderByWithRelationInput | LabTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabTests.
     */
    cursor?: LabTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabTests.
     */
    skip?: number
    distinct?: LabTestScalarFieldEnum | LabTestScalarFieldEnum[]
  }

  /**
   * LabTest create
   */
  export type LabTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabTest.
     */
    data: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
  }

  /**
   * LabTest createMany
   */
  export type LabTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
  }

  /**
   * LabTest createManyAndReturn
   */
  export type LabTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabTests.
     */
    data: LabTestCreateManyInput | LabTestCreateManyInput[]
  }

  /**
   * LabTest update
   */
  export type LabTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabTest.
     */
    data: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
    /**
     * Choose, which LabTest to update.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest updateMany
   */
  export type LabTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabTests.
     */
    data: XOR<LabTestUpdateManyMutationInput, LabTestUncheckedUpdateManyInput>
    /**
     * Filter which LabTests to update
     */
    where?: LabTestWhereInput
  }

  /**
   * LabTest upsert
   */
  export type LabTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabTest to update in case it exists.
     */
    where: LabTestWhereUniqueInput
    /**
     * In case the LabTest found by the `where` argument doesn't exist, create a new LabTest with this data.
     */
    create: XOR<LabTestCreateInput, LabTestUncheckedCreateInput>
    /**
     * In case the LabTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabTestUpdateInput, LabTestUncheckedUpdateInput>
  }

  /**
   * LabTest delete
   */
  export type LabTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
    /**
     * Filter which LabTest to delete.
     */
    where: LabTestWhereUniqueInput
  }

  /**
   * LabTest deleteMany
   */
  export type LabTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabTests to delete
     */
    where?: LabTestWhereInput
  }

  /**
   * LabTest.bookings
   */
  export type LabTest$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    where?: LabBookingTestWhereInput
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    cursor?: LabBookingTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabBookingTestScalarFieldEnum | LabBookingTestScalarFieldEnum[]
  }

  /**
   * LabTest without action
   */
  export type LabTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabTest
     */
    select?: LabTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabTestInclude<ExtArgs> | null
  }


  /**
   * Model LabBooking
   */

  export type AggregateLabBooking = {
    _count: LabBookingCountAggregateOutputType | null
    _avg: LabBookingAvgAggregateOutputType | null
    _sum: LabBookingSumAggregateOutputType | null
    _min: LabBookingMinAggregateOutputType | null
    _max: LabBookingMaxAggregateOutputType | null
  }

  export type LabBookingAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
  }

  export type LabBookingSumAggregateOutputType = {
    id: number | null
    userId: number | null
    totalAmount: number | null
  }

  export type LabBookingMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    bookingDate: Date | null
    collectionType: string | null
    address: string | null
    status: string | null
    totalAmount: number | null
    paymentStatus: string | null
    reportUrl: string | null
    reportReadyDate: Date | null
    createdAt: Date | null
  }

  export type LabBookingMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    bookingDate: Date | null
    collectionType: string | null
    address: string | null
    status: string | null
    totalAmount: number | null
    paymentStatus: string | null
    reportUrl: string | null
    reportReadyDate: Date | null
    createdAt: Date | null
  }

  export type LabBookingCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    bookingDate: number
    collectionType: number
    address: number
    status: number
    totalAmount: number
    paymentStatus: number
    reportUrl: number
    reportReadyDate: number
    createdAt: number
    _all: number
  }


  export type LabBookingAvgAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
  }

  export type LabBookingSumAggregateInputType = {
    id?: true
    userId?: true
    totalAmount?: true
  }

  export type LabBookingMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    bookingDate?: true
    collectionType?: true
    address?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    reportUrl?: true
    reportReadyDate?: true
    createdAt?: true
  }

  export type LabBookingMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    bookingDate?: true
    collectionType?: true
    address?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    reportUrl?: true
    reportReadyDate?: true
    createdAt?: true
  }

  export type LabBookingCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    bookingDate?: true
    collectionType?: true
    address?: true
    status?: true
    totalAmount?: true
    paymentStatus?: true
    reportUrl?: true
    reportReadyDate?: true
    createdAt?: true
    _all?: true
  }

  export type LabBookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabBooking to aggregate.
     */
    where?: LabBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookings to fetch.
     */
    orderBy?: LabBookingOrderByWithRelationInput | LabBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabBookings
    **/
    _count?: true | LabBookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabBookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabBookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabBookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabBookingMaxAggregateInputType
  }

  export type GetLabBookingAggregateType<T extends LabBookingAggregateArgs> = {
        [P in keyof T & keyof AggregateLabBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabBooking[P]>
      : GetScalarType<T[P], AggregateLabBooking[P]>
  }




  export type LabBookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabBookingWhereInput
    orderBy?: LabBookingOrderByWithAggregationInput | LabBookingOrderByWithAggregationInput[]
    by: LabBookingScalarFieldEnum[] | LabBookingScalarFieldEnum
    having?: LabBookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabBookingCountAggregateInputType | true
    _avg?: LabBookingAvgAggregateInputType
    _sum?: LabBookingSumAggregateInputType
    _min?: LabBookingMinAggregateInputType
    _max?: LabBookingMaxAggregateInputType
  }

  export type LabBookingGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    bookingDate: Date
    collectionType: string
    address: string | null
    status: string
    totalAmount: number
    paymentStatus: string
    reportUrl: string | null
    reportReadyDate: Date | null
    createdAt: Date
    _count: LabBookingCountAggregateOutputType | null
    _avg: LabBookingAvgAggregateOutputType | null
    _sum: LabBookingSumAggregateOutputType | null
    _min: LabBookingMinAggregateOutputType | null
    _max: LabBookingMaxAggregateOutputType | null
  }

  type GetLabBookingGroupByPayload<T extends LabBookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabBookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabBookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabBookingGroupByOutputType[P]>
            : GetScalarType<T[P], LabBookingGroupByOutputType[P]>
        }
      >
    >


  export type LabBookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    bookingDate?: boolean
    collectionType?: boolean
    address?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    reportUrl?: boolean
    reportReadyDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    tests?: boolean | LabBooking$testsArgs<ExtArgs>
    report?: boolean | LabBooking$reportArgs<ExtArgs>
    _count?: boolean | LabBookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labBooking"]>

  export type LabBookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    bookingDate?: boolean
    collectionType?: boolean
    address?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    reportUrl?: boolean
    reportReadyDate?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labBooking"]>

  export type LabBookingSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    bookingDate?: boolean
    collectionType?: boolean
    address?: boolean
    status?: boolean
    totalAmount?: boolean
    paymentStatus?: boolean
    reportUrl?: boolean
    reportReadyDate?: boolean
    createdAt?: boolean
  }

  export type LabBookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    tests?: boolean | LabBooking$testsArgs<ExtArgs>
    report?: boolean | LabBooking$reportArgs<ExtArgs>
    _count?: boolean | LabBookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LabBookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LabBookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabBooking"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      tests: Prisma.$LabBookingTestPayload<ExtArgs>[]
      report: Prisma.$LabReportPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      bookingDate: Date
      collectionType: string
      address: string | null
      status: string
      totalAmount: number
      paymentStatus: string
      reportUrl: string | null
      reportReadyDate: Date | null
      createdAt: Date
    }, ExtArgs["result"]["labBooking"]>
    composites: {}
  }

  type LabBookingGetPayload<S extends boolean | null | undefined | LabBookingDefaultArgs> = $Result.GetResult<Prisma.$LabBookingPayload, S>

  type LabBookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabBookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabBookingCountAggregateInputType | true
    }

  export interface LabBookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabBooking'], meta: { name: 'LabBooking' } }
    /**
     * Find zero or one LabBooking that matches the filter.
     * @param {LabBookingFindUniqueArgs} args - Arguments to find a LabBooking
     * @example
     * // Get one LabBooking
     * const labBooking = await prisma.labBooking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabBookingFindUniqueArgs>(args: SelectSubset<T, LabBookingFindUniqueArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabBooking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabBookingFindUniqueOrThrowArgs} args - Arguments to find a LabBooking
     * @example
     * // Get one LabBooking
     * const labBooking = await prisma.labBooking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabBookingFindUniqueOrThrowArgs>(args: SelectSubset<T, LabBookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabBooking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingFindFirstArgs} args - Arguments to find a LabBooking
     * @example
     * // Get one LabBooking
     * const labBooking = await prisma.labBooking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabBookingFindFirstArgs>(args?: SelectSubset<T, LabBookingFindFirstArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabBooking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingFindFirstOrThrowArgs} args - Arguments to find a LabBooking
     * @example
     * // Get one LabBooking
     * const labBooking = await prisma.labBooking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabBookingFindFirstOrThrowArgs>(args?: SelectSubset<T, LabBookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabBookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabBookings
     * const labBookings = await prisma.labBooking.findMany()
     * 
     * // Get first 10 LabBookings
     * const labBookings = await prisma.labBooking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labBookingWithIdOnly = await prisma.labBooking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabBookingFindManyArgs>(args?: SelectSubset<T, LabBookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabBooking.
     * @param {LabBookingCreateArgs} args - Arguments to create a LabBooking.
     * @example
     * // Create one LabBooking
     * const LabBooking = await prisma.labBooking.create({
     *   data: {
     *     // ... data to create a LabBooking
     *   }
     * })
     * 
     */
    create<T extends LabBookingCreateArgs>(args: SelectSubset<T, LabBookingCreateArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabBookings.
     * @param {LabBookingCreateManyArgs} args - Arguments to create many LabBookings.
     * @example
     * // Create many LabBookings
     * const labBooking = await prisma.labBooking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabBookingCreateManyArgs>(args?: SelectSubset<T, LabBookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabBookings and returns the data saved in the database.
     * @param {LabBookingCreateManyAndReturnArgs} args - Arguments to create many LabBookings.
     * @example
     * // Create many LabBookings
     * const labBooking = await prisma.labBooking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabBookings and only return the `id`
     * const labBookingWithIdOnly = await prisma.labBooking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabBookingCreateManyAndReturnArgs>(args?: SelectSubset<T, LabBookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabBooking.
     * @param {LabBookingDeleteArgs} args - Arguments to delete one LabBooking.
     * @example
     * // Delete one LabBooking
     * const LabBooking = await prisma.labBooking.delete({
     *   where: {
     *     // ... filter to delete one LabBooking
     *   }
     * })
     * 
     */
    delete<T extends LabBookingDeleteArgs>(args: SelectSubset<T, LabBookingDeleteArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabBooking.
     * @param {LabBookingUpdateArgs} args - Arguments to update one LabBooking.
     * @example
     * // Update one LabBooking
     * const labBooking = await prisma.labBooking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabBookingUpdateArgs>(args: SelectSubset<T, LabBookingUpdateArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabBookings.
     * @param {LabBookingDeleteManyArgs} args - Arguments to filter LabBookings to delete.
     * @example
     * // Delete a few LabBookings
     * const { count } = await prisma.labBooking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabBookingDeleteManyArgs>(args?: SelectSubset<T, LabBookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabBookings
     * const labBooking = await prisma.labBooking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabBookingUpdateManyArgs>(args: SelectSubset<T, LabBookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabBooking.
     * @param {LabBookingUpsertArgs} args - Arguments to update or create a LabBooking.
     * @example
     * // Update or create a LabBooking
     * const labBooking = await prisma.labBooking.upsert({
     *   create: {
     *     // ... data to create a LabBooking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabBooking we want to update
     *   }
     * })
     */
    upsert<T extends LabBookingUpsertArgs>(args: SelectSubset<T, LabBookingUpsertArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabBookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingCountArgs} args - Arguments to filter LabBookings to count.
     * @example
     * // Count the number of LabBookings
     * const count = await prisma.labBooking.count({
     *   where: {
     *     // ... the filter for the LabBookings we want to count
     *   }
     * })
    **/
    count<T extends LabBookingCountArgs>(
      args?: Subset<T, LabBookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabBookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabBookingAggregateArgs>(args: Subset<T, LabBookingAggregateArgs>): Prisma.PrismaPromise<GetLabBookingAggregateType<T>>

    /**
     * Group by LabBooking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabBookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabBookingGroupByArgs['orderBy'] }
        : { orderBy?: LabBookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabBookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabBooking model
   */
  readonly fields: LabBookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabBooking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabBookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    tests<T extends LabBooking$testsArgs<ExtArgs> = {}>(args?: Subset<T, LabBooking$testsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findMany"> | Null>
    report<T extends LabBooking$reportArgs<ExtArgs> = {}>(args?: Subset<T, LabBooking$reportArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabBooking model
   */ 
  interface LabBookingFieldRefs {
    readonly id: FieldRef<"LabBooking", 'Int'>
    readonly uuid: FieldRef<"LabBooking", 'String'>
    readonly userId: FieldRef<"LabBooking", 'Int'>
    readonly bookingDate: FieldRef<"LabBooking", 'DateTime'>
    readonly collectionType: FieldRef<"LabBooking", 'String'>
    readonly address: FieldRef<"LabBooking", 'String'>
    readonly status: FieldRef<"LabBooking", 'String'>
    readonly totalAmount: FieldRef<"LabBooking", 'Float'>
    readonly paymentStatus: FieldRef<"LabBooking", 'String'>
    readonly reportUrl: FieldRef<"LabBooking", 'String'>
    readonly reportReadyDate: FieldRef<"LabBooking", 'DateTime'>
    readonly createdAt: FieldRef<"LabBooking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabBooking findUnique
   */
  export type LabBookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter, which LabBooking to fetch.
     */
    where: LabBookingWhereUniqueInput
  }

  /**
   * LabBooking findUniqueOrThrow
   */
  export type LabBookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter, which LabBooking to fetch.
     */
    where: LabBookingWhereUniqueInput
  }

  /**
   * LabBooking findFirst
   */
  export type LabBookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter, which LabBooking to fetch.
     */
    where?: LabBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookings to fetch.
     */
    orderBy?: LabBookingOrderByWithRelationInput | LabBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabBookings.
     */
    cursor?: LabBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabBookings.
     */
    distinct?: LabBookingScalarFieldEnum | LabBookingScalarFieldEnum[]
  }

  /**
   * LabBooking findFirstOrThrow
   */
  export type LabBookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter, which LabBooking to fetch.
     */
    where?: LabBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookings to fetch.
     */
    orderBy?: LabBookingOrderByWithRelationInput | LabBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabBookings.
     */
    cursor?: LabBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabBookings.
     */
    distinct?: LabBookingScalarFieldEnum | LabBookingScalarFieldEnum[]
  }

  /**
   * LabBooking findMany
   */
  export type LabBookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter, which LabBookings to fetch.
     */
    where?: LabBookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookings to fetch.
     */
    orderBy?: LabBookingOrderByWithRelationInput | LabBookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabBookings.
     */
    cursor?: LabBookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookings.
     */
    skip?: number
    distinct?: LabBookingScalarFieldEnum | LabBookingScalarFieldEnum[]
  }

  /**
   * LabBooking create
   */
  export type LabBookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * The data needed to create a LabBooking.
     */
    data: XOR<LabBookingCreateInput, LabBookingUncheckedCreateInput>
  }

  /**
   * LabBooking createMany
   */
  export type LabBookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabBookings.
     */
    data: LabBookingCreateManyInput | LabBookingCreateManyInput[]
  }

  /**
   * LabBooking createManyAndReturn
   */
  export type LabBookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabBookings.
     */
    data: LabBookingCreateManyInput | LabBookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabBooking update
   */
  export type LabBookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * The data needed to update a LabBooking.
     */
    data: XOR<LabBookingUpdateInput, LabBookingUncheckedUpdateInput>
    /**
     * Choose, which LabBooking to update.
     */
    where: LabBookingWhereUniqueInput
  }

  /**
   * LabBooking updateMany
   */
  export type LabBookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabBookings.
     */
    data: XOR<LabBookingUpdateManyMutationInput, LabBookingUncheckedUpdateManyInput>
    /**
     * Filter which LabBookings to update
     */
    where?: LabBookingWhereInput
  }

  /**
   * LabBooking upsert
   */
  export type LabBookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * The filter to search for the LabBooking to update in case it exists.
     */
    where: LabBookingWhereUniqueInput
    /**
     * In case the LabBooking found by the `where` argument doesn't exist, create a new LabBooking with this data.
     */
    create: XOR<LabBookingCreateInput, LabBookingUncheckedCreateInput>
    /**
     * In case the LabBooking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabBookingUpdateInput, LabBookingUncheckedUpdateInput>
  }

  /**
   * LabBooking delete
   */
  export type LabBookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
    /**
     * Filter which LabBooking to delete.
     */
    where: LabBookingWhereUniqueInput
  }

  /**
   * LabBooking deleteMany
   */
  export type LabBookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabBookings to delete
     */
    where?: LabBookingWhereInput
  }

  /**
   * LabBooking.tests
   */
  export type LabBooking$testsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    where?: LabBookingTestWhereInput
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    cursor?: LabBookingTestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabBookingTestScalarFieldEnum | LabBookingTestScalarFieldEnum[]
  }

  /**
   * LabBooking.report
   */
  export type LabBooking$reportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    where?: LabReportWhereInput
  }

  /**
   * LabBooking without action
   */
  export type LabBookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBooking
     */
    select?: LabBookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingInclude<ExtArgs> | null
  }


  /**
   * Model LabBookingTest
   */

  export type AggregateLabBookingTest = {
    _count: LabBookingTestCountAggregateOutputType | null
    _avg: LabBookingTestAvgAggregateOutputType | null
    _sum: LabBookingTestSumAggregateOutputType | null
    _min: LabBookingTestMinAggregateOutputType | null
    _max: LabBookingTestMaxAggregateOutputType | null
  }

  export type LabBookingTestAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    testId: number | null
  }

  export type LabBookingTestSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    testId: number | null
  }

  export type LabBookingTestMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    testId: number | null
  }

  export type LabBookingTestMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    testId: number | null
  }

  export type LabBookingTestCountAggregateOutputType = {
    id: number
    bookingId: number
    testId: number
    _all: number
  }


  export type LabBookingTestAvgAggregateInputType = {
    id?: true
    bookingId?: true
    testId?: true
  }

  export type LabBookingTestSumAggregateInputType = {
    id?: true
    bookingId?: true
    testId?: true
  }

  export type LabBookingTestMinAggregateInputType = {
    id?: true
    bookingId?: true
    testId?: true
  }

  export type LabBookingTestMaxAggregateInputType = {
    id?: true
    bookingId?: true
    testId?: true
  }

  export type LabBookingTestCountAggregateInputType = {
    id?: true
    bookingId?: true
    testId?: true
    _all?: true
  }

  export type LabBookingTestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabBookingTest to aggregate.
     */
    where?: LabBookingTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookingTests to fetch.
     */
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabBookingTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookingTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookingTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabBookingTests
    **/
    _count?: true | LabBookingTestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabBookingTestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabBookingTestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabBookingTestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabBookingTestMaxAggregateInputType
  }

  export type GetLabBookingTestAggregateType<T extends LabBookingTestAggregateArgs> = {
        [P in keyof T & keyof AggregateLabBookingTest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabBookingTest[P]>
      : GetScalarType<T[P], AggregateLabBookingTest[P]>
  }




  export type LabBookingTestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabBookingTestWhereInput
    orderBy?: LabBookingTestOrderByWithAggregationInput | LabBookingTestOrderByWithAggregationInput[]
    by: LabBookingTestScalarFieldEnum[] | LabBookingTestScalarFieldEnum
    having?: LabBookingTestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabBookingTestCountAggregateInputType | true
    _avg?: LabBookingTestAvgAggregateInputType
    _sum?: LabBookingTestSumAggregateInputType
    _min?: LabBookingTestMinAggregateInputType
    _max?: LabBookingTestMaxAggregateInputType
  }

  export type LabBookingTestGroupByOutputType = {
    id: number
    bookingId: number
    testId: number
    _count: LabBookingTestCountAggregateOutputType | null
    _avg: LabBookingTestAvgAggregateOutputType | null
    _sum: LabBookingTestSumAggregateOutputType | null
    _min: LabBookingTestMinAggregateOutputType | null
    _max: LabBookingTestMaxAggregateOutputType | null
  }

  type GetLabBookingTestGroupByPayload<T extends LabBookingTestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabBookingTestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabBookingTestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabBookingTestGroupByOutputType[P]>
            : GetScalarType<T[P], LabBookingTestGroupByOutputType[P]>
        }
      >
    >


  export type LabBookingTestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    testId?: boolean
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labBookingTest"]>

  export type LabBookingTestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    testId?: boolean
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labBookingTest"]>

  export type LabBookingTestSelectScalar = {
    id?: boolean
    bookingId?: boolean
    testId?: boolean
  }

  export type LabBookingTestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
  }
  export type LabBookingTestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
    test?: boolean | LabTestDefaultArgs<ExtArgs>
  }

  export type $LabBookingTestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabBookingTest"
    objects: {
      booking: Prisma.$LabBookingPayload<ExtArgs>
      test: Prisma.$LabTestPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      testId: number
    }, ExtArgs["result"]["labBookingTest"]>
    composites: {}
  }

  type LabBookingTestGetPayload<S extends boolean | null | undefined | LabBookingTestDefaultArgs> = $Result.GetResult<Prisma.$LabBookingTestPayload, S>

  type LabBookingTestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabBookingTestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabBookingTestCountAggregateInputType | true
    }

  export interface LabBookingTestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabBookingTest'], meta: { name: 'LabBookingTest' } }
    /**
     * Find zero or one LabBookingTest that matches the filter.
     * @param {LabBookingTestFindUniqueArgs} args - Arguments to find a LabBookingTest
     * @example
     * // Get one LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabBookingTestFindUniqueArgs>(args: SelectSubset<T, LabBookingTestFindUniqueArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabBookingTest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabBookingTestFindUniqueOrThrowArgs} args - Arguments to find a LabBookingTest
     * @example
     * // Get one LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabBookingTestFindUniqueOrThrowArgs>(args: SelectSubset<T, LabBookingTestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabBookingTest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestFindFirstArgs} args - Arguments to find a LabBookingTest
     * @example
     * // Get one LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabBookingTestFindFirstArgs>(args?: SelectSubset<T, LabBookingTestFindFirstArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabBookingTest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestFindFirstOrThrowArgs} args - Arguments to find a LabBookingTest
     * @example
     * // Get one LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabBookingTestFindFirstOrThrowArgs>(args?: SelectSubset<T, LabBookingTestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabBookingTests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabBookingTests
     * const labBookingTests = await prisma.labBookingTest.findMany()
     * 
     * // Get first 10 LabBookingTests
     * const labBookingTests = await prisma.labBookingTest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labBookingTestWithIdOnly = await prisma.labBookingTest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabBookingTestFindManyArgs>(args?: SelectSubset<T, LabBookingTestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabBookingTest.
     * @param {LabBookingTestCreateArgs} args - Arguments to create a LabBookingTest.
     * @example
     * // Create one LabBookingTest
     * const LabBookingTest = await prisma.labBookingTest.create({
     *   data: {
     *     // ... data to create a LabBookingTest
     *   }
     * })
     * 
     */
    create<T extends LabBookingTestCreateArgs>(args: SelectSubset<T, LabBookingTestCreateArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabBookingTests.
     * @param {LabBookingTestCreateManyArgs} args - Arguments to create many LabBookingTests.
     * @example
     * // Create many LabBookingTests
     * const labBookingTest = await prisma.labBookingTest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabBookingTestCreateManyArgs>(args?: SelectSubset<T, LabBookingTestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabBookingTests and returns the data saved in the database.
     * @param {LabBookingTestCreateManyAndReturnArgs} args - Arguments to create many LabBookingTests.
     * @example
     * // Create many LabBookingTests
     * const labBookingTest = await prisma.labBookingTest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabBookingTests and only return the `id`
     * const labBookingTestWithIdOnly = await prisma.labBookingTest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabBookingTestCreateManyAndReturnArgs>(args?: SelectSubset<T, LabBookingTestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabBookingTest.
     * @param {LabBookingTestDeleteArgs} args - Arguments to delete one LabBookingTest.
     * @example
     * // Delete one LabBookingTest
     * const LabBookingTest = await prisma.labBookingTest.delete({
     *   where: {
     *     // ... filter to delete one LabBookingTest
     *   }
     * })
     * 
     */
    delete<T extends LabBookingTestDeleteArgs>(args: SelectSubset<T, LabBookingTestDeleteArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabBookingTest.
     * @param {LabBookingTestUpdateArgs} args - Arguments to update one LabBookingTest.
     * @example
     * // Update one LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabBookingTestUpdateArgs>(args: SelectSubset<T, LabBookingTestUpdateArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabBookingTests.
     * @param {LabBookingTestDeleteManyArgs} args - Arguments to filter LabBookingTests to delete.
     * @example
     * // Delete a few LabBookingTests
     * const { count } = await prisma.labBookingTest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabBookingTestDeleteManyArgs>(args?: SelectSubset<T, LabBookingTestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabBookingTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabBookingTests
     * const labBookingTest = await prisma.labBookingTest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabBookingTestUpdateManyArgs>(args: SelectSubset<T, LabBookingTestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabBookingTest.
     * @param {LabBookingTestUpsertArgs} args - Arguments to update or create a LabBookingTest.
     * @example
     * // Update or create a LabBookingTest
     * const labBookingTest = await prisma.labBookingTest.upsert({
     *   create: {
     *     // ... data to create a LabBookingTest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabBookingTest we want to update
     *   }
     * })
     */
    upsert<T extends LabBookingTestUpsertArgs>(args: SelectSubset<T, LabBookingTestUpsertArgs<ExtArgs>>): Prisma__LabBookingTestClient<$Result.GetResult<Prisma.$LabBookingTestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabBookingTests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestCountArgs} args - Arguments to filter LabBookingTests to count.
     * @example
     * // Count the number of LabBookingTests
     * const count = await prisma.labBookingTest.count({
     *   where: {
     *     // ... the filter for the LabBookingTests we want to count
     *   }
     * })
    **/
    count<T extends LabBookingTestCountArgs>(
      args?: Subset<T, LabBookingTestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabBookingTestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabBookingTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabBookingTestAggregateArgs>(args: Subset<T, LabBookingTestAggregateArgs>): Prisma.PrismaPromise<GetLabBookingTestAggregateType<T>>

    /**
     * Group by LabBookingTest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabBookingTestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabBookingTestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabBookingTestGroupByArgs['orderBy'] }
        : { orderBy?: LabBookingTestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabBookingTestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabBookingTestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabBookingTest model
   */
  readonly fields: LabBookingTestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabBookingTest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabBookingTestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends LabBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabBookingDefaultArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    test<T extends LabTestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabTestDefaultArgs<ExtArgs>>): Prisma__LabTestClient<$Result.GetResult<Prisma.$LabTestPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabBookingTest model
   */ 
  interface LabBookingTestFieldRefs {
    readonly id: FieldRef<"LabBookingTest", 'Int'>
    readonly bookingId: FieldRef<"LabBookingTest", 'Int'>
    readonly testId: FieldRef<"LabBookingTest", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LabBookingTest findUnique
   */
  export type LabBookingTestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter, which LabBookingTest to fetch.
     */
    where: LabBookingTestWhereUniqueInput
  }

  /**
   * LabBookingTest findUniqueOrThrow
   */
  export type LabBookingTestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter, which LabBookingTest to fetch.
     */
    where: LabBookingTestWhereUniqueInput
  }

  /**
   * LabBookingTest findFirst
   */
  export type LabBookingTestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter, which LabBookingTest to fetch.
     */
    where?: LabBookingTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookingTests to fetch.
     */
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabBookingTests.
     */
    cursor?: LabBookingTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookingTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookingTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabBookingTests.
     */
    distinct?: LabBookingTestScalarFieldEnum | LabBookingTestScalarFieldEnum[]
  }

  /**
   * LabBookingTest findFirstOrThrow
   */
  export type LabBookingTestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter, which LabBookingTest to fetch.
     */
    where?: LabBookingTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookingTests to fetch.
     */
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabBookingTests.
     */
    cursor?: LabBookingTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookingTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookingTests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabBookingTests.
     */
    distinct?: LabBookingTestScalarFieldEnum | LabBookingTestScalarFieldEnum[]
  }

  /**
   * LabBookingTest findMany
   */
  export type LabBookingTestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter, which LabBookingTests to fetch.
     */
    where?: LabBookingTestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabBookingTests to fetch.
     */
    orderBy?: LabBookingTestOrderByWithRelationInput | LabBookingTestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabBookingTests.
     */
    cursor?: LabBookingTestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabBookingTests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabBookingTests.
     */
    skip?: number
    distinct?: LabBookingTestScalarFieldEnum | LabBookingTestScalarFieldEnum[]
  }

  /**
   * LabBookingTest create
   */
  export type LabBookingTestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * The data needed to create a LabBookingTest.
     */
    data: XOR<LabBookingTestCreateInput, LabBookingTestUncheckedCreateInput>
  }

  /**
   * LabBookingTest createMany
   */
  export type LabBookingTestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabBookingTests.
     */
    data: LabBookingTestCreateManyInput | LabBookingTestCreateManyInput[]
  }

  /**
   * LabBookingTest createManyAndReturn
   */
  export type LabBookingTestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabBookingTests.
     */
    data: LabBookingTestCreateManyInput | LabBookingTestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabBookingTest update
   */
  export type LabBookingTestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * The data needed to update a LabBookingTest.
     */
    data: XOR<LabBookingTestUpdateInput, LabBookingTestUncheckedUpdateInput>
    /**
     * Choose, which LabBookingTest to update.
     */
    where: LabBookingTestWhereUniqueInput
  }

  /**
   * LabBookingTest updateMany
   */
  export type LabBookingTestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabBookingTests.
     */
    data: XOR<LabBookingTestUpdateManyMutationInput, LabBookingTestUncheckedUpdateManyInput>
    /**
     * Filter which LabBookingTests to update
     */
    where?: LabBookingTestWhereInput
  }

  /**
   * LabBookingTest upsert
   */
  export type LabBookingTestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * The filter to search for the LabBookingTest to update in case it exists.
     */
    where: LabBookingTestWhereUniqueInput
    /**
     * In case the LabBookingTest found by the `where` argument doesn't exist, create a new LabBookingTest with this data.
     */
    create: XOR<LabBookingTestCreateInput, LabBookingTestUncheckedCreateInput>
    /**
     * In case the LabBookingTest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabBookingTestUpdateInput, LabBookingTestUncheckedUpdateInput>
  }

  /**
   * LabBookingTest delete
   */
  export type LabBookingTestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
    /**
     * Filter which LabBookingTest to delete.
     */
    where: LabBookingTestWhereUniqueInput
  }

  /**
   * LabBookingTest deleteMany
   */
  export type LabBookingTestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabBookingTests to delete
     */
    where?: LabBookingTestWhereInput
  }

  /**
   * LabBookingTest without action
   */
  export type LabBookingTestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabBookingTest
     */
    select?: LabBookingTestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabBookingTestInclude<ExtArgs> | null
  }


  /**
   * Model LabReport
   */

  export type AggregateLabReport = {
    _count: LabReportCountAggregateOutputType | null
    _avg: LabReportAvgAggregateOutputType | null
    _sum: LabReportSumAggregateOutputType | null
    _min: LabReportMinAggregateOutputType | null
    _max: LabReportMaxAggregateOutputType | null
  }

  export type LabReportAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    reviewedById: number | null
  }

  export type LabReportSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    reviewedById: number | null
  }

  export type LabReportMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    bookingId: number | null
    reportUrl: string | null
    results: string | null
    status: string | null
    reviewedById: number | null
    interpretation: string | null
    recommendations: string | null
    readyAt: Date | null
    createdAt: Date | null
  }

  export type LabReportMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    bookingId: number | null
    reportUrl: string | null
    results: string | null
    status: string | null
    reviewedById: number | null
    interpretation: string | null
    recommendations: string | null
    readyAt: Date | null
    createdAt: Date | null
  }

  export type LabReportCountAggregateOutputType = {
    id: number
    uuid: number
    bookingId: number
    reportUrl: number
    results: number
    status: number
    reviewedById: number
    interpretation: number
    recommendations: number
    readyAt: number
    createdAt: number
    _all: number
  }


  export type LabReportAvgAggregateInputType = {
    id?: true
    bookingId?: true
    reviewedById?: true
  }

  export type LabReportSumAggregateInputType = {
    id?: true
    bookingId?: true
    reviewedById?: true
  }

  export type LabReportMinAggregateInputType = {
    id?: true
    uuid?: true
    bookingId?: true
    reportUrl?: true
    results?: true
    status?: true
    reviewedById?: true
    interpretation?: true
    recommendations?: true
    readyAt?: true
    createdAt?: true
  }

  export type LabReportMaxAggregateInputType = {
    id?: true
    uuid?: true
    bookingId?: true
    reportUrl?: true
    results?: true
    status?: true
    reviewedById?: true
    interpretation?: true
    recommendations?: true
    readyAt?: true
    createdAt?: true
  }

  export type LabReportCountAggregateInputType = {
    id?: true
    uuid?: true
    bookingId?: true
    reportUrl?: true
    results?: true
    status?: true
    reviewedById?: true
    interpretation?: true
    recommendations?: true
    readyAt?: true
    createdAt?: true
    _all?: true
  }

  export type LabReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabReport to aggregate.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabReports
    **/
    _count?: true | LabReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabReportMaxAggregateInputType
  }

  export type GetLabReportAggregateType<T extends LabReportAggregateArgs> = {
        [P in keyof T & keyof AggregateLabReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabReport[P]>
      : GetScalarType<T[P], AggregateLabReport[P]>
  }




  export type LabReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabReportWhereInput
    orderBy?: LabReportOrderByWithAggregationInput | LabReportOrderByWithAggregationInput[]
    by: LabReportScalarFieldEnum[] | LabReportScalarFieldEnum
    having?: LabReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabReportCountAggregateInputType | true
    _avg?: LabReportAvgAggregateInputType
    _sum?: LabReportSumAggregateInputType
    _min?: LabReportMinAggregateInputType
    _max?: LabReportMaxAggregateInputType
  }

  export type LabReportGroupByOutputType = {
    id: number
    uuid: string
    bookingId: number
    reportUrl: string
    results: string | null
    status: string
    reviewedById: number | null
    interpretation: string | null
    recommendations: string | null
    readyAt: Date | null
    createdAt: Date
    _count: LabReportCountAggregateOutputType | null
    _avg: LabReportAvgAggregateOutputType | null
    _sum: LabReportSumAggregateOutputType | null
    _min: LabReportMinAggregateOutputType | null
    _max: LabReportMaxAggregateOutputType | null
  }

  type GetLabReportGroupByPayload<T extends LabReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabReportGroupByOutputType[P]>
            : GetScalarType<T[P], LabReportGroupByOutputType[P]>
        }
      >
    >


  export type LabReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    bookingId?: boolean
    reportUrl?: boolean
    results?: boolean
    status?: boolean
    reviewedById?: boolean
    interpretation?: boolean
    recommendations?: boolean
    readyAt?: boolean
    createdAt?: boolean
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labReport"]>

  export type LabReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    bookingId?: boolean
    reportUrl?: boolean
    results?: boolean
    status?: boolean
    reviewedById?: boolean
    interpretation?: boolean
    recommendations?: boolean
    readyAt?: boolean
    createdAt?: boolean
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labReport"]>

  export type LabReportSelectScalar = {
    id?: boolean
    uuid?: boolean
    bookingId?: boolean
    reportUrl?: boolean
    results?: boolean
    status?: boolean
    reviewedById?: boolean
    interpretation?: boolean
    recommendations?: boolean
    readyAt?: boolean
    createdAt?: boolean
  }

  export type LabReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
  }
  export type LabReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | LabBookingDefaultArgs<ExtArgs>
  }

  export type $LabReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabReport"
    objects: {
      booking: Prisma.$LabBookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      bookingId: number
      reportUrl: string
      results: string | null
      status: string
      reviewedById: number | null
      interpretation: string | null
      recommendations: string | null
      readyAt: Date | null
      createdAt: Date
    }, ExtArgs["result"]["labReport"]>
    composites: {}
  }

  type LabReportGetPayload<S extends boolean | null | undefined | LabReportDefaultArgs> = $Result.GetResult<Prisma.$LabReportPayload, S>

  type LabReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LabReportFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LabReportCountAggregateInputType | true
    }

  export interface LabReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabReport'], meta: { name: 'LabReport' } }
    /**
     * Find zero or one LabReport that matches the filter.
     * @param {LabReportFindUniqueArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabReportFindUniqueArgs>(args: SelectSubset<T, LabReportFindUniqueArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LabReport that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LabReportFindUniqueOrThrowArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabReportFindUniqueOrThrowArgs>(args: SelectSubset<T, LabReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LabReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindFirstArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabReportFindFirstArgs>(args?: SelectSubset<T, LabReportFindFirstArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LabReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindFirstOrThrowArgs} args - Arguments to find a LabReport
     * @example
     * // Get one LabReport
     * const labReport = await prisma.labReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabReportFindFirstOrThrowArgs>(args?: SelectSubset<T, LabReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LabReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabReports
     * const labReports = await prisma.labReport.findMany()
     * 
     * // Get first 10 LabReports
     * const labReports = await prisma.labReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labReportWithIdOnly = await prisma.labReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabReportFindManyArgs>(args?: SelectSubset<T, LabReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LabReport.
     * @param {LabReportCreateArgs} args - Arguments to create a LabReport.
     * @example
     * // Create one LabReport
     * const LabReport = await prisma.labReport.create({
     *   data: {
     *     // ... data to create a LabReport
     *   }
     * })
     * 
     */
    create<T extends LabReportCreateArgs>(args: SelectSubset<T, LabReportCreateArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LabReports.
     * @param {LabReportCreateManyArgs} args - Arguments to create many LabReports.
     * @example
     * // Create many LabReports
     * const labReport = await prisma.labReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabReportCreateManyArgs>(args?: SelectSubset<T, LabReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabReports and returns the data saved in the database.
     * @param {LabReportCreateManyAndReturnArgs} args - Arguments to create many LabReports.
     * @example
     * // Create many LabReports
     * const labReport = await prisma.labReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabReports and only return the `id`
     * const labReportWithIdOnly = await prisma.labReport.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabReportCreateManyAndReturnArgs>(args?: SelectSubset<T, LabReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LabReport.
     * @param {LabReportDeleteArgs} args - Arguments to delete one LabReport.
     * @example
     * // Delete one LabReport
     * const LabReport = await prisma.labReport.delete({
     *   where: {
     *     // ... filter to delete one LabReport
     *   }
     * })
     * 
     */
    delete<T extends LabReportDeleteArgs>(args: SelectSubset<T, LabReportDeleteArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LabReport.
     * @param {LabReportUpdateArgs} args - Arguments to update one LabReport.
     * @example
     * // Update one LabReport
     * const labReport = await prisma.labReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabReportUpdateArgs>(args: SelectSubset<T, LabReportUpdateArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LabReports.
     * @param {LabReportDeleteManyArgs} args - Arguments to filter LabReports to delete.
     * @example
     * // Delete a few LabReports
     * const { count } = await prisma.labReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabReportDeleteManyArgs>(args?: SelectSubset<T, LabReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabReports
     * const labReport = await prisma.labReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabReportUpdateManyArgs>(args: SelectSubset<T, LabReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LabReport.
     * @param {LabReportUpsertArgs} args - Arguments to update or create a LabReport.
     * @example
     * // Update or create a LabReport
     * const labReport = await prisma.labReport.upsert({
     *   create: {
     *     // ... data to create a LabReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabReport we want to update
     *   }
     * })
     */
    upsert<T extends LabReportUpsertArgs>(args: SelectSubset<T, LabReportUpsertArgs<ExtArgs>>): Prisma__LabReportClient<$Result.GetResult<Prisma.$LabReportPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LabReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportCountArgs} args - Arguments to filter LabReports to count.
     * @example
     * // Count the number of LabReports
     * const count = await prisma.labReport.count({
     *   where: {
     *     // ... the filter for the LabReports we want to count
     *   }
     * })
    **/
    count<T extends LabReportCountArgs>(
      args?: Subset<T, LabReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabReportAggregateArgs>(args: Subset<T, LabReportAggregateArgs>): Prisma.PrismaPromise<GetLabReportAggregateType<T>>

    /**
     * Group by LabReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabReportGroupByArgs['orderBy'] }
        : { orderBy?: LabReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabReport model
   */
  readonly fields: LabReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends LabBookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LabBookingDefaultArgs<ExtArgs>>): Prisma__LabBookingClient<$Result.GetResult<Prisma.$LabBookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabReport model
   */ 
  interface LabReportFieldRefs {
    readonly id: FieldRef<"LabReport", 'Int'>
    readonly uuid: FieldRef<"LabReport", 'String'>
    readonly bookingId: FieldRef<"LabReport", 'Int'>
    readonly reportUrl: FieldRef<"LabReport", 'String'>
    readonly results: FieldRef<"LabReport", 'String'>
    readonly status: FieldRef<"LabReport", 'String'>
    readonly reviewedById: FieldRef<"LabReport", 'Int'>
    readonly interpretation: FieldRef<"LabReport", 'String'>
    readonly recommendations: FieldRef<"LabReport", 'String'>
    readonly readyAt: FieldRef<"LabReport", 'DateTime'>
    readonly createdAt: FieldRef<"LabReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabReport findUnique
   */
  export type LabReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport findUniqueOrThrow
   */
  export type LabReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport findFirst
   */
  export type LabReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabReports.
     */
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport findFirstOrThrow
   */
  export type LabReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReport to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabReports.
     */
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport findMany
   */
  export type LabReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter, which LabReports to fetch.
     */
    where?: LabReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabReports to fetch.
     */
    orderBy?: LabReportOrderByWithRelationInput | LabReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabReports.
     */
    cursor?: LabReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabReports.
     */
    skip?: number
    distinct?: LabReportScalarFieldEnum | LabReportScalarFieldEnum[]
  }

  /**
   * LabReport create
   */
  export type LabReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The data needed to create a LabReport.
     */
    data: XOR<LabReportCreateInput, LabReportUncheckedCreateInput>
  }

  /**
   * LabReport createMany
   */
  export type LabReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabReports.
     */
    data: LabReportCreateManyInput | LabReportCreateManyInput[]
  }

  /**
   * LabReport createManyAndReturn
   */
  export type LabReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LabReports.
     */
    data: LabReportCreateManyInput | LabReportCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabReport update
   */
  export type LabReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The data needed to update a LabReport.
     */
    data: XOR<LabReportUpdateInput, LabReportUncheckedUpdateInput>
    /**
     * Choose, which LabReport to update.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport updateMany
   */
  export type LabReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabReports.
     */
    data: XOR<LabReportUpdateManyMutationInput, LabReportUncheckedUpdateManyInput>
    /**
     * Filter which LabReports to update
     */
    where?: LabReportWhereInput
  }

  /**
   * LabReport upsert
   */
  export type LabReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * The filter to search for the LabReport to update in case it exists.
     */
    where: LabReportWhereUniqueInput
    /**
     * In case the LabReport found by the `where` argument doesn't exist, create a new LabReport with this data.
     */
    create: XOR<LabReportCreateInput, LabReportUncheckedCreateInput>
    /**
     * In case the LabReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabReportUpdateInput, LabReportUncheckedUpdateInput>
  }

  /**
   * LabReport delete
   */
  export type LabReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
    /**
     * Filter which LabReport to delete.
     */
    where: LabReportWhereUniqueInput
  }

  /**
   * LabReport deleteMany
   */
  export type LabReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabReports to delete
     */
    where?: LabReportWhereInput
  }

  /**
   * LabReport without action
   */
  export type LabReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabReport
     */
    select?: LabReportSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabReportInclude<ExtArgs> | null
  }


  /**
   * Model HealthRecord
   */

  export type AggregateHealthRecord = {
    _count: HealthRecordCountAggregateOutputType | null
    _avg: HealthRecordAvgAggregateOutputType | null
    _sum: HealthRecordSumAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  export type HealthRecordAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    fileSize: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type HealthRecordSumAggregateOutputType = {
    id: number | null
    userId: number | null
    fileSize: number | null
    doctorId: number | null
    appointmentId: number | null
  }

  export type HealthRecordMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    recordType: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    doctorId: number | null
    appointmentId: number | null
    documentDate: Date | null
    isPublic: boolean | null
    sharedWith: string | null
    createdAt: Date | null
  }

  export type HealthRecordMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    recordType: string | null
    title: string | null
    description: string | null
    fileUrl: string | null
    fileName: string | null
    fileType: string | null
    fileSize: number | null
    doctorId: number | null
    appointmentId: number | null
    documentDate: Date | null
    isPublic: boolean | null
    sharedWith: string | null
    createdAt: Date | null
  }

  export type HealthRecordCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    recordType: number
    title: number
    description: number
    fileUrl: number
    fileName: number
    fileType: number
    fileSize: number
    doctorId: number
    appointmentId: number
    documentDate: number
    isPublic: number
    sharedWith: number
    createdAt: number
    _all: number
  }


  export type HealthRecordAvgAggregateInputType = {
    id?: true
    userId?: true
    fileSize?: true
    doctorId?: true
    appointmentId?: true
  }

  export type HealthRecordSumAggregateInputType = {
    id?: true
    userId?: true
    fileSize?: true
    doctorId?: true
    appointmentId?: true
  }

  export type HealthRecordMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    recordType?: true
    title?: true
    description?: true
    fileUrl?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    doctorId?: true
    appointmentId?: true
    documentDate?: true
    isPublic?: true
    sharedWith?: true
    createdAt?: true
  }

  export type HealthRecordMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    recordType?: true
    title?: true
    description?: true
    fileUrl?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    doctorId?: true
    appointmentId?: true
    documentDate?: true
    isPublic?: true
    sharedWith?: true
    createdAt?: true
  }

  export type HealthRecordCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    recordType?: true
    title?: true
    description?: true
    fileUrl?: true
    fileName?: true
    fileType?: true
    fileSize?: true
    doctorId?: true
    appointmentId?: true
    documentDate?: true
    isPublic?: true
    sharedWith?: true
    createdAt?: true
    _all?: true
  }

  export type HealthRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecord to aggregate.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthRecords
    **/
    _count?: true | HealthRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthRecordMaxAggregateInputType
  }

  export type GetHealthRecordAggregateType<T extends HealthRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthRecord[P]>
      : GetScalarType<T[P], AggregateHealthRecord[P]>
  }




  export type HealthRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthRecordWhereInput
    orderBy?: HealthRecordOrderByWithAggregationInput | HealthRecordOrderByWithAggregationInput[]
    by: HealthRecordScalarFieldEnum[] | HealthRecordScalarFieldEnum
    having?: HealthRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthRecordCountAggregateInputType | true
    _avg?: HealthRecordAvgAggregateInputType
    _sum?: HealthRecordSumAggregateInputType
    _min?: HealthRecordMinAggregateInputType
    _max?: HealthRecordMaxAggregateInputType
  }

  export type HealthRecordGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    recordType: string
    title: string
    description: string | null
    fileUrl: string
    fileName: string
    fileType: string | null
    fileSize: number | null
    doctorId: number | null
    appointmentId: number | null
    documentDate: Date | null
    isPublic: boolean
    sharedWith: string | null
    createdAt: Date
    _count: HealthRecordCountAggregateOutputType | null
    _avg: HealthRecordAvgAggregateOutputType | null
    _sum: HealthRecordSumAggregateOutputType | null
    _min: HealthRecordMinAggregateOutputType | null
    _max: HealthRecordMaxAggregateOutputType | null
  }

  type GetHealthRecordGroupByPayload<T extends HealthRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
            : GetScalarType<T[P], HealthRecordGroupByOutputType[P]>
        }
      >
    >


  export type HealthRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    documentDate?: boolean
    isPublic?: boolean
    sharedWith?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    documentDate?: boolean
    isPublic?: boolean
    sharedWith?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthRecord"]>

  export type HealthRecordSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    recordType?: boolean
    title?: boolean
    description?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileType?: boolean
    fileSize?: boolean
    doctorId?: boolean
    appointmentId?: boolean
    documentDate?: boolean
    isPublic?: boolean
    sharedWith?: boolean
    createdAt?: boolean
  }

  export type HealthRecordInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type HealthRecordIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $HealthRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthRecord"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      recordType: string
      title: string
      description: string | null
      fileUrl: string
      fileName: string
      fileType: string | null
      fileSize: number | null
      doctorId: number | null
      appointmentId: number | null
      documentDate: Date | null
      isPublic: boolean
      sharedWith: string | null
      createdAt: Date
    }, ExtArgs["result"]["healthRecord"]>
    composites: {}
  }

  type HealthRecordGetPayload<S extends boolean | null | undefined | HealthRecordDefaultArgs> = $Result.GetResult<Prisma.$HealthRecordPayload, S>

  type HealthRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthRecordFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthRecordCountAggregateInputType | true
    }

  export interface HealthRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthRecord'], meta: { name: 'HealthRecord' } }
    /**
     * Find zero or one HealthRecord that matches the filter.
     * @param {HealthRecordFindUniqueArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthRecordFindUniqueArgs>(args: SelectSubset<T, HealthRecordFindUniqueArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthRecord that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthRecordFindUniqueOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthRecordFindFirstArgs>(args?: SelectSubset<T, HealthRecordFindFirstArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindFirstOrThrowArgs} args - Arguments to find a HealthRecord
     * @example
     * // Get one HealthRecord
     * const healthRecord = await prisma.healthRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany()
     * 
     * // Get first 10 HealthRecords
     * const healthRecords = await prisma.healthRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthRecordFindManyArgs>(args?: SelectSubset<T, HealthRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthRecord.
     * @param {HealthRecordCreateArgs} args - Arguments to create a HealthRecord.
     * @example
     * // Create one HealthRecord
     * const HealthRecord = await prisma.healthRecord.create({
     *   data: {
     *     // ... data to create a HealthRecord
     *   }
     * })
     * 
     */
    create<T extends HealthRecordCreateArgs>(args: SelectSubset<T, HealthRecordCreateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthRecords.
     * @param {HealthRecordCreateManyArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthRecordCreateManyArgs>(args?: SelectSubset<T, HealthRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthRecords and returns the data saved in the database.
     * @param {HealthRecordCreateManyAndReturnArgs} args - Arguments to create many HealthRecords.
     * @example
     * // Create many HealthRecords
     * const healthRecord = await prisma.healthRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthRecords and only return the `id`
     * const healthRecordWithIdOnly = await prisma.healthRecord.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthRecord.
     * @param {HealthRecordDeleteArgs} args - Arguments to delete one HealthRecord.
     * @example
     * // Delete one HealthRecord
     * const HealthRecord = await prisma.healthRecord.delete({
     *   where: {
     *     // ... filter to delete one HealthRecord
     *   }
     * })
     * 
     */
    delete<T extends HealthRecordDeleteArgs>(args: SelectSubset<T, HealthRecordDeleteArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthRecord.
     * @param {HealthRecordUpdateArgs} args - Arguments to update one HealthRecord.
     * @example
     * // Update one HealthRecord
     * const healthRecord = await prisma.healthRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthRecordUpdateArgs>(args: SelectSubset<T, HealthRecordUpdateArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthRecords.
     * @param {HealthRecordDeleteManyArgs} args - Arguments to filter HealthRecords to delete.
     * @example
     * // Delete a few HealthRecords
     * const { count } = await prisma.healthRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthRecordDeleteManyArgs>(args?: SelectSubset<T, HealthRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthRecords
     * const healthRecord = await prisma.healthRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthRecordUpdateManyArgs>(args: SelectSubset<T, HealthRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthRecord.
     * @param {HealthRecordUpsertArgs} args - Arguments to update or create a HealthRecord.
     * @example
     * // Update or create a HealthRecord
     * const healthRecord = await prisma.healthRecord.upsert({
     *   create: {
     *     // ... data to create a HealthRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthRecord we want to update
     *   }
     * })
     */
    upsert<T extends HealthRecordUpsertArgs>(args: SelectSubset<T, HealthRecordUpsertArgs<ExtArgs>>): Prisma__HealthRecordClient<$Result.GetResult<Prisma.$HealthRecordPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordCountArgs} args - Arguments to filter HealthRecords to count.
     * @example
     * // Count the number of HealthRecords
     * const count = await prisma.healthRecord.count({
     *   where: {
     *     // ... the filter for the HealthRecords we want to count
     *   }
     * })
    **/
    count<T extends HealthRecordCountArgs>(
      args?: Subset<T, HealthRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthRecordAggregateArgs>(args: Subset<T, HealthRecordAggregateArgs>): Prisma.PrismaPromise<GetHealthRecordAggregateType<T>>

    /**
     * Group by HealthRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthRecordGroupByArgs['orderBy'] }
        : { orderBy?: HealthRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthRecord model
   */
  readonly fields: HealthRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthRecord model
   */ 
  interface HealthRecordFieldRefs {
    readonly id: FieldRef<"HealthRecord", 'Int'>
    readonly uuid: FieldRef<"HealthRecord", 'String'>
    readonly userId: FieldRef<"HealthRecord", 'Int'>
    readonly recordType: FieldRef<"HealthRecord", 'String'>
    readonly title: FieldRef<"HealthRecord", 'String'>
    readonly description: FieldRef<"HealthRecord", 'String'>
    readonly fileUrl: FieldRef<"HealthRecord", 'String'>
    readonly fileName: FieldRef<"HealthRecord", 'String'>
    readonly fileType: FieldRef<"HealthRecord", 'String'>
    readonly fileSize: FieldRef<"HealthRecord", 'Int'>
    readonly doctorId: FieldRef<"HealthRecord", 'Int'>
    readonly appointmentId: FieldRef<"HealthRecord", 'Int'>
    readonly documentDate: FieldRef<"HealthRecord", 'DateTime'>
    readonly isPublic: FieldRef<"HealthRecord", 'Boolean'>
    readonly sharedWith: FieldRef<"HealthRecord", 'String'>
    readonly createdAt: FieldRef<"HealthRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthRecord findUnique
   */
  export type HealthRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findUniqueOrThrow
   */
  export type HealthRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord findFirst
   */
  export type HealthRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findFirstOrThrow
   */
  export type HealthRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecord to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthRecords.
     */
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord findMany
   */
  export type HealthRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter, which HealthRecords to fetch.
     */
    where?: HealthRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthRecords to fetch.
     */
    orderBy?: HealthRecordOrderByWithRelationInput | HealthRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthRecords.
     */
    cursor?: HealthRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthRecords.
     */
    skip?: number
    distinct?: HealthRecordScalarFieldEnum | HealthRecordScalarFieldEnum[]
  }

  /**
   * HealthRecord create
   */
  export type HealthRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthRecord.
     */
    data: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
  }

  /**
   * HealthRecord createMany
   */
  export type HealthRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
  }

  /**
   * HealthRecord createManyAndReturn
   */
  export type HealthRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthRecords.
     */
    data: HealthRecordCreateManyInput | HealthRecordCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthRecord update
   */
  export type HealthRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthRecord.
     */
    data: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
    /**
     * Choose, which HealthRecord to update.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord updateMany
   */
  export type HealthRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthRecords.
     */
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyInput>
    /**
     * Filter which HealthRecords to update
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord upsert
   */
  export type HealthRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthRecord to update in case it exists.
     */
    where: HealthRecordWhereUniqueInput
    /**
     * In case the HealthRecord found by the `where` argument doesn't exist, create a new HealthRecord with this data.
     */
    create: XOR<HealthRecordCreateInput, HealthRecordUncheckedCreateInput>
    /**
     * In case the HealthRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthRecordUpdateInput, HealthRecordUncheckedUpdateInput>
  }

  /**
   * HealthRecord delete
   */
  export type HealthRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
    /**
     * Filter which HealthRecord to delete.
     */
    where: HealthRecordWhereUniqueInput
  }

  /**
   * HealthRecord deleteMany
   */
  export type HealthRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthRecords to delete
     */
    where?: HealthRecordWhereInput
  }

  /**
   * HealthRecord without action
   */
  export type HealthRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthRecord
     */
    select?: HealthRecordSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthRecordInclude<ExtArgs> | null
  }


  /**
   * Model ForumPost
   */

  export type AggregateForumPost = {
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  export type ForumPostAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    upvotes: number | null
    downvotes: number | null
    views: number | null
    commentsCount: number | null
  }

  export type ForumPostSumAggregateOutputType = {
    id: number | null
    userId: number | null
    upvotes: number | null
    downvotes: number | null
    views: number | null
    commentsCount: number | null
  }

  export type ForumPostMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    title: string | null
    content: string | null
    category: string | null
    status: string | null
    upvotes: number | null
    downvotes: number | null
    views: number | null
    commentsCount: number | null
    pinned: boolean | null
    verifiedDoctor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    title: string | null
    content: string | null
    category: string | null
    status: string | null
    upvotes: number | null
    downvotes: number | null
    views: number | null
    commentsCount: number | null
    pinned: boolean | null
    verifiedDoctor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumPostCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    title: number
    content: number
    category: number
    status: number
    upvotes: number
    downvotes: number
    views: number
    commentsCount: number
    pinned: number
    verifiedDoctor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumPostAvgAggregateInputType = {
    id?: true
    userId?: true
    upvotes?: true
    downvotes?: true
    views?: true
    commentsCount?: true
  }

  export type ForumPostSumAggregateInputType = {
    id?: true
    userId?: true
    upvotes?: true
    downvotes?: true
    views?: true
    commentsCount?: true
  }

  export type ForumPostMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    status?: true
    upvotes?: true
    downvotes?: true
    views?: true
    commentsCount?: true
    pinned?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    status?: true
    upvotes?: true
    downvotes?: true
    views?: true
    commentsCount?: true
    pinned?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumPostCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    title?: true
    content?: true
    category?: true
    status?: true
    upvotes?: true
    downvotes?: true
    views?: true
    commentsCount?: true
    pinned?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumPostAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPost to aggregate.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumPosts
    **/
    _count?: true | ForumPostCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumPostAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumPostSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumPostMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumPostMaxAggregateInputType
  }

  export type GetForumPostAggregateType<T extends ForumPostAggregateArgs> = {
        [P in keyof T & keyof AggregateForumPost]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumPost[P]>
      : GetScalarType<T[P], AggregateForumPost[P]>
  }




  export type ForumPostGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumPostWhereInput
    orderBy?: ForumPostOrderByWithAggregationInput | ForumPostOrderByWithAggregationInput[]
    by: ForumPostScalarFieldEnum[] | ForumPostScalarFieldEnum
    having?: ForumPostScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumPostCountAggregateInputType | true
    _avg?: ForumPostAvgAggregateInputType
    _sum?: ForumPostSumAggregateInputType
    _min?: ForumPostMinAggregateInputType
    _max?: ForumPostMaxAggregateInputType
  }

  export type ForumPostGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    title: string
    content: string
    category: string
    status: string
    upvotes: number
    downvotes: number
    views: number
    commentsCount: number
    pinned: boolean
    verifiedDoctor: boolean
    createdAt: Date
    updatedAt: Date
    _count: ForumPostCountAggregateOutputType | null
    _avg: ForumPostAvgAggregateOutputType | null
    _sum: ForumPostSumAggregateOutputType | null
    _min: ForumPostMinAggregateOutputType | null
    _max: ForumPostMaxAggregateOutputType | null
  }

  type GetForumPostGroupByPayload<T extends ForumPostGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumPostGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumPostGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
            : GetScalarType<T[P], ForumPostGroupByOutputType[P]>
        }
      >
    >


  export type ForumPostSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    views?: boolean
    commentsCount?: boolean
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    upvotesByUser?: boolean | ForumPost$upvotesByUserArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    views?: boolean
    commentsCount?: boolean
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumPost"]>

  export type ForumPostSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    title?: boolean
    content?: boolean
    category?: boolean
    status?: boolean
    upvotes?: boolean
    downvotes?: boolean
    views?: boolean
    commentsCount?: boolean
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumPostInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    comments?: boolean | ForumPost$commentsArgs<ExtArgs>
    upvotesByUser?: boolean | ForumPost$upvotesByUserArgs<ExtArgs>
    _count?: boolean | ForumPostCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumPostIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ForumPostPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumPost"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      comments: Prisma.$ForumCommentPayload<ExtArgs>[]
      upvotesByUser: Prisma.$PostUpvotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      title: string
      content: string
      category: string
      status: string
      upvotes: number
      downvotes: number
      views: number
      commentsCount: number
      pinned: boolean
      verifiedDoctor: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumPost"]>
    composites: {}
  }

  type ForumPostGetPayload<S extends boolean | null | undefined | ForumPostDefaultArgs> = $Result.GetResult<Prisma.$ForumPostPayload, S>

  type ForumPostCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumPostFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumPostCountAggregateInputType | true
    }

  export interface ForumPostDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumPost'], meta: { name: 'ForumPost' } }
    /**
     * Find zero or one ForumPost that matches the filter.
     * @param {ForumPostFindUniqueArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumPostFindUniqueArgs>(args: SelectSubset<T, ForumPostFindUniqueArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumPost that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumPostFindUniqueOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumPostFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumPostFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumPostFindFirstArgs>(args?: SelectSubset<T, ForumPostFindFirstArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumPost that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindFirstOrThrowArgs} args - Arguments to find a ForumPost
     * @example
     * // Get one ForumPost
     * const forumPost = await prisma.forumPost.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumPostFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumPostFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumPosts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumPosts
     * const forumPosts = await prisma.forumPost.findMany()
     * 
     * // Get first 10 ForumPosts
     * const forumPosts = await prisma.forumPost.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumPostFindManyArgs>(args?: SelectSubset<T, ForumPostFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumPost.
     * @param {ForumPostCreateArgs} args - Arguments to create a ForumPost.
     * @example
     * // Create one ForumPost
     * const ForumPost = await prisma.forumPost.create({
     *   data: {
     *     // ... data to create a ForumPost
     *   }
     * })
     * 
     */
    create<T extends ForumPostCreateArgs>(args: SelectSubset<T, ForumPostCreateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumPosts.
     * @param {ForumPostCreateManyArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumPostCreateManyArgs>(args?: SelectSubset<T, ForumPostCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumPosts and returns the data saved in the database.
     * @param {ForumPostCreateManyAndReturnArgs} args - Arguments to create many ForumPosts.
     * @example
     * // Create many ForumPosts
     * const forumPost = await prisma.forumPost.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumPosts and only return the `id`
     * const forumPostWithIdOnly = await prisma.forumPost.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumPostCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumPostCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumPost.
     * @param {ForumPostDeleteArgs} args - Arguments to delete one ForumPost.
     * @example
     * // Delete one ForumPost
     * const ForumPost = await prisma.forumPost.delete({
     *   where: {
     *     // ... filter to delete one ForumPost
     *   }
     * })
     * 
     */
    delete<T extends ForumPostDeleteArgs>(args: SelectSubset<T, ForumPostDeleteArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumPost.
     * @param {ForumPostUpdateArgs} args - Arguments to update one ForumPost.
     * @example
     * // Update one ForumPost
     * const forumPost = await prisma.forumPost.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumPostUpdateArgs>(args: SelectSubset<T, ForumPostUpdateArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumPosts.
     * @param {ForumPostDeleteManyArgs} args - Arguments to filter ForumPosts to delete.
     * @example
     * // Delete a few ForumPosts
     * const { count } = await prisma.forumPost.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumPostDeleteManyArgs>(args?: SelectSubset<T, ForumPostDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumPosts
     * const forumPost = await prisma.forumPost.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumPostUpdateManyArgs>(args: SelectSubset<T, ForumPostUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumPost.
     * @param {ForumPostUpsertArgs} args - Arguments to update or create a ForumPost.
     * @example
     * // Update or create a ForumPost
     * const forumPost = await prisma.forumPost.upsert({
     *   create: {
     *     // ... data to create a ForumPost
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumPost we want to update
     *   }
     * })
     */
    upsert<T extends ForumPostUpsertArgs>(args: SelectSubset<T, ForumPostUpsertArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumPosts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostCountArgs} args - Arguments to filter ForumPosts to count.
     * @example
     * // Count the number of ForumPosts
     * const count = await prisma.forumPost.count({
     *   where: {
     *     // ... the filter for the ForumPosts we want to count
     *   }
     * })
    **/
    count<T extends ForumPostCountArgs>(
      args?: Subset<T, ForumPostCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumPostCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumPostAggregateArgs>(args: Subset<T, ForumPostAggregateArgs>): Prisma.PrismaPromise<GetForumPostAggregateType<T>>

    /**
     * Group by ForumPost.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumPostGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumPostGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumPostGroupByArgs['orderBy'] }
        : { orderBy?: ForumPostGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumPostGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumPostGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumPost model
   */
  readonly fields: ForumPostFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumPost.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumPostClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    comments<T extends ForumPost$commentsArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany"> | Null>
    upvotesByUser<T extends ForumPost$upvotesByUserArgs<ExtArgs> = {}>(args?: Subset<T, ForumPost$upvotesByUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumPost model
   */ 
  interface ForumPostFieldRefs {
    readonly id: FieldRef<"ForumPost", 'Int'>
    readonly uuid: FieldRef<"ForumPost", 'String'>
    readonly userId: FieldRef<"ForumPost", 'Int'>
    readonly title: FieldRef<"ForumPost", 'String'>
    readonly content: FieldRef<"ForumPost", 'String'>
    readonly category: FieldRef<"ForumPost", 'String'>
    readonly status: FieldRef<"ForumPost", 'String'>
    readonly upvotes: FieldRef<"ForumPost", 'Int'>
    readonly downvotes: FieldRef<"ForumPost", 'Int'>
    readonly views: FieldRef<"ForumPost", 'Int'>
    readonly commentsCount: FieldRef<"ForumPost", 'Int'>
    readonly pinned: FieldRef<"ForumPost", 'Boolean'>
    readonly verifiedDoctor: FieldRef<"ForumPost", 'Boolean'>
    readonly createdAt: FieldRef<"ForumPost", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumPost", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumPost findUnique
   */
  export type ForumPostFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findUniqueOrThrow
   */
  export type ForumPostFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost findFirst
   */
  export type ForumPostFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findFirstOrThrow
   */
  export type ForumPostFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPost to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumPosts.
     */
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost findMany
   */
  export type ForumPostFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter, which ForumPosts to fetch.
     */
    where?: ForumPostWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumPosts to fetch.
     */
    orderBy?: ForumPostOrderByWithRelationInput | ForumPostOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumPosts.
     */
    cursor?: ForumPostWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumPosts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumPosts.
     */
    skip?: number
    distinct?: ForumPostScalarFieldEnum | ForumPostScalarFieldEnum[]
  }

  /**
   * ForumPost create
   */
  export type ForumPostCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumPost.
     */
    data: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
  }

  /**
   * ForumPost createMany
   */
  export type ForumPostCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
  }

  /**
   * ForumPost createManyAndReturn
   */
  export type ForumPostCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumPosts.
     */
    data: ForumPostCreateManyInput | ForumPostCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumPost update
   */
  export type ForumPostUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumPost.
     */
    data: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
    /**
     * Choose, which ForumPost to update.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost updateMany
   */
  export type ForumPostUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumPosts.
     */
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyInput>
    /**
     * Filter which ForumPosts to update
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost upsert
   */
  export type ForumPostUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumPost to update in case it exists.
     */
    where: ForumPostWhereUniqueInput
    /**
     * In case the ForumPost found by the `where` argument doesn't exist, create a new ForumPost with this data.
     */
    create: XOR<ForumPostCreateInput, ForumPostUncheckedCreateInput>
    /**
     * In case the ForumPost was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumPostUpdateInput, ForumPostUncheckedUpdateInput>
  }

  /**
   * ForumPost delete
   */
  export type ForumPostDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
    /**
     * Filter which ForumPost to delete.
     */
    where: ForumPostWhereUniqueInput
  }

  /**
   * ForumPost deleteMany
   */
  export type ForumPostDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumPosts to delete
     */
    where?: ForumPostWhereInput
  }

  /**
   * ForumPost.comments
   */
  export type ForumPost$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumPost.upvotesByUser
   */
  export type ForumPost$upvotesByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    where?: PostUpvoteWhereInput
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    cursor?: PostUpvoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PostUpvoteScalarFieldEnum | PostUpvoteScalarFieldEnum[]
  }

  /**
   * ForumPost without action
   */
  export type ForumPostDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumPost
     */
    select?: ForumPostSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumPostInclude<ExtArgs> | null
  }


  /**
   * Model ForumComment
   */

  export type AggregateForumComment = {
    _count: ForumCommentCountAggregateOutputType | null
    _avg: ForumCommentAvgAggregateOutputType | null
    _sum: ForumCommentSumAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  export type ForumCommentAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    upvotes: number | null
    helpfulCount: number | null
  }

  export type ForumCommentSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    upvotes: number | null
    helpfulCount: number | null
  }

  export type ForumCommentMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    content: string | null
    upvotes: number | null
    helpfulCount: number | null
    verifiedDoctor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    postId: number | null
    userId: number | null
    parentCommentId: number | null
    content: string | null
    upvotes: number | null
    helpfulCount: number | null
    verifiedDoctor: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ForumCommentCountAggregateOutputType = {
    id: number
    uuid: number
    postId: number
    userId: number
    parentCommentId: number
    content: number
    upvotes: number
    helpfulCount: number
    verifiedDoctor: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ForumCommentAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    upvotes?: true
    helpfulCount?: true
  }

  export type ForumCommentSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    upvotes?: true
    helpfulCount?: true
  }

  export type ForumCommentMinAggregateInputType = {
    id?: true
    uuid?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    content?: true
    upvotes?: true
    helpfulCount?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentMaxAggregateInputType = {
    id?: true
    uuid?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    content?: true
    upvotes?: true
    helpfulCount?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ForumCommentCountAggregateInputType = {
    id?: true
    uuid?: true
    postId?: true
    userId?: true
    parentCommentId?: true
    content?: true
    upvotes?: true
    helpfulCount?: true
    verifiedDoctor?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ForumCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComment to aggregate.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ForumComments
    **/
    _count?: true | ForumCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ForumCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ForumCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ForumCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ForumCommentMaxAggregateInputType
  }

  export type GetForumCommentAggregateType<T extends ForumCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateForumComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateForumComment[P]>
      : GetScalarType<T[P], AggregateForumComment[P]>
  }




  export type ForumCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithAggregationInput | ForumCommentOrderByWithAggregationInput[]
    by: ForumCommentScalarFieldEnum[] | ForumCommentScalarFieldEnum
    having?: ForumCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ForumCommentCountAggregateInputType | true
    _avg?: ForumCommentAvgAggregateInputType
    _sum?: ForumCommentSumAggregateInputType
    _min?: ForumCommentMinAggregateInputType
    _max?: ForumCommentMaxAggregateInputType
  }

  export type ForumCommentGroupByOutputType = {
    id: number
    uuid: string
    postId: number
    userId: number
    parentCommentId: number | null
    content: string
    upvotes: number
    helpfulCount: number
    verifiedDoctor: boolean
    createdAt: Date
    updatedAt: Date
    _count: ForumCommentCountAggregateOutputType | null
    _avg: ForumCommentAvgAggregateOutputType | null
    _sum: ForumCommentSumAggregateOutputType | null
    _min: ForumCommentMinAggregateOutputType | null
    _max: ForumCommentMaxAggregateOutputType | null
  }

  type GetForumCommentGroupByPayload<T extends ForumCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ForumCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ForumCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ForumCommentGroupByOutputType[P]>
        }
      >
    >


  export type ForumCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    postId?: boolean
    userId?: boolean
    parentCommentId?: boolean
    content?: boolean
    upvotes?: boolean
    helpfulCount?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ForumComment$parentCommentArgs<ExtArgs>
    replies?: boolean | ForumComment$repliesArgs<ExtArgs>
    upvotesByUser?: boolean | ForumComment$upvotesByUserArgs<ExtArgs>
    _count?: boolean | ForumCommentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    postId?: boolean
    userId?: boolean
    parentCommentId?: boolean
    content?: boolean
    upvotes?: boolean
    helpfulCount?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ForumComment$parentCommentArgs<ExtArgs>
  }, ExtArgs["result"]["forumComment"]>

  export type ForumCommentSelectScalar = {
    id?: boolean
    uuid?: boolean
    postId?: boolean
    userId?: boolean
    parentCommentId?: boolean
    content?: boolean
    upvotes?: boolean
    helpfulCount?: boolean
    verifiedDoctor?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ForumCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ForumComment$parentCommentArgs<ExtArgs>
    replies?: boolean | ForumComment$repliesArgs<ExtArgs>
    upvotesByUser?: boolean | ForumComment$upvotesByUserArgs<ExtArgs>
    _count?: boolean | ForumCommentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ForumCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    parentComment?: boolean | ForumComment$parentCommentArgs<ExtArgs>
  }

  export type $ForumCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ForumComment"
    objects: {
      post: Prisma.$ForumPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      parentComment: Prisma.$ForumCommentPayload<ExtArgs> | null
      replies: Prisma.$ForumCommentPayload<ExtArgs>[]
      upvotesByUser: Prisma.$CommentUpvotePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      postId: number
      userId: number
      parentCommentId: number | null
      content: string
      upvotes: number
      helpfulCount: number
      verifiedDoctor: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["forumComment"]>
    composites: {}
  }

  type ForumCommentGetPayload<S extends boolean | null | undefined | ForumCommentDefaultArgs> = $Result.GetResult<Prisma.$ForumCommentPayload, S>

  type ForumCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ForumCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ForumCommentCountAggregateInputType | true
    }

  export interface ForumCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ForumComment'], meta: { name: 'ForumComment' } }
    /**
     * Find zero or one ForumComment that matches the filter.
     * @param {ForumCommentFindUniqueArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ForumCommentFindUniqueArgs>(args: SelectSubset<T, ForumCommentFindUniqueArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ForumComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ForumCommentFindUniqueOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ForumCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ForumCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ForumComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ForumCommentFindFirstArgs>(args?: SelectSubset<T, ForumCommentFindFirstArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ForumComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindFirstOrThrowArgs} args - Arguments to find a ForumComment
     * @example
     * // Get one ForumComment
     * const forumComment = await prisma.forumComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ForumCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ForumCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ForumComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ForumComments
     * const forumComments = await prisma.forumComment.findMany()
     * 
     * // Get first 10 ForumComments
     * const forumComments = await prisma.forumComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ForumCommentFindManyArgs>(args?: SelectSubset<T, ForumCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ForumComment.
     * @param {ForumCommentCreateArgs} args - Arguments to create a ForumComment.
     * @example
     * // Create one ForumComment
     * const ForumComment = await prisma.forumComment.create({
     *   data: {
     *     // ... data to create a ForumComment
     *   }
     * })
     * 
     */
    create<T extends ForumCommentCreateArgs>(args: SelectSubset<T, ForumCommentCreateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ForumComments.
     * @param {ForumCommentCreateManyArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ForumCommentCreateManyArgs>(args?: SelectSubset<T, ForumCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ForumComments and returns the data saved in the database.
     * @param {ForumCommentCreateManyAndReturnArgs} args - Arguments to create many ForumComments.
     * @example
     * // Create many ForumComments
     * const forumComment = await prisma.forumComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ForumComments and only return the `id`
     * const forumCommentWithIdOnly = await prisma.forumComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ForumCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ForumCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ForumComment.
     * @param {ForumCommentDeleteArgs} args - Arguments to delete one ForumComment.
     * @example
     * // Delete one ForumComment
     * const ForumComment = await prisma.forumComment.delete({
     *   where: {
     *     // ... filter to delete one ForumComment
     *   }
     * })
     * 
     */
    delete<T extends ForumCommentDeleteArgs>(args: SelectSubset<T, ForumCommentDeleteArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ForumComment.
     * @param {ForumCommentUpdateArgs} args - Arguments to update one ForumComment.
     * @example
     * // Update one ForumComment
     * const forumComment = await prisma.forumComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ForumCommentUpdateArgs>(args: SelectSubset<T, ForumCommentUpdateArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ForumComments.
     * @param {ForumCommentDeleteManyArgs} args - Arguments to filter ForumComments to delete.
     * @example
     * // Delete a few ForumComments
     * const { count } = await prisma.forumComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ForumCommentDeleteManyArgs>(args?: SelectSubset<T, ForumCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ForumComments
     * const forumComment = await prisma.forumComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ForumCommentUpdateManyArgs>(args: SelectSubset<T, ForumCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ForumComment.
     * @param {ForumCommentUpsertArgs} args - Arguments to update or create a ForumComment.
     * @example
     * // Update or create a ForumComment
     * const forumComment = await prisma.forumComment.upsert({
     *   create: {
     *     // ... data to create a ForumComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ForumComment we want to update
     *   }
     * })
     */
    upsert<T extends ForumCommentUpsertArgs>(args: SelectSubset<T, ForumCommentUpsertArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ForumComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentCountArgs} args - Arguments to filter ForumComments to count.
     * @example
     * // Count the number of ForumComments
     * const count = await prisma.forumComment.count({
     *   where: {
     *     // ... the filter for the ForumComments we want to count
     *   }
     * })
    **/
    count<T extends ForumCommentCountArgs>(
      args?: Subset<T, ForumCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ForumCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ForumCommentAggregateArgs>(args: Subset<T, ForumCommentAggregateArgs>): Prisma.PrismaPromise<GetForumCommentAggregateType<T>>

    /**
     * Group by ForumComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ForumCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ForumCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ForumCommentGroupByArgs['orderBy'] }
        : { orderBy?: ForumCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ForumCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetForumCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ForumComment model
   */
  readonly fields: ForumCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ForumComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ForumCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends ForumPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostDefaultArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    parentComment<T extends ForumComment$parentCommentArgs<ExtArgs> = {}>(args?: Subset<T, ForumComment$parentCommentArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    replies<T extends ForumComment$repliesArgs<ExtArgs> = {}>(args?: Subset<T, ForumComment$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findMany"> | Null>
    upvotesByUser<T extends ForumComment$upvotesByUserArgs<ExtArgs> = {}>(args?: Subset<T, ForumComment$upvotesByUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ForumComment model
   */ 
  interface ForumCommentFieldRefs {
    readonly id: FieldRef<"ForumComment", 'Int'>
    readonly uuid: FieldRef<"ForumComment", 'String'>
    readonly postId: FieldRef<"ForumComment", 'Int'>
    readonly userId: FieldRef<"ForumComment", 'Int'>
    readonly parentCommentId: FieldRef<"ForumComment", 'Int'>
    readonly content: FieldRef<"ForumComment", 'String'>
    readonly upvotes: FieldRef<"ForumComment", 'Int'>
    readonly helpfulCount: FieldRef<"ForumComment", 'Int'>
    readonly verifiedDoctor: FieldRef<"ForumComment", 'Boolean'>
    readonly createdAt: FieldRef<"ForumComment", 'DateTime'>
    readonly updatedAt: FieldRef<"ForumComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ForumComment findUnique
   */
  export type ForumCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findUniqueOrThrow
   */
  export type ForumCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment findFirst
   */
  export type ForumCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findFirstOrThrow
   */
  export type ForumCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComment to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ForumComments.
     */
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment findMany
   */
  export type ForumCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter, which ForumComments to fetch.
     */
    where?: ForumCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ForumComments to fetch.
     */
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ForumComments.
     */
    cursor?: ForumCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ForumComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ForumComments.
     */
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment create
   */
  export type ForumCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ForumComment.
     */
    data: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
  }

  /**
   * ForumComment createMany
   */
  export type ForumCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
  }

  /**
   * ForumComment createManyAndReturn
   */
  export type ForumCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ForumComments.
     */
    data: ForumCommentCreateManyInput | ForumCommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ForumComment update
   */
  export type ForumCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ForumComment.
     */
    data: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
    /**
     * Choose, which ForumComment to update.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment updateMany
   */
  export type ForumCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ForumComments.
     */
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyInput>
    /**
     * Filter which ForumComments to update
     */
    where?: ForumCommentWhereInput
  }

  /**
   * ForumComment upsert
   */
  export type ForumCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ForumComment to update in case it exists.
     */
    where: ForumCommentWhereUniqueInput
    /**
     * In case the ForumComment found by the `where` argument doesn't exist, create a new ForumComment with this data.
     */
    create: XOR<ForumCommentCreateInput, ForumCommentUncheckedCreateInput>
    /**
     * In case the ForumComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ForumCommentUpdateInput, ForumCommentUncheckedUpdateInput>
  }

  /**
   * ForumComment delete
   */
  export type ForumCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    /**
     * Filter which ForumComment to delete.
     */
    where: ForumCommentWhereUniqueInput
  }

  /**
   * ForumComment deleteMany
   */
  export type ForumCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ForumComments to delete
     */
    where?: ForumCommentWhereInput
  }

  /**
   * ForumComment.parentComment
   */
  export type ForumComment$parentCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
  }

  /**
   * ForumComment.replies
   */
  export type ForumComment$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
    where?: ForumCommentWhereInput
    orderBy?: ForumCommentOrderByWithRelationInput | ForumCommentOrderByWithRelationInput[]
    cursor?: ForumCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ForumCommentScalarFieldEnum | ForumCommentScalarFieldEnum[]
  }

  /**
   * ForumComment.upvotesByUser
   */
  export type ForumComment$upvotesByUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    where?: CommentUpvoteWhereInput
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    cursor?: CommentUpvoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CommentUpvoteScalarFieldEnum | CommentUpvoteScalarFieldEnum[]
  }

  /**
   * ForumComment without action
   */
  export type ForumCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ForumComment
     */
    select?: ForumCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ForumCommentInclude<ExtArgs> | null
  }


  /**
   * Model PostUpvote
   */

  export type AggregatePostUpvote = {
    _count: PostUpvoteCountAggregateOutputType | null
    _avg: PostUpvoteAvgAggregateOutputType | null
    _sum: PostUpvoteSumAggregateOutputType | null
    _min: PostUpvoteMinAggregateOutputType | null
    _max: PostUpvoteMaxAggregateOutputType | null
  }

  export type PostUpvoteAvgAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type PostUpvoteSumAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
  }

  export type PostUpvoteMinAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    voteType: string | null
  }

  export type PostUpvoteMaxAggregateOutputType = {
    id: number | null
    postId: number | null
    userId: number | null
    voteType: string | null
  }

  export type PostUpvoteCountAggregateOutputType = {
    id: number
    postId: number
    userId: number
    voteType: number
    _all: number
  }


  export type PostUpvoteAvgAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type PostUpvoteSumAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
  }

  export type PostUpvoteMinAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    voteType?: true
  }

  export type PostUpvoteMaxAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    voteType?: true
  }

  export type PostUpvoteCountAggregateInputType = {
    id?: true
    postId?: true
    userId?: true
    voteType?: true
    _all?: true
  }

  export type PostUpvoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostUpvote to aggregate.
     */
    where?: PostUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUpvotes to fetch.
     */
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PostUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PostUpvotes
    **/
    _count?: true | PostUpvoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PostUpvoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PostUpvoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PostUpvoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PostUpvoteMaxAggregateInputType
  }

  export type GetPostUpvoteAggregateType<T extends PostUpvoteAggregateArgs> = {
        [P in keyof T & keyof AggregatePostUpvote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePostUpvote[P]>
      : GetScalarType<T[P], AggregatePostUpvote[P]>
  }




  export type PostUpvoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PostUpvoteWhereInput
    orderBy?: PostUpvoteOrderByWithAggregationInput | PostUpvoteOrderByWithAggregationInput[]
    by: PostUpvoteScalarFieldEnum[] | PostUpvoteScalarFieldEnum
    having?: PostUpvoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PostUpvoteCountAggregateInputType | true
    _avg?: PostUpvoteAvgAggregateInputType
    _sum?: PostUpvoteSumAggregateInputType
    _min?: PostUpvoteMinAggregateInputType
    _max?: PostUpvoteMaxAggregateInputType
  }

  export type PostUpvoteGroupByOutputType = {
    id: number
    postId: number
    userId: number
    voteType: string
    _count: PostUpvoteCountAggregateOutputType | null
    _avg: PostUpvoteAvgAggregateOutputType | null
    _sum: PostUpvoteSumAggregateOutputType | null
    _min: PostUpvoteMinAggregateOutputType | null
    _max: PostUpvoteMaxAggregateOutputType | null
  }

  type GetPostUpvoteGroupByPayload<T extends PostUpvoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PostUpvoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PostUpvoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PostUpvoteGroupByOutputType[P]>
            : GetScalarType<T[P], PostUpvoteGroupByOutputType[P]>
        }
      >
    >


  export type PostUpvoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    voteType?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postUpvote"]>

  export type PostUpvoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    postId?: boolean
    userId?: boolean
    voteType?: boolean
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["postUpvote"]>

  export type PostUpvoteSelectScalar = {
    id?: boolean
    postId?: boolean
    userId?: boolean
    voteType?: boolean
  }

  export type PostUpvoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PostUpvoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    post?: boolean | ForumPostDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PostUpvotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PostUpvote"
    objects: {
      post: Prisma.$ForumPostPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      postId: number
      userId: number
      voteType: string
    }, ExtArgs["result"]["postUpvote"]>
    composites: {}
  }

  type PostUpvoteGetPayload<S extends boolean | null | undefined | PostUpvoteDefaultArgs> = $Result.GetResult<Prisma.$PostUpvotePayload, S>

  type PostUpvoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PostUpvoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PostUpvoteCountAggregateInputType | true
    }

  export interface PostUpvoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PostUpvote'], meta: { name: 'PostUpvote' } }
    /**
     * Find zero or one PostUpvote that matches the filter.
     * @param {PostUpvoteFindUniqueArgs} args - Arguments to find a PostUpvote
     * @example
     * // Get one PostUpvote
     * const postUpvote = await prisma.postUpvote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PostUpvoteFindUniqueArgs>(args: SelectSubset<T, PostUpvoteFindUniqueArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PostUpvote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PostUpvoteFindUniqueOrThrowArgs} args - Arguments to find a PostUpvote
     * @example
     * // Get one PostUpvote
     * const postUpvote = await prisma.postUpvote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PostUpvoteFindUniqueOrThrowArgs>(args: SelectSubset<T, PostUpvoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PostUpvote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteFindFirstArgs} args - Arguments to find a PostUpvote
     * @example
     * // Get one PostUpvote
     * const postUpvote = await prisma.postUpvote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PostUpvoteFindFirstArgs>(args?: SelectSubset<T, PostUpvoteFindFirstArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PostUpvote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteFindFirstOrThrowArgs} args - Arguments to find a PostUpvote
     * @example
     * // Get one PostUpvote
     * const postUpvote = await prisma.postUpvote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PostUpvoteFindFirstOrThrowArgs>(args?: SelectSubset<T, PostUpvoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PostUpvotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PostUpvotes
     * const postUpvotes = await prisma.postUpvote.findMany()
     * 
     * // Get first 10 PostUpvotes
     * const postUpvotes = await prisma.postUpvote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const postUpvoteWithIdOnly = await prisma.postUpvote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PostUpvoteFindManyArgs>(args?: SelectSubset<T, PostUpvoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PostUpvote.
     * @param {PostUpvoteCreateArgs} args - Arguments to create a PostUpvote.
     * @example
     * // Create one PostUpvote
     * const PostUpvote = await prisma.postUpvote.create({
     *   data: {
     *     // ... data to create a PostUpvote
     *   }
     * })
     * 
     */
    create<T extends PostUpvoteCreateArgs>(args: SelectSubset<T, PostUpvoteCreateArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PostUpvotes.
     * @param {PostUpvoteCreateManyArgs} args - Arguments to create many PostUpvotes.
     * @example
     * // Create many PostUpvotes
     * const postUpvote = await prisma.postUpvote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PostUpvoteCreateManyArgs>(args?: SelectSubset<T, PostUpvoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PostUpvotes and returns the data saved in the database.
     * @param {PostUpvoteCreateManyAndReturnArgs} args - Arguments to create many PostUpvotes.
     * @example
     * // Create many PostUpvotes
     * const postUpvote = await prisma.postUpvote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PostUpvotes and only return the `id`
     * const postUpvoteWithIdOnly = await prisma.postUpvote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PostUpvoteCreateManyAndReturnArgs>(args?: SelectSubset<T, PostUpvoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PostUpvote.
     * @param {PostUpvoteDeleteArgs} args - Arguments to delete one PostUpvote.
     * @example
     * // Delete one PostUpvote
     * const PostUpvote = await prisma.postUpvote.delete({
     *   where: {
     *     // ... filter to delete one PostUpvote
     *   }
     * })
     * 
     */
    delete<T extends PostUpvoteDeleteArgs>(args: SelectSubset<T, PostUpvoteDeleteArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PostUpvote.
     * @param {PostUpvoteUpdateArgs} args - Arguments to update one PostUpvote.
     * @example
     * // Update one PostUpvote
     * const postUpvote = await prisma.postUpvote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PostUpvoteUpdateArgs>(args: SelectSubset<T, PostUpvoteUpdateArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PostUpvotes.
     * @param {PostUpvoteDeleteManyArgs} args - Arguments to filter PostUpvotes to delete.
     * @example
     * // Delete a few PostUpvotes
     * const { count } = await prisma.postUpvote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PostUpvoteDeleteManyArgs>(args?: SelectSubset<T, PostUpvoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PostUpvotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PostUpvotes
     * const postUpvote = await prisma.postUpvote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PostUpvoteUpdateManyArgs>(args: SelectSubset<T, PostUpvoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PostUpvote.
     * @param {PostUpvoteUpsertArgs} args - Arguments to update or create a PostUpvote.
     * @example
     * // Update or create a PostUpvote
     * const postUpvote = await prisma.postUpvote.upsert({
     *   create: {
     *     // ... data to create a PostUpvote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PostUpvote we want to update
     *   }
     * })
     */
    upsert<T extends PostUpvoteUpsertArgs>(args: SelectSubset<T, PostUpvoteUpsertArgs<ExtArgs>>): Prisma__PostUpvoteClient<$Result.GetResult<Prisma.$PostUpvotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PostUpvotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteCountArgs} args - Arguments to filter PostUpvotes to count.
     * @example
     * // Count the number of PostUpvotes
     * const count = await prisma.postUpvote.count({
     *   where: {
     *     // ... the filter for the PostUpvotes we want to count
     *   }
     * })
    **/
    count<T extends PostUpvoteCountArgs>(
      args?: Subset<T, PostUpvoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PostUpvoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PostUpvote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PostUpvoteAggregateArgs>(args: Subset<T, PostUpvoteAggregateArgs>): Prisma.PrismaPromise<GetPostUpvoteAggregateType<T>>

    /**
     * Group by PostUpvote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PostUpvoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PostUpvoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PostUpvoteGroupByArgs['orderBy'] }
        : { orderBy?: PostUpvoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PostUpvoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPostUpvoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PostUpvote model
   */
  readonly fields: PostUpvoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PostUpvote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PostUpvoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    post<T extends ForumPostDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumPostDefaultArgs<ExtArgs>>): Prisma__ForumPostClient<$Result.GetResult<Prisma.$ForumPostPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PostUpvote model
   */ 
  interface PostUpvoteFieldRefs {
    readonly id: FieldRef<"PostUpvote", 'Int'>
    readonly postId: FieldRef<"PostUpvote", 'Int'>
    readonly userId: FieldRef<"PostUpvote", 'Int'>
    readonly voteType: FieldRef<"PostUpvote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PostUpvote findUnique
   */
  export type PostUpvoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which PostUpvote to fetch.
     */
    where: PostUpvoteWhereUniqueInput
  }

  /**
   * PostUpvote findUniqueOrThrow
   */
  export type PostUpvoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which PostUpvote to fetch.
     */
    where: PostUpvoteWhereUniqueInput
  }

  /**
   * PostUpvote findFirst
   */
  export type PostUpvoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which PostUpvote to fetch.
     */
    where?: PostUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUpvotes to fetch.
     */
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostUpvotes.
     */
    cursor?: PostUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostUpvotes.
     */
    distinct?: PostUpvoteScalarFieldEnum | PostUpvoteScalarFieldEnum[]
  }

  /**
   * PostUpvote findFirstOrThrow
   */
  export type PostUpvoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which PostUpvote to fetch.
     */
    where?: PostUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUpvotes to fetch.
     */
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PostUpvotes.
     */
    cursor?: PostUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PostUpvotes.
     */
    distinct?: PostUpvoteScalarFieldEnum | PostUpvoteScalarFieldEnum[]
  }

  /**
   * PostUpvote findMany
   */
  export type PostUpvoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which PostUpvotes to fetch.
     */
    where?: PostUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PostUpvotes to fetch.
     */
    orderBy?: PostUpvoteOrderByWithRelationInput | PostUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PostUpvotes.
     */
    cursor?: PostUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PostUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PostUpvotes.
     */
    skip?: number
    distinct?: PostUpvoteScalarFieldEnum | PostUpvoteScalarFieldEnum[]
  }

  /**
   * PostUpvote create
   */
  export type PostUpvoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * The data needed to create a PostUpvote.
     */
    data: XOR<PostUpvoteCreateInput, PostUpvoteUncheckedCreateInput>
  }

  /**
   * PostUpvote createMany
   */
  export type PostUpvoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PostUpvotes.
     */
    data: PostUpvoteCreateManyInput | PostUpvoteCreateManyInput[]
  }

  /**
   * PostUpvote createManyAndReturn
   */
  export type PostUpvoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PostUpvotes.
     */
    data: PostUpvoteCreateManyInput | PostUpvoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PostUpvote update
   */
  export type PostUpvoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * The data needed to update a PostUpvote.
     */
    data: XOR<PostUpvoteUpdateInput, PostUpvoteUncheckedUpdateInput>
    /**
     * Choose, which PostUpvote to update.
     */
    where: PostUpvoteWhereUniqueInput
  }

  /**
   * PostUpvote updateMany
   */
  export type PostUpvoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PostUpvotes.
     */
    data: XOR<PostUpvoteUpdateManyMutationInput, PostUpvoteUncheckedUpdateManyInput>
    /**
     * Filter which PostUpvotes to update
     */
    where?: PostUpvoteWhereInput
  }

  /**
   * PostUpvote upsert
   */
  export type PostUpvoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * The filter to search for the PostUpvote to update in case it exists.
     */
    where: PostUpvoteWhereUniqueInput
    /**
     * In case the PostUpvote found by the `where` argument doesn't exist, create a new PostUpvote with this data.
     */
    create: XOR<PostUpvoteCreateInput, PostUpvoteUncheckedCreateInput>
    /**
     * In case the PostUpvote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PostUpvoteUpdateInput, PostUpvoteUncheckedUpdateInput>
  }

  /**
   * PostUpvote delete
   */
  export type PostUpvoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
    /**
     * Filter which PostUpvote to delete.
     */
    where: PostUpvoteWhereUniqueInput
  }

  /**
   * PostUpvote deleteMany
   */
  export type PostUpvoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PostUpvotes to delete
     */
    where?: PostUpvoteWhereInput
  }

  /**
   * PostUpvote without action
   */
  export type PostUpvoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PostUpvote
     */
    select?: PostUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PostUpvoteInclude<ExtArgs> | null
  }


  /**
   * Model CommentUpvote
   */

  export type AggregateCommentUpvote = {
    _count: CommentUpvoteCountAggregateOutputType | null
    _avg: CommentUpvoteAvgAggregateOutputType | null
    _sum: CommentUpvoteSumAggregateOutputType | null
    _min: CommentUpvoteMinAggregateOutputType | null
    _max: CommentUpvoteMaxAggregateOutputType | null
  }

  export type CommentUpvoteAvgAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type CommentUpvoteSumAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
  }

  export type CommentUpvoteMinAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    voteType: string | null
  }

  export type CommentUpvoteMaxAggregateOutputType = {
    id: number | null
    commentId: number | null
    userId: number | null
    voteType: string | null
  }

  export type CommentUpvoteCountAggregateOutputType = {
    id: number
    commentId: number
    userId: number
    voteType: number
    _all: number
  }


  export type CommentUpvoteAvgAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type CommentUpvoteSumAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
  }

  export type CommentUpvoteMinAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    voteType?: true
  }

  export type CommentUpvoteMaxAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    voteType?: true
  }

  export type CommentUpvoteCountAggregateInputType = {
    id?: true
    commentId?: true
    userId?: true
    voteType?: true
    _all?: true
  }

  export type CommentUpvoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentUpvote to aggregate.
     */
    where?: CommentUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUpvotes to fetch.
     */
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CommentUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CommentUpvotes
    **/
    _count?: true | CommentUpvoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CommentUpvoteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CommentUpvoteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CommentUpvoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CommentUpvoteMaxAggregateInputType
  }

  export type GetCommentUpvoteAggregateType<T extends CommentUpvoteAggregateArgs> = {
        [P in keyof T & keyof AggregateCommentUpvote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCommentUpvote[P]>
      : GetScalarType<T[P], AggregateCommentUpvote[P]>
  }




  export type CommentUpvoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CommentUpvoteWhereInput
    orderBy?: CommentUpvoteOrderByWithAggregationInput | CommentUpvoteOrderByWithAggregationInput[]
    by: CommentUpvoteScalarFieldEnum[] | CommentUpvoteScalarFieldEnum
    having?: CommentUpvoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CommentUpvoteCountAggregateInputType | true
    _avg?: CommentUpvoteAvgAggregateInputType
    _sum?: CommentUpvoteSumAggregateInputType
    _min?: CommentUpvoteMinAggregateInputType
    _max?: CommentUpvoteMaxAggregateInputType
  }

  export type CommentUpvoteGroupByOutputType = {
    id: number
    commentId: number
    userId: number
    voteType: string
    _count: CommentUpvoteCountAggregateOutputType | null
    _avg: CommentUpvoteAvgAggregateOutputType | null
    _sum: CommentUpvoteSumAggregateOutputType | null
    _min: CommentUpvoteMinAggregateOutputType | null
    _max: CommentUpvoteMaxAggregateOutputType | null
  }

  type GetCommentUpvoteGroupByPayload<T extends CommentUpvoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CommentUpvoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CommentUpvoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CommentUpvoteGroupByOutputType[P]>
            : GetScalarType<T[P], CommentUpvoteGroupByOutputType[P]>
        }
      >
    >


  export type CommentUpvoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    voteType?: boolean
    comment?: boolean | ForumCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentUpvote"]>

  export type CommentUpvoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    commentId?: boolean
    userId?: boolean
    voteType?: boolean
    comment?: boolean | ForumCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["commentUpvote"]>

  export type CommentUpvoteSelectScalar = {
    id?: boolean
    commentId?: boolean
    userId?: boolean
    voteType?: boolean
  }

  export type CommentUpvoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | ForumCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CommentUpvoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    comment?: boolean | ForumCommentDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CommentUpvotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CommentUpvote"
    objects: {
      comment: Prisma.$ForumCommentPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      commentId: number
      userId: number
      voteType: string
    }, ExtArgs["result"]["commentUpvote"]>
    composites: {}
  }

  type CommentUpvoteGetPayload<S extends boolean | null | undefined | CommentUpvoteDefaultArgs> = $Result.GetResult<Prisma.$CommentUpvotePayload, S>

  type CommentUpvoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CommentUpvoteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CommentUpvoteCountAggregateInputType | true
    }

  export interface CommentUpvoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CommentUpvote'], meta: { name: 'CommentUpvote' } }
    /**
     * Find zero or one CommentUpvote that matches the filter.
     * @param {CommentUpvoteFindUniqueArgs} args - Arguments to find a CommentUpvote
     * @example
     * // Get one CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CommentUpvoteFindUniqueArgs>(args: SelectSubset<T, CommentUpvoteFindUniqueArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CommentUpvote that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CommentUpvoteFindUniqueOrThrowArgs} args - Arguments to find a CommentUpvote
     * @example
     * // Get one CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CommentUpvoteFindUniqueOrThrowArgs>(args: SelectSubset<T, CommentUpvoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CommentUpvote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteFindFirstArgs} args - Arguments to find a CommentUpvote
     * @example
     * // Get one CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CommentUpvoteFindFirstArgs>(args?: SelectSubset<T, CommentUpvoteFindFirstArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CommentUpvote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteFindFirstOrThrowArgs} args - Arguments to find a CommentUpvote
     * @example
     * // Get one CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CommentUpvoteFindFirstOrThrowArgs>(args?: SelectSubset<T, CommentUpvoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CommentUpvotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CommentUpvotes
     * const commentUpvotes = await prisma.commentUpvote.findMany()
     * 
     * // Get first 10 CommentUpvotes
     * const commentUpvotes = await prisma.commentUpvote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const commentUpvoteWithIdOnly = await prisma.commentUpvote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CommentUpvoteFindManyArgs>(args?: SelectSubset<T, CommentUpvoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CommentUpvote.
     * @param {CommentUpvoteCreateArgs} args - Arguments to create a CommentUpvote.
     * @example
     * // Create one CommentUpvote
     * const CommentUpvote = await prisma.commentUpvote.create({
     *   data: {
     *     // ... data to create a CommentUpvote
     *   }
     * })
     * 
     */
    create<T extends CommentUpvoteCreateArgs>(args: SelectSubset<T, CommentUpvoteCreateArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CommentUpvotes.
     * @param {CommentUpvoteCreateManyArgs} args - Arguments to create many CommentUpvotes.
     * @example
     * // Create many CommentUpvotes
     * const commentUpvote = await prisma.commentUpvote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CommentUpvoteCreateManyArgs>(args?: SelectSubset<T, CommentUpvoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CommentUpvotes and returns the data saved in the database.
     * @param {CommentUpvoteCreateManyAndReturnArgs} args - Arguments to create many CommentUpvotes.
     * @example
     * // Create many CommentUpvotes
     * const commentUpvote = await prisma.commentUpvote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CommentUpvotes and only return the `id`
     * const commentUpvoteWithIdOnly = await prisma.commentUpvote.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CommentUpvoteCreateManyAndReturnArgs>(args?: SelectSubset<T, CommentUpvoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CommentUpvote.
     * @param {CommentUpvoteDeleteArgs} args - Arguments to delete one CommentUpvote.
     * @example
     * // Delete one CommentUpvote
     * const CommentUpvote = await prisma.commentUpvote.delete({
     *   where: {
     *     // ... filter to delete one CommentUpvote
     *   }
     * })
     * 
     */
    delete<T extends CommentUpvoteDeleteArgs>(args: SelectSubset<T, CommentUpvoteDeleteArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CommentUpvote.
     * @param {CommentUpvoteUpdateArgs} args - Arguments to update one CommentUpvote.
     * @example
     * // Update one CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CommentUpvoteUpdateArgs>(args: SelectSubset<T, CommentUpvoteUpdateArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CommentUpvotes.
     * @param {CommentUpvoteDeleteManyArgs} args - Arguments to filter CommentUpvotes to delete.
     * @example
     * // Delete a few CommentUpvotes
     * const { count } = await prisma.commentUpvote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CommentUpvoteDeleteManyArgs>(args?: SelectSubset<T, CommentUpvoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CommentUpvotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CommentUpvotes
     * const commentUpvote = await prisma.commentUpvote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CommentUpvoteUpdateManyArgs>(args: SelectSubset<T, CommentUpvoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CommentUpvote.
     * @param {CommentUpvoteUpsertArgs} args - Arguments to update or create a CommentUpvote.
     * @example
     * // Update or create a CommentUpvote
     * const commentUpvote = await prisma.commentUpvote.upsert({
     *   create: {
     *     // ... data to create a CommentUpvote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CommentUpvote we want to update
     *   }
     * })
     */
    upsert<T extends CommentUpvoteUpsertArgs>(args: SelectSubset<T, CommentUpvoteUpsertArgs<ExtArgs>>): Prisma__CommentUpvoteClient<$Result.GetResult<Prisma.$CommentUpvotePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CommentUpvotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteCountArgs} args - Arguments to filter CommentUpvotes to count.
     * @example
     * // Count the number of CommentUpvotes
     * const count = await prisma.commentUpvote.count({
     *   where: {
     *     // ... the filter for the CommentUpvotes we want to count
     *   }
     * })
    **/
    count<T extends CommentUpvoteCountArgs>(
      args?: Subset<T, CommentUpvoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CommentUpvoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CommentUpvote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CommentUpvoteAggregateArgs>(args: Subset<T, CommentUpvoteAggregateArgs>): Prisma.PrismaPromise<GetCommentUpvoteAggregateType<T>>

    /**
     * Group by CommentUpvote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CommentUpvoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CommentUpvoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CommentUpvoteGroupByArgs['orderBy'] }
        : { orderBy?: CommentUpvoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CommentUpvoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCommentUpvoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CommentUpvote model
   */
  readonly fields: CommentUpvoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CommentUpvote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CommentUpvoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    comment<T extends ForumCommentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ForumCommentDefaultArgs<ExtArgs>>): Prisma__ForumCommentClient<$Result.GetResult<Prisma.$ForumCommentPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CommentUpvote model
   */ 
  interface CommentUpvoteFieldRefs {
    readonly id: FieldRef<"CommentUpvote", 'Int'>
    readonly commentId: FieldRef<"CommentUpvote", 'Int'>
    readonly userId: FieldRef<"CommentUpvote", 'Int'>
    readonly voteType: FieldRef<"CommentUpvote", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CommentUpvote findUnique
   */
  export type CommentUpvoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentUpvote to fetch.
     */
    where: CommentUpvoteWhereUniqueInput
  }

  /**
   * CommentUpvote findUniqueOrThrow
   */
  export type CommentUpvoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentUpvote to fetch.
     */
    where: CommentUpvoteWhereUniqueInput
  }

  /**
   * CommentUpvote findFirst
   */
  export type CommentUpvoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentUpvote to fetch.
     */
    where?: CommentUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUpvotes to fetch.
     */
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentUpvotes.
     */
    cursor?: CommentUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentUpvotes.
     */
    distinct?: CommentUpvoteScalarFieldEnum | CommentUpvoteScalarFieldEnum[]
  }

  /**
   * CommentUpvote findFirstOrThrow
   */
  export type CommentUpvoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentUpvote to fetch.
     */
    where?: CommentUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUpvotes to fetch.
     */
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CommentUpvotes.
     */
    cursor?: CommentUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUpvotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CommentUpvotes.
     */
    distinct?: CommentUpvoteScalarFieldEnum | CommentUpvoteScalarFieldEnum[]
  }

  /**
   * CommentUpvote findMany
   */
  export type CommentUpvoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter, which CommentUpvotes to fetch.
     */
    where?: CommentUpvoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CommentUpvotes to fetch.
     */
    orderBy?: CommentUpvoteOrderByWithRelationInput | CommentUpvoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CommentUpvotes.
     */
    cursor?: CommentUpvoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CommentUpvotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CommentUpvotes.
     */
    skip?: number
    distinct?: CommentUpvoteScalarFieldEnum | CommentUpvoteScalarFieldEnum[]
  }

  /**
   * CommentUpvote create
   */
  export type CommentUpvoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * The data needed to create a CommentUpvote.
     */
    data: XOR<CommentUpvoteCreateInput, CommentUpvoteUncheckedCreateInput>
  }

  /**
   * CommentUpvote createMany
   */
  export type CommentUpvoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CommentUpvotes.
     */
    data: CommentUpvoteCreateManyInput | CommentUpvoteCreateManyInput[]
  }

  /**
   * CommentUpvote createManyAndReturn
   */
  export type CommentUpvoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CommentUpvotes.
     */
    data: CommentUpvoteCreateManyInput | CommentUpvoteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CommentUpvote update
   */
  export type CommentUpvoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * The data needed to update a CommentUpvote.
     */
    data: XOR<CommentUpvoteUpdateInput, CommentUpvoteUncheckedUpdateInput>
    /**
     * Choose, which CommentUpvote to update.
     */
    where: CommentUpvoteWhereUniqueInput
  }

  /**
   * CommentUpvote updateMany
   */
  export type CommentUpvoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CommentUpvotes.
     */
    data: XOR<CommentUpvoteUpdateManyMutationInput, CommentUpvoteUncheckedUpdateManyInput>
    /**
     * Filter which CommentUpvotes to update
     */
    where?: CommentUpvoteWhereInput
  }

  /**
   * CommentUpvote upsert
   */
  export type CommentUpvoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * The filter to search for the CommentUpvote to update in case it exists.
     */
    where: CommentUpvoteWhereUniqueInput
    /**
     * In case the CommentUpvote found by the `where` argument doesn't exist, create a new CommentUpvote with this data.
     */
    create: XOR<CommentUpvoteCreateInput, CommentUpvoteUncheckedCreateInput>
    /**
     * In case the CommentUpvote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CommentUpvoteUpdateInput, CommentUpvoteUncheckedUpdateInput>
  }

  /**
   * CommentUpvote delete
   */
  export type CommentUpvoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
    /**
     * Filter which CommentUpvote to delete.
     */
    where: CommentUpvoteWhereUniqueInput
  }

  /**
   * CommentUpvote deleteMany
   */
  export type CommentUpvoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CommentUpvotes to delete
     */
    where?: CommentUpvoteWhereInput
  }

  /**
   * CommentUpvote without action
   */
  export type CommentUpvoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CommentUpvote
     */
    select?: CommentUpvoteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CommentUpvoteInclude<ExtArgs> | null
  }


  /**
   * Model HealthArticle
   */

  export type AggregateHealthArticle = {
    _count: HealthArticleCountAggregateOutputType | null
    _avg: HealthArticleAvgAggregateOutputType | null
    _sum: HealthArticleSumAggregateOutputType | null
    _min: HealthArticleMinAggregateOutputType | null
    _max: HealthArticleMaxAggregateOutputType | null
  }

  export type HealthArticleAvgAggregateOutputType = {
    id: number | null
    authorId: number | null
    views: number | null
  }

  export type HealthArticleSumAggregateOutputType = {
    id: number | null
    authorId: number | null
    views: number | null
  }

  export type HealthArticleMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    authorId: number | null
    featuredImageUrl: string | null
    status: string | null
    views: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthArticleMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    title: string | null
    slug: string | null
    content: string | null
    category: string | null
    authorId: number | null
    featuredImageUrl: string | null
    status: string | null
    views: number | null
    publishedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type HealthArticleCountAggregateOutputType = {
    id: number
    uuid: number
    title: number
    slug: number
    content: number
    category: number
    authorId: number
    featuredImageUrl: number
    status: number
    views: number
    publishedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type HealthArticleAvgAggregateInputType = {
    id?: true
    authorId?: true
    views?: true
  }

  export type HealthArticleSumAggregateInputType = {
    id?: true
    authorId?: true
    views?: true
  }

  export type HealthArticleMinAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    authorId?: true
    featuredImageUrl?: true
    status?: true
    views?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthArticleMaxAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    authorId?: true
    featuredImageUrl?: true
    status?: true
    views?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type HealthArticleCountAggregateInputType = {
    id?: true
    uuid?: true
    title?: true
    slug?: true
    content?: true
    category?: true
    authorId?: true
    featuredImageUrl?: true
    status?: true
    views?: true
    publishedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type HealthArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthArticle to aggregate.
     */
    where?: HealthArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthArticles to fetch.
     */
    orderBy?: HealthArticleOrderByWithRelationInput | HealthArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HealthArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HealthArticles
    **/
    _count?: true | HealthArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HealthArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HealthArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HealthArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HealthArticleMaxAggregateInputType
  }

  export type GetHealthArticleAggregateType<T extends HealthArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateHealthArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHealthArticle[P]>
      : GetScalarType<T[P], AggregateHealthArticle[P]>
  }




  export type HealthArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HealthArticleWhereInput
    orderBy?: HealthArticleOrderByWithAggregationInput | HealthArticleOrderByWithAggregationInput[]
    by: HealthArticleScalarFieldEnum[] | HealthArticleScalarFieldEnum
    having?: HealthArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HealthArticleCountAggregateInputType | true
    _avg?: HealthArticleAvgAggregateInputType
    _sum?: HealthArticleSumAggregateInputType
    _min?: HealthArticleMinAggregateInputType
    _max?: HealthArticleMaxAggregateInputType
  }

  export type HealthArticleGroupByOutputType = {
    id: number
    uuid: string
    title: string
    slug: string
    content: string
    category: string
    authorId: number | null
    featuredImageUrl: string | null
    status: string
    views: number
    publishedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: HealthArticleCountAggregateOutputType | null
    _avg: HealthArticleAvgAggregateOutputType | null
    _sum: HealthArticleSumAggregateOutputType | null
    _min: HealthArticleMinAggregateOutputType | null
    _max: HealthArticleMaxAggregateOutputType | null
  }

  type GetHealthArticleGroupByPayload<T extends HealthArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HealthArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HealthArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HealthArticleGroupByOutputType[P]>
            : GetScalarType<T[P], HealthArticleGroupByOutputType[P]>
        }
      >
    >


  export type HealthArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    featuredImageUrl?: boolean
    status?: boolean
    views?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | HealthArticle$authorArgs<ExtArgs>
    comments?: boolean | HealthArticle$commentsArgs<ExtArgs>
    savedBy?: boolean | HealthArticle$savedByArgs<ExtArgs>
    _count?: boolean | HealthArticleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["healthArticle"]>

  export type HealthArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    featuredImageUrl?: boolean
    status?: boolean
    views?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    author?: boolean | HealthArticle$authorArgs<ExtArgs>
  }, ExtArgs["result"]["healthArticle"]>

  export type HealthArticleSelectScalar = {
    id?: boolean
    uuid?: boolean
    title?: boolean
    slug?: boolean
    content?: boolean
    category?: boolean
    authorId?: boolean
    featuredImageUrl?: boolean
    status?: boolean
    views?: boolean
    publishedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type HealthArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | HealthArticle$authorArgs<ExtArgs>
    comments?: boolean | HealthArticle$commentsArgs<ExtArgs>
    savedBy?: boolean | HealthArticle$savedByArgs<ExtArgs>
    _count?: boolean | HealthArticleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HealthArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    author?: boolean | HealthArticle$authorArgs<ExtArgs>
  }

  export type $HealthArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HealthArticle"
    objects: {
      author: Prisma.$UserPayload<ExtArgs> | null
      comments: Prisma.$ArticleCommentPayload<ExtArgs>[]
      savedBy: Prisma.$SavedArticlePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      title: string
      slug: string
      content: string
      category: string
      authorId: number | null
      featuredImageUrl: string | null
      status: string
      views: number
      publishedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["healthArticle"]>
    composites: {}
  }

  type HealthArticleGetPayload<S extends boolean | null | undefined | HealthArticleDefaultArgs> = $Result.GetResult<Prisma.$HealthArticlePayload, S>

  type HealthArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HealthArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HealthArticleCountAggregateInputType | true
    }

  export interface HealthArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HealthArticle'], meta: { name: 'HealthArticle' } }
    /**
     * Find zero or one HealthArticle that matches the filter.
     * @param {HealthArticleFindUniqueArgs} args - Arguments to find a HealthArticle
     * @example
     * // Get one HealthArticle
     * const healthArticle = await prisma.healthArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HealthArticleFindUniqueArgs>(args: SelectSubset<T, HealthArticleFindUniqueArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HealthArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HealthArticleFindUniqueOrThrowArgs} args - Arguments to find a HealthArticle
     * @example
     * // Get one HealthArticle
     * const healthArticle = await prisma.healthArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HealthArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, HealthArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HealthArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleFindFirstArgs} args - Arguments to find a HealthArticle
     * @example
     * // Get one HealthArticle
     * const healthArticle = await prisma.healthArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HealthArticleFindFirstArgs>(args?: SelectSubset<T, HealthArticleFindFirstArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HealthArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleFindFirstOrThrowArgs} args - Arguments to find a HealthArticle
     * @example
     * // Get one HealthArticle
     * const healthArticle = await prisma.healthArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HealthArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, HealthArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HealthArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HealthArticles
     * const healthArticles = await prisma.healthArticle.findMany()
     * 
     * // Get first 10 HealthArticles
     * const healthArticles = await prisma.healthArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const healthArticleWithIdOnly = await prisma.healthArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HealthArticleFindManyArgs>(args?: SelectSubset<T, HealthArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HealthArticle.
     * @param {HealthArticleCreateArgs} args - Arguments to create a HealthArticle.
     * @example
     * // Create one HealthArticle
     * const HealthArticle = await prisma.healthArticle.create({
     *   data: {
     *     // ... data to create a HealthArticle
     *   }
     * })
     * 
     */
    create<T extends HealthArticleCreateArgs>(args: SelectSubset<T, HealthArticleCreateArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HealthArticles.
     * @param {HealthArticleCreateManyArgs} args - Arguments to create many HealthArticles.
     * @example
     * // Create many HealthArticles
     * const healthArticle = await prisma.healthArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HealthArticleCreateManyArgs>(args?: SelectSubset<T, HealthArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HealthArticles and returns the data saved in the database.
     * @param {HealthArticleCreateManyAndReturnArgs} args - Arguments to create many HealthArticles.
     * @example
     * // Create many HealthArticles
     * const healthArticle = await prisma.healthArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HealthArticles and only return the `id`
     * const healthArticleWithIdOnly = await prisma.healthArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HealthArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, HealthArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HealthArticle.
     * @param {HealthArticleDeleteArgs} args - Arguments to delete one HealthArticle.
     * @example
     * // Delete one HealthArticle
     * const HealthArticle = await prisma.healthArticle.delete({
     *   where: {
     *     // ... filter to delete one HealthArticle
     *   }
     * })
     * 
     */
    delete<T extends HealthArticleDeleteArgs>(args: SelectSubset<T, HealthArticleDeleteArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HealthArticle.
     * @param {HealthArticleUpdateArgs} args - Arguments to update one HealthArticle.
     * @example
     * // Update one HealthArticle
     * const healthArticle = await prisma.healthArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HealthArticleUpdateArgs>(args: SelectSubset<T, HealthArticleUpdateArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HealthArticles.
     * @param {HealthArticleDeleteManyArgs} args - Arguments to filter HealthArticles to delete.
     * @example
     * // Delete a few HealthArticles
     * const { count } = await prisma.healthArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HealthArticleDeleteManyArgs>(args?: SelectSubset<T, HealthArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HealthArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HealthArticles
     * const healthArticle = await prisma.healthArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HealthArticleUpdateManyArgs>(args: SelectSubset<T, HealthArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HealthArticle.
     * @param {HealthArticleUpsertArgs} args - Arguments to update or create a HealthArticle.
     * @example
     * // Update or create a HealthArticle
     * const healthArticle = await prisma.healthArticle.upsert({
     *   create: {
     *     // ... data to create a HealthArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HealthArticle we want to update
     *   }
     * })
     */
    upsert<T extends HealthArticleUpsertArgs>(args: SelectSubset<T, HealthArticleUpsertArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HealthArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleCountArgs} args - Arguments to filter HealthArticles to count.
     * @example
     * // Count the number of HealthArticles
     * const count = await prisma.healthArticle.count({
     *   where: {
     *     // ... the filter for the HealthArticles we want to count
     *   }
     * })
    **/
    count<T extends HealthArticleCountArgs>(
      args?: Subset<T, HealthArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HealthArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HealthArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HealthArticleAggregateArgs>(args: Subset<T, HealthArticleAggregateArgs>): Prisma.PrismaPromise<GetHealthArticleAggregateType<T>>

    /**
     * Group by HealthArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HealthArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HealthArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HealthArticleGroupByArgs['orderBy'] }
        : { orderBy?: HealthArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HealthArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHealthArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HealthArticle model
   */
  readonly fields: HealthArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HealthArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HealthArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    author<T extends HealthArticle$authorArgs<ExtArgs> = {}>(args?: Subset<T, HealthArticle$authorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    comments<T extends HealthArticle$commentsArgs<ExtArgs> = {}>(args?: Subset<T, HealthArticle$commentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findMany"> | Null>
    savedBy<T extends HealthArticle$savedByArgs<ExtArgs> = {}>(args?: Subset<T, HealthArticle$savedByArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HealthArticle model
   */ 
  interface HealthArticleFieldRefs {
    readonly id: FieldRef<"HealthArticle", 'Int'>
    readonly uuid: FieldRef<"HealthArticle", 'String'>
    readonly title: FieldRef<"HealthArticle", 'String'>
    readonly slug: FieldRef<"HealthArticle", 'String'>
    readonly content: FieldRef<"HealthArticle", 'String'>
    readonly category: FieldRef<"HealthArticle", 'String'>
    readonly authorId: FieldRef<"HealthArticle", 'Int'>
    readonly featuredImageUrl: FieldRef<"HealthArticle", 'String'>
    readonly status: FieldRef<"HealthArticle", 'String'>
    readonly views: FieldRef<"HealthArticle", 'Int'>
    readonly publishedAt: FieldRef<"HealthArticle", 'DateTime'>
    readonly createdAt: FieldRef<"HealthArticle", 'DateTime'>
    readonly updatedAt: FieldRef<"HealthArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HealthArticle findUnique
   */
  export type HealthArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter, which HealthArticle to fetch.
     */
    where: HealthArticleWhereUniqueInput
  }

  /**
   * HealthArticle findUniqueOrThrow
   */
  export type HealthArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter, which HealthArticle to fetch.
     */
    where: HealthArticleWhereUniqueInput
  }

  /**
   * HealthArticle findFirst
   */
  export type HealthArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter, which HealthArticle to fetch.
     */
    where?: HealthArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthArticles to fetch.
     */
    orderBy?: HealthArticleOrderByWithRelationInput | HealthArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthArticles.
     */
    cursor?: HealthArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthArticles.
     */
    distinct?: HealthArticleScalarFieldEnum | HealthArticleScalarFieldEnum[]
  }

  /**
   * HealthArticle findFirstOrThrow
   */
  export type HealthArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter, which HealthArticle to fetch.
     */
    where?: HealthArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthArticles to fetch.
     */
    orderBy?: HealthArticleOrderByWithRelationInput | HealthArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HealthArticles.
     */
    cursor?: HealthArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HealthArticles.
     */
    distinct?: HealthArticleScalarFieldEnum | HealthArticleScalarFieldEnum[]
  }

  /**
   * HealthArticle findMany
   */
  export type HealthArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter, which HealthArticles to fetch.
     */
    where?: HealthArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HealthArticles to fetch.
     */
    orderBy?: HealthArticleOrderByWithRelationInput | HealthArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HealthArticles.
     */
    cursor?: HealthArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HealthArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HealthArticles.
     */
    skip?: number
    distinct?: HealthArticleScalarFieldEnum | HealthArticleScalarFieldEnum[]
  }

  /**
   * HealthArticle create
   */
  export type HealthArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a HealthArticle.
     */
    data: XOR<HealthArticleCreateInput, HealthArticleUncheckedCreateInput>
  }

  /**
   * HealthArticle createMany
   */
  export type HealthArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HealthArticles.
     */
    data: HealthArticleCreateManyInput | HealthArticleCreateManyInput[]
  }

  /**
   * HealthArticle createManyAndReturn
   */
  export type HealthArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HealthArticles.
     */
    data: HealthArticleCreateManyInput | HealthArticleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HealthArticle update
   */
  export type HealthArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a HealthArticle.
     */
    data: XOR<HealthArticleUpdateInput, HealthArticleUncheckedUpdateInput>
    /**
     * Choose, which HealthArticle to update.
     */
    where: HealthArticleWhereUniqueInput
  }

  /**
   * HealthArticle updateMany
   */
  export type HealthArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HealthArticles.
     */
    data: XOR<HealthArticleUpdateManyMutationInput, HealthArticleUncheckedUpdateManyInput>
    /**
     * Filter which HealthArticles to update
     */
    where?: HealthArticleWhereInput
  }

  /**
   * HealthArticle upsert
   */
  export type HealthArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the HealthArticle to update in case it exists.
     */
    where: HealthArticleWhereUniqueInput
    /**
     * In case the HealthArticle found by the `where` argument doesn't exist, create a new HealthArticle with this data.
     */
    create: XOR<HealthArticleCreateInput, HealthArticleUncheckedCreateInput>
    /**
     * In case the HealthArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HealthArticleUpdateInput, HealthArticleUncheckedUpdateInput>
  }

  /**
   * HealthArticle delete
   */
  export type HealthArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
    /**
     * Filter which HealthArticle to delete.
     */
    where: HealthArticleWhereUniqueInput
  }

  /**
   * HealthArticle deleteMany
   */
  export type HealthArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HealthArticles to delete
     */
    where?: HealthArticleWhereInput
  }

  /**
   * HealthArticle.author
   */
  export type HealthArticle$authorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * HealthArticle.comments
   */
  export type HealthArticle$commentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    where?: ArticleCommentWhereInput
    orderBy?: ArticleCommentOrderByWithRelationInput | ArticleCommentOrderByWithRelationInput[]
    cursor?: ArticleCommentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ArticleCommentScalarFieldEnum | ArticleCommentScalarFieldEnum[]
  }

  /**
   * HealthArticle.savedBy
   */
  export type HealthArticle$savedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    where?: SavedArticleWhereInput
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    cursor?: SavedArticleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SavedArticleScalarFieldEnum | SavedArticleScalarFieldEnum[]
  }

  /**
   * HealthArticle without action
   */
  export type HealthArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HealthArticle
     */
    select?: HealthArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HealthArticleInclude<ExtArgs> | null
  }


  /**
   * Model ArticleComment
   */

  export type AggregateArticleComment = {
    _count: ArticleCommentCountAggregateOutputType | null
    _avg: ArticleCommentAvgAggregateOutputType | null
    _sum: ArticleCommentSumAggregateOutputType | null
    _min: ArticleCommentMinAggregateOutputType | null
    _max: ArticleCommentMaxAggregateOutputType | null
  }

  export type ArticleCommentAvgAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: number | null
    upvotes: number | null
  }

  export type ArticleCommentSumAggregateOutputType = {
    id: number | null
    articleId: number | null
    userId: number | null
    upvotes: number | null
  }

  export type ArticleCommentMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    articleId: number | null
    userId: number | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
  }

  export type ArticleCommentMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    articleId: number | null
    userId: number | null
    content: string | null
    upvotes: number | null
    createdAt: Date | null
  }

  export type ArticleCommentCountAggregateOutputType = {
    id: number
    uuid: number
    articleId: number
    userId: number
    content: number
    upvotes: number
    createdAt: number
    _all: number
  }


  export type ArticleCommentAvgAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    upvotes?: true
  }

  export type ArticleCommentSumAggregateInputType = {
    id?: true
    articleId?: true
    userId?: true
    upvotes?: true
  }

  export type ArticleCommentMinAggregateInputType = {
    id?: true
    uuid?: true
    articleId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
  }

  export type ArticleCommentMaxAggregateInputType = {
    id?: true
    uuid?: true
    articleId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
  }

  export type ArticleCommentCountAggregateInputType = {
    id?: true
    uuid?: true
    articleId?: true
    userId?: true
    content?: true
    upvotes?: true
    createdAt?: true
    _all?: true
  }

  export type ArticleCommentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleComment to aggregate.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: ArticleCommentOrderByWithRelationInput | ArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ArticleComments
    **/
    _count?: true | ArticleCommentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ArticleCommentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ArticleCommentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ArticleCommentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ArticleCommentMaxAggregateInputType
  }

  export type GetArticleCommentAggregateType<T extends ArticleCommentAggregateArgs> = {
        [P in keyof T & keyof AggregateArticleComment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateArticleComment[P]>
      : GetScalarType<T[P], AggregateArticleComment[P]>
  }




  export type ArticleCommentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ArticleCommentWhereInput
    orderBy?: ArticleCommentOrderByWithAggregationInput | ArticleCommentOrderByWithAggregationInput[]
    by: ArticleCommentScalarFieldEnum[] | ArticleCommentScalarFieldEnum
    having?: ArticleCommentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ArticleCommentCountAggregateInputType | true
    _avg?: ArticleCommentAvgAggregateInputType
    _sum?: ArticleCommentSumAggregateInputType
    _min?: ArticleCommentMinAggregateInputType
    _max?: ArticleCommentMaxAggregateInputType
  }

  export type ArticleCommentGroupByOutputType = {
    id: number
    uuid: string
    articleId: number
    userId: number
    content: string
    upvotes: number
    createdAt: Date
    _count: ArticleCommentCountAggregateOutputType | null
    _avg: ArticleCommentAvgAggregateOutputType | null
    _sum: ArticleCommentSumAggregateOutputType | null
    _min: ArticleCommentMinAggregateOutputType | null
    _max: ArticleCommentMaxAggregateOutputType | null
  }

  type GetArticleCommentGroupByPayload<T extends ArticleCommentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ArticleCommentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ArticleCommentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ArticleCommentGroupByOutputType[P]>
            : GetScalarType<T[P], ArticleCommentGroupByOutputType[P]>
        }
      >
    >


  export type ArticleCommentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    upvotes?: boolean
    createdAt?: boolean
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleComment"]>

  export type ArticleCommentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    upvotes?: boolean
    createdAt?: boolean
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["articleComment"]>

  export type ArticleCommentSelectScalar = {
    id?: boolean
    uuid?: boolean
    articleId?: boolean
    userId?: boolean
    content?: boolean
    upvotes?: boolean
    createdAt?: boolean
  }

  export type ArticleCommentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }
  export type ArticleCommentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }

  export type $ArticleCommentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ArticleComment"
    objects: {
      article: Prisma.$HealthArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      articleId: number
      userId: number
      content: string
      upvotes: number
      createdAt: Date
    }, ExtArgs["result"]["articleComment"]>
    composites: {}
  }

  type ArticleCommentGetPayload<S extends boolean | null | undefined | ArticleCommentDefaultArgs> = $Result.GetResult<Prisma.$ArticleCommentPayload, S>

  type ArticleCommentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ArticleCommentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ArticleCommentCountAggregateInputType | true
    }

  export interface ArticleCommentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ArticleComment'], meta: { name: 'ArticleComment' } }
    /**
     * Find zero or one ArticleComment that matches the filter.
     * @param {ArticleCommentFindUniqueArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ArticleCommentFindUniqueArgs>(args: SelectSubset<T, ArticleCommentFindUniqueArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ArticleComment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ArticleCommentFindUniqueOrThrowArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ArticleCommentFindUniqueOrThrowArgs>(args: SelectSubset<T, ArticleCommentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ArticleComment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindFirstArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ArticleCommentFindFirstArgs>(args?: SelectSubset<T, ArticleCommentFindFirstArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ArticleComment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindFirstOrThrowArgs} args - Arguments to find a ArticleComment
     * @example
     * // Get one ArticleComment
     * const articleComment = await prisma.articleComment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ArticleCommentFindFirstOrThrowArgs>(args?: SelectSubset<T, ArticleCommentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ArticleComments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ArticleComments
     * const articleComments = await prisma.articleComment.findMany()
     * 
     * // Get first 10 ArticleComments
     * const articleComments = await prisma.articleComment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const articleCommentWithIdOnly = await prisma.articleComment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ArticleCommentFindManyArgs>(args?: SelectSubset<T, ArticleCommentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ArticleComment.
     * @param {ArticleCommentCreateArgs} args - Arguments to create a ArticleComment.
     * @example
     * // Create one ArticleComment
     * const ArticleComment = await prisma.articleComment.create({
     *   data: {
     *     // ... data to create a ArticleComment
     *   }
     * })
     * 
     */
    create<T extends ArticleCommentCreateArgs>(args: SelectSubset<T, ArticleCommentCreateArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ArticleComments.
     * @param {ArticleCommentCreateManyArgs} args - Arguments to create many ArticleComments.
     * @example
     * // Create many ArticleComments
     * const articleComment = await prisma.articleComment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ArticleCommentCreateManyArgs>(args?: SelectSubset<T, ArticleCommentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ArticleComments and returns the data saved in the database.
     * @param {ArticleCommentCreateManyAndReturnArgs} args - Arguments to create many ArticleComments.
     * @example
     * // Create many ArticleComments
     * const articleComment = await prisma.articleComment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ArticleComments and only return the `id`
     * const articleCommentWithIdOnly = await prisma.articleComment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ArticleCommentCreateManyAndReturnArgs>(args?: SelectSubset<T, ArticleCommentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ArticleComment.
     * @param {ArticleCommentDeleteArgs} args - Arguments to delete one ArticleComment.
     * @example
     * // Delete one ArticleComment
     * const ArticleComment = await prisma.articleComment.delete({
     *   where: {
     *     // ... filter to delete one ArticleComment
     *   }
     * })
     * 
     */
    delete<T extends ArticleCommentDeleteArgs>(args: SelectSubset<T, ArticleCommentDeleteArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ArticleComment.
     * @param {ArticleCommentUpdateArgs} args - Arguments to update one ArticleComment.
     * @example
     * // Update one ArticleComment
     * const articleComment = await prisma.articleComment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ArticleCommentUpdateArgs>(args: SelectSubset<T, ArticleCommentUpdateArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ArticleComments.
     * @param {ArticleCommentDeleteManyArgs} args - Arguments to filter ArticleComments to delete.
     * @example
     * // Delete a few ArticleComments
     * const { count } = await prisma.articleComment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ArticleCommentDeleteManyArgs>(args?: SelectSubset<T, ArticleCommentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ArticleComments
     * const articleComment = await prisma.articleComment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ArticleCommentUpdateManyArgs>(args: SelectSubset<T, ArticleCommentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ArticleComment.
     * @param {ArticleCommentUpsertArgs} args - Arguments to update or create a ArticleComment.
     * @example
     * // Update or create a ArticleComment
     * const articleComment = await prisma.articleComment.upsert({
     *   create: {
     *     // ... data to create a ArticleComment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ArticleComment we want to update
     *   }
     * })
     */
    upsert<T extends ArticleCommentUpsertArgs>(args: SelectSubset<T, ArticleCommentUpsertArgs<ExtArgs>>): Prisma__ArticleCommentClient<$Result.GetResult<Prisma.$ArticleCommentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ArticleComments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentCountArgs} args - Arguments to filter ArticleComments to count.
     * @example
     * // Count the number of ArticleComments
     * const count = await prisma.articleComment.count({
     *   where: {
     *     // ... the filter for the ArticleComments we want to count
     *   }
     * })
    **/
    count<T extends ArticleCommentCountArgs>(
      args?: Subset<T, ArticleCommentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ArticleCommentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ArticleCommentAggregateArgs>(args: Subset<T, ArticleCommentAggregateArgs>): Prisma.PrismaPromise<GetArticleCommentAggregateType<T>>

    /**
     * Group by ArticleComment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ArticleCommentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ArticleCommentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ArticleCommentGroupByArgs['orderBy'] }
        : { orderBy?: ArticleCommentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ArticleCommentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetArticleCommentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ArticleComment model
   */
  readonly fields: ArticleCommentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ArticleComment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ArticleCommentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    article<T extends HealthArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthArticleDefaultArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ArticleComment model
   */ 
  interface ArticleCommentFieldRefs {
    readonly id: FieldRef<"ArticleComment", 'Int'>
    readonly uuid: FieldRef<"ArticleComment", 'String'>
    readonly articleId: FieldRef<"ArticleComment", 'Int'>
    readonly userId: FieldRef<"ArticleComment", 'Int'>
    readonly content: FieldRef<"ArticleComment", 'String'>
    readonly upvotes: FieldRef<"ArticleComment", 'Int'>
    readonly createdAt: FieldRef<"ArticleComment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ArticleComment findUnique
   */
  export type ArticleCommentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where: ArticleCommentWhereUniqueInput
  }

  /**
   * ArticleComment findUniqueOrThrow
   */
  export type ArticleCommentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where: ArticleCommentWhereUniqueInput
  }

  /**
   * ArticleComment findFirst
   */
  export type ArticleCommentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: ArticleCommentOrderByWithRelationInput | ArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleComments.
     */
    distinct?: ArticleCommentScalarFieldEnum | ArticleCommentScalarFieldEnum[]
  }

  /**
   * ArticleComment findFirstOrThrow
   */
  export type ArticleCommentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which ArticleComment to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: ArticleCommentOrderByWithRelationInput | ArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ArticleComments.
     */
    distinct?: ArticleCommentScalarFieldEnum | ArticleCommentScalarFieldEnum[]
  }

  /**
   * ArticleComment findMany
   */
  export type ArticleCommentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter, which ArticleComments to fetch.
     */
    where?: ArticleCommentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ArticleComments to fetch.
     */
    orderBy?: ArticleCommentOrderByWithRelationInput | ArticleCommentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ArticleComments.
     */
    cursor?: ArticleCommentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ArticleComments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ArticleComments.
     */
    skip?: number
    distinct?: ArticleCommentScalarFieldEnum | ArticleCommentScalarFieldEnum[]
  }

  /**
   * ArticleComment create
   */
  export type ArticleCommentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * The data needed to create a ArticleComment.
     */
    data: XOR<ArticleCommentCreateInput, ArticleCommentUncheckedCreateInput>
  }

  /**
   * ArticleComment createMany
   */
  export type ArticleCommentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ArticleComments.
     */
    data: ArticleCommentCreateManyInput | ArticleCommentCreateManyInput[]
  }

  /**
   * ArticleComment createManyAndReturn
   */
  export type ArticleCommentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ArticleComments.
     */
    data: ArticleCommentCreateManyInput | ArticleCommentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ArticleComment update
   */
  export type ArticleCommentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * The data needed to update a ArticleComment.
     */
    data: XOR<ArticleCommentUpdateInput, ArticleCommentUncheckedUpdateInput>
    /**
     * Choose, which ArticleComment to update.
     */
    where: ArticleCommentWhereUniqueInput
  }

  /**
   * ArticleComment updateMany
   */
  export type ArticleCommentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ArticleComments.
     */
    data: XOR<ArticleCommentUpdateManyMutationInput, ArticleCommentUncheckedUpdateManyInput>
    /**
     * Filter which ArticleComments to update
     */
    where?: ArticleCommentWhereInput
  }

  /**
   * ArticleComment upsert
   */
  export type ArticleCommentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * The filter to search for the ArticleComment to update in case it exists.
     */
    where: ArticleCommentWhereUniqueInput
    /**
     * In case the ArticleComment found by the `where` argument doesn't exist, create a new ArticleComment with this data.
     */
    create: XOR<ArticleCommentCreateInput, ArticleCommentUncheckedCreateInput>
    /**
     * In case the ArticleComment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ArticleCommentUpdateInput, ArticleCommentUncheckedUpdateInput>
  }

  /**
   * ArticleComment delete
   */
  export type ArticleCommentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
    /**
     * Filter which ArticleComment to delete.
     */
    where: ArticleCommentWhereUniqueInput
  }

  /**
   * ArticleComment deleteMany
   */
  export type ArticleCommentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ArticleComments to delete
     */
    where?: ArticleCommentWhereInput
  }

  /**
   * ArticleComment without action
   */
  export type ArticleCommentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ArticleComment
     */
    select?: ArticleCommentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ArticleCommentInclude<ExtArgs> | null
  }


  /**
   * Model SavedArticle
   */

  export type AggregateSavedArticle = {
    _count: SavedArticleCountAggregateOutputType | null
    _avg: SavedArticleAvgAggregateOutputType | null
    _sum: SavedArticleSumAggregateOutputType | null
    _min: SavedArticleMinAggregateOutputType | null
    _max: SavedArticleMaxAggregateOutputType | null
  }

  export type SavedArticleAvgAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
  }

  export type SavedArticleSumAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
  }

  export type SavedArticleMinAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
    savedAt: Date | null
  }

  export type SavedArticleMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    articleId: number | null
    savedAt: Date | null
  }

  export type SavedArticleCountAggregateOutputType = {
    id: number
    userId: number
    articleId: number
    savedAt: number
    _all: number
  }


  export type SavedArticleAvgAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
  }

  export type SavedArticleSumAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
  }

  export type SavedArticleMinAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    savedAt?: true
  }

  export type SavedArticleMaxAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    savedAt?: true
  }

  export type SavedArticleCountAggregateInputType = {
    id?: true
    userId?: true
    articleId?: true
    savedAt?: true
    _all?: true
  }

  export type SavedArticleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedArticle to aggregate.
     */
    where?: SavedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedArticles to fetch.
     */
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SavedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SavedArticles
    **/
    _count?: true | SavedArticleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SavedArticleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SavedArticleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SavedArticleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SavedArticleMaxAggregateInputType
  }

  export type GetSavedArticleAggregateType<T extends SavedArticleAggregateArgs> = {
        [P in keyof T & keyof AggregateSavedArticle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSavedArticle[P]>
      : GetScalarType<T[P], AggregateSavedArticle[P]>
  }




  export type SavedArticleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SavedArticleWhereInput
    orderBy?: SavedArticleOrderByWithAggregationInput | SavedArticleOrderByWithAggregationInput[]
    by: SavedArticleScalarFieldEnum[] | SavedArticleScalarFieldEnum
    having?: SavedArticleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SavedArticleCountAggregateInputType | true
    _avg?: SavedArticleAvgAggregateInputType
    _sum?: SavedArticleSumAggregateInputType
    _min?: SavedArticleMinAggregateInputType
    _max?: SavedArticleMaxAggregateInputType
  }

  export type SavedArticleGroupByOutputType = {
    id: number
    userId: number
    articleId: number
    savedAt: Date
    _count: SavedArticleCountAggregateOutputType | null
    _avg: SavedArticleAvgAggregateOutputType | null
    _sum: SavedArticleSumAggregateOutputType | null
    _min: SavedArticleMinAggregateOutputType | null
    _max: SavedArticleMaxAggregateOutputType | null
  }

  type GetSavedArticleGroupByPayload<T extends SavedArticleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SavedArticleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SavedArticleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SavedArticleGroupByOutputType[P]>
            : GetScalarType<T[P], SavedArticleGroupByOutputType[P]>
        }
      >
    >


  export type SavedArticleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    articleId?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedArticle"]>

  export type SavedArticleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    articleId?: boolean
    savedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["savedArticle"]>

  export type SavedArticleSelectScalar = {
    id?: boolean
    userId?: boolean
    articleId?: boolean
    savedAt?: boolean
  }

  export type SavedArticleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }
  export type SavedArticleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    article?: boolean | HealthArticleDefaultArgs<ExtArgs>
  }

  export type $SavedArticlePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SavedArticle"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      article: Prisma.$HealthArticlePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      articleId: number
      savedAt: Date
    }, ExtArgs["result"]["savedArticle"]>
    composites: {}
  }

  type SavedArticleGetPayload<S extends boolean | null | undefined | SavedArticleDefaultArgs> = $Result.GetResult<Prisma.$SavedArticlePayload, S>

  type SavedArticleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SavedArticleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SavedArticleCountAggregateInputType | true
    }

  export interface SavedArticleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SavedArticle'], meta: { name: 'SavedArticle' } }
    /**
     * Find zero or one SavedArticle that matches the filter.
     * @param {SavedArticleFindUniqueArgs} args - Arguments to find a SavedArticle
     * @example
     * // Get one SavedArticle
     * const savedArticle = await prisma.savedArticle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SavedArticleFindUniqueArgs>(args: SelectSubset<T, SavedArticleFindUniqueArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SavedArticle that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SavedArticleFindUniqueOrThrowArgs} args - Arguments to find a SavedArticle
     * @example
     * // Get one SavedArticle
     * const savedArticle = await prisma.savedArticle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SavedArticleFindUniqueOrThrowArgs>(args: SelectSubset<T, SavedArticleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SavedArticle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleFindFirstArgs} args - Arguments to find a SavedArticle
     * @example
     * // Get one SavedArticle
     * const savedArticle = await prisma.savedArticle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SavedArticleFindFirstArgs>(args?: SelectSubset<T, SavedArticleFindFirstArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SavedArticle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleFindFirstOrThrowArgs} args - Arguments to find a SavedArticle
     * @example
     * // Get one SavedArticle
     * const savedArticle = await prisma.savedArticle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SavedArticleFindFirstOrThrowArgs>(args?: SelectSubset<T, SavedArticleFindFirstOrThrowArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SavedArticles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SavedArticles
     * const savedArticles = await prisma.savedArticle.findMany()
     * 
     * // Get first 10 SavedArticles
     * const savedArticles = await prisma.savedArticle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const savedArticleWithIdOnly = await prisma.savedArticle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SavedArticleFindManyArgs>(args?: SelectSubset<T, SavedArticleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SavedArticle.
     * @param {SavedArticleCreateArgs} args - Arguments to create a SavedArticle.
     * @example
     * // Create one SavedArticle
     * const SavedArticle = await prisma.savedArticle.create({
     *   data: {
     *     // ... data to create a SavedArticle
     *   }
     * })
     * 
     */
    create<T extends SavedArticleCreateArgs>(args: SelectSubset<T, SavedArticleCreateArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SavedArticles.
     * @param {SavedArticleCreateManyArgs} args - Arguments to create many SavedArticles.
     * @example
     * // Create many SavedArticles
     * const savedArticle = await prisma.savedArticle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SavedArticleCreateManyArgs>(args?: SelectSubset<T, SavedArticleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SavedArticles and returns the data saved in the database.
     * @param {SavedArticleCreateManyAndReturnArgs} args - Arguments to create many SavedArticles.
     * @example
     * // Create many SavedArticles
     * const savedArticle = await prisma.savedArticle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SavedArticles and only return the `id`
     * const savedArticleWithIdOnly = await prisma.savedArticle.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SavedArticleCreateManyAndReturnArgs>(args?: SelectSubset<T, SavedArticleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SavedArticle.
     * @param {SavedArticleDeleteArgs} args - Arguments to delete one SavedArticle.
     * @example
     * // Delete one SavedArticle
     * const SavedArticle = await prisma.savedArticle.delete({
     *   where: {
     *     // ... filter to delete one SavedArticle
     *   }
     * })
     * 
     */
    delete<T extends SavedArticleDeleteArgs>(args: SelectSubset<T, SavedArticleDeleteArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SavedArticle.
     * @param {SavedArticleUpdateArgs} args - Arguments to update one SavedArticle.
     * @example
     * // Update one SavedArticle
     * const savedArticle = await prisma.savedArticle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SavedArticleUpdateArgs>(args: SelectSubset<T, SavedArticleUpdateArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SavedArticles.
     * @param {SavedArticleDeleteManyArgs} args - Arguments to filter SavedArticles to delete.
     * @example
     * // Delete a few SavedArticles
     * const { count } = await prisma.savedArticle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SavedArticleDeleteManyArgs>(args?: SelectSubset<T, SavedArticleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SavedArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SavedArticles
     * const savedArticle = await prisma.savedArticle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SavedArticleUpdateManyArgs>(args: SelectSubset<T, SavedArticleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SavedArticle.
     * @param {SavedArticleUpsertArgs} args - Arguments to update or create a SavedArticle.
     * @example
     * // Update or create a SavedArticle
     * const savedArticle = await prisma.savedArticle.upsert({
     *   create: {
     *     // ... data to create a SavedArticle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SavedArticle we want to update
     *   }
     * })
     */
    upsert<T extends SavedArticleUpsertArgs>(args: SelectSubset<T, SavedArticleUpsertArgs<ExtArgs>>): Prisma__SavedArticleClient<$Result.GetResult<Prisma.$SavedArticlePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SavedArticles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleCountArgs} args - Arguments to filter SavedArticles to count.
     * @example
     * // Count the number of SavedArticles
     * const count = await prisma.savedArticle.count({
     *   where: {
     *     // ... the filter for the SavedArticles we want to count
     *   }
     * })
    **/
    count<T extends SavedArticleCountArgs>(
      args?: Subset<T, SavedArticleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SavedArticleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SavedArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SavedArticleAggregateArgs>(args: Subset<T, SavedArticleAggregateArgs>): Prisma.PrismaPromise<GetSavedArticleAggregateType<T>>

    /**
     * Group by SavedArticle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SavedArticleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SavedArticleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SavedArticleGroupByArgs['orderBy'] }
        : { orderBy?: SavedArticleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SavedArticleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSavedArticleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SavedArticle model
   */
  readonly fields: SavedArticleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SavedArticle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SavedArticleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    article<T extends HealthArticleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HealthArticleDefaultArgs<ExtArgs>>): Prisma__HealthArticleClient<$Result.GetResult<Prisma.$HealthArticlePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SavedArticle model
   */ 
  interface SavedArticleFieldRefs {
    readonly id: FieldRef<"SavedArticle", 'Int'>
    readonly userId: FieldRef<"SavedArticle", 'Int'>
    readonly articleId: FieldRef<"SavedArticle", 'Int'>
    readonly savedAt: FieldRef<"SavedArticle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SavedArticle findUnique
   */
  export type SavedArticleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter, which SavedArticle to fetch.
     */
    where: SavedArticleWhereUniqueInput
  }

  /**
   * SavedArticle findUniqueOrThrow
   */
  export type SavedArticleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter, which SavedArticle to fetch.
     */
    where: SavedArticleWhereUniqueInput
  }

  /**
   * SavedArticle findFirst
   */
  export type SavedArticleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter, which SavedArticle to fetch.
     */
    where?: SavedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedArticles to fetch.
     */
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedArticles.
     */
    cursor?: SavedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedArticles.
     */
    distinct?: SavedArticleScalarFieldEnum | SavedArticleScalarFieldEnum[]
  }

  /**
   * SavedArticle findFirstOrThrow
   */
  export type SavedArticleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter, which SavedArticle to fetch.
     */
    where?: SavedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedArticles to fetch.
     */
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SavedArticles.
     */
    cursor?: SavedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedArticles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SavedArticles.
     */
    distinct?: SavedArticleScalarFieldEnum | SavedArticleScalarFieldEnum[]
  }

  /**
   * SavedArticle findMany
   */
  export type SavedArticleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter, which SavedArticles to fetch.
     */
    where?: SavedArticleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SavedArticles to fetch.
     */
    orderBy?: SavedArticleOrderByWithRelationInput | SavedArticleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SavedArticles.
     */
    cursor?: SavedArticleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SavedArticles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SavedArticles.
     */
    skip?: number
    distinct?: SavedArticleScalarFieldEnum | SavedArticleScalarFieldEnum[]
  }

  /**
   * SavedArticle create
   */
  export type SavedArticleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * The data needed to create a SavedArticle.
     */
    data: XOR<SavedArticleCreateInput, SavedArticleUncheckedCreateInput>
  }

  /**
   * SavedArticle createMany
   */
  export type SavedArticleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SavedArticles.
     */
    data: SavedArticleCreateManyInput | SavedArticleCreateManyInput[]
  }

  /**
   * SavedArticle createManyAndReturn
   */
  export type SavedArticleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SavedArticles.
     */
    data: SavedArticleCreateManyInput | SavedArticleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SavedArticle update
   */
  export type SavedArticleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * The data needed to update a SavedArticle.
     */
    data: XOR<SavedArticleUpdateInput, SavedArticleUncheckedUpdateInput>
    /**
     * Choose, which SavedArticle to update.
     */
    where: SavedArticleWhereUniqueInput
  }

  /**
   * SavedArticle updateMany
   */
  export type SavedArticleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SavedArticles.
     */
    data: XOR<SavedArticleUpdateManyMutationInput, SavedArticleUncheckedUpdateManyInput>
    /**
     * Filter which SavedArticles to update
     */
    where?: SavedArticleWhereInput
  }

  /**
   * SavedArticle upsert
   */
  export type SavedArticleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * The filter to search for the SavedArticle to update in case it exists.
     */
    where: SavedArticleWhereUniqueInput
    /**
     * In case the SavedArticle found by the `where` argument doesn't exist, create a new SavedArticle with this data.
     */
    create: XOR<SavedArticleCreateInput, SavedArticleUncheckedCreateInput>
    /**
     * In case the SavedArticle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SavedArticleUpdateInput, SavedArticleUncheckedUpdateInput>
  }

  /**
   * SavedArticle delete
   */
  export type SavedArticleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
    /**
     * Filter which SavedArticle to delete.
     */
    where: SavedArticleWhereUniqueInput
  }

  /**
   * SavedArticle deleteMany
   */
  export type SavedArticleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SavedArticles to delete
     */
    where?: SavedArticleWhereInput
  }

  /**
   * SavedArticle without action
   */
  export type SavedArticleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SavedArticle
     */
    select?: SavedArticleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SavedArticleInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    type: string | null
    title: string | null
    message: string | null
    data: string | null
    read: boolean | null
    actionUrl: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    type: number
    title: number
    message: number
    data: number
    read: number
    actionUrl: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    read?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    read?: true
    actionUrl?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    type?: true
    title?: true
    message?: true
    data?: true
    read?: true
    actionUrl?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    type: string
    title: string
    message: string
    data: string | null
    read: boolean
    actionUrl: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    data?: boolean
    read?: boolean
    actionUrl?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      type: string
      title: string
      message: string
      data: string | null
      read: boolean
      actionUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly uuid: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly actionUrl: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SymptomCheckSession
   */

  export type AggregateSymptomCheckSession = {
    _count: SymptomCheckSessionCountAggregateOutputType | null
    _avg: SymptomCheckSessionAvgAggregateOutputType | null
    _sum: SymptomCheckSessionSumAggregateOutputType | null
    _min: SymptomCheckSessionMinAggregateOutputType | null
    _max: SymptomCheckSessionMaxAggregateOutputType | null
  }

  export type SymptomCheckSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SymptomCheckSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type SymptomCheckSessionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    conversation: string | null
    result: string | null
    riskLevel: string | null
    createdAt: Date | null
  }

  export type SymptomCheckSessionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    conversation: string | null
    result: string | null
    riskLevel: string | null
    createdAt: Date | null
  }

  export type SymptomCheckSessionCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    conversation: number
    result: number
    riskLevel: number
    createdAt: number
    _all: number
  }


  export type SymptomCheckSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SymptomCheckSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type SymptomCheckSessionMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    result?: true
    riskLevel?: true
    createdAt?: true
  }

  export type SymptomCheckSessionMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    result?: true
    riskLevel?: true
    createdAt?: true
  }

  export type SymptomCheckSessionCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    result?: true
    riskLevel?: true
    createdAt?: true
    _all?: true
  }

  export type SymptomCheckSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymptomCheckSession to aggregate.
     */
    where?: SymptomCheckSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomCheckSessions to fetch.
     */
    orderBy?: SymptomCheckSessionOrderByWithRelationInput | SymptomCheckSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SymptomCheckSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomCheckSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomCheckSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SymptomCheckSessions
    **/
    _count?: true | SymptomCheckSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SymptomCheckSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SymptomCheckSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SymptomCheckSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SymptomCheckSessionMaxAggregateInputType
  }

  export type GetSymptomCheckSessionAggregateType<T extends SymptomCheckSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSymptomCheckSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSymptomCheckSession[P]>
      : GetScalarType<T[P], AggregateSymptomCheckSession[P]>
  }




  export type SymptomCheckSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SymptomCheckSessionWhereInput
    orderBy?: SymptomCheckSessionOrderByWithAggregationInput | SymptomCheckSessionOrderByWithAggregationInput[]
    by: SymptomCheckSessionScalarFieldEnum[] | SymptomCheckSessionScalarFieldEnum
    having?: SymptomCheckSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SymptomCheckSessionCountAggregateInputType | true
    _avg?: SymptomCheckSessionAvgAggregateInputType
    _sum?: SymptomCheckSessionSumAggregateInputType
    _min?: SymptomCheckSessionMinAggregateInputType
    _max?: SymptomCheckSessionMaxAggregateInputType
  }

  export type SymptomCheckSessionGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    conversation: string
    result: string | null
    riskLevel: string | null
    createdAt: Date
    _count: SymptomCheckSessionCountAggregateOutputType | null
    _avg: SymptomCheckSessionAvgAggregateOutputType | null
    _sum: SymptomCheckSessionSumAggregateOutputType | null
    _min: SymptomCheckSessionMinAggregateOutputType | null
    _max: SymptomCheckSessionMaxAggregateOutputType | null
  }

  type GetSymptomCheckSessionGroupByPayload<T extends SymptomCheckSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SymptomCheckSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SymptomCheckSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SymptomCheckSessionGroupByOutputType[P]>
            : GetScalarType<T[P], SymptomCheckSessionGroupByOutputType[P]>
        }
      >
    >


  export type SymptomCheckSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    result?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptomCheckSession"]>

  export type SymptomCheckSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    result?: boolean
    riskLevel?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["symptomCheckSession"]>

  export type SymptomCheckSessionSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    result?: boolean
    riskLevel?: boolean
    createdAt?: boolean
  }

  export type SymptomCheckSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SymptomCheckSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SymptomCheckSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SymptomCheckSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      conversation: string
      result: string | null
      riskLevel: string | null
      createdAt: Date
    }, ExtArgs["result"]["symptomCheckSession"]>
    composites: {}
  }

  type SymptomCheckSessionGetPayload<S extends boolean | null | undefined | SymptomCheckSessionDefaultArgs> = $Result.GetResult<Prisma.$SymptomCheckSessionPayload, S>

  type SymptomCheckSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SymptomCheckSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SymptomCheckSessionCountAggregateInputType | true
    }

  export interface SymptomCheckSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SymptomCheckSession'], meta: { name: 'SymptomCheckSession' } }
    /**
     * Find zero or one SymptomCheckSession that matches the filter.
     * @param {SymptomCheckSessionFindUniqueArgs} args - Arguments to find a SymptomCheckSession
     * @example
     * // Get one SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SymptomCheckSessionFindUniqueArgs>(args: SelectSubset<T, SymptomCheckSessionFindUniqueArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SymptomCheckSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SymptomCheckSessionFindUniqueOrThrowArgs} args - Arguments to find a SymptomCheckSession
     * @example
     * // Get one SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SymptomCheckSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SymptomCheckSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SymptomCheckSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionFindFirstArgs} args - Arguments to find a SymptomCheckSession
     * @example
     * // Get one SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SymptomCheckSessionFindFirstArgs>(args?: SelectSubset<T, SymptomCheckSessionFindFirstArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SymptomCheckSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionFindFirstOrThrowArgs} args - Arguments to find a SymptomCheckSession
     * @example
     * // Get one SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SymptomCheckSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SymptomCheckSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SymptomCheckSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SymptomCheckSessions
     * const symptomCheckSessions = await prisma.symptomCheckSession.findMany()
     * 
     * // Get first 10 SymptomCheckSessions
     * const symptomCheckSessions = await prisma.symptomCheckSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const symptomCheckSessionWithIdOnly = await prisma.symptomCheckSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SymptomCheckSessionFindManyArgs>(args?: SelectSubset<T, SymptomCheckSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SymptomCheckSession.
     * @param {SymptomCheckSessionCreateArgs} args - Arguments to create a SymptomCheckSession.
     * @example
     * // Create one SymptomCheckSession
     * const SymptomCheckSession = await prisma.symptomCheckSession.create({
     *   data: {
     *     // ... data to create a SymptomCheckSession
     *   }
     * })
     * 
     */
    create<T extends SymptomCheckSessionCreateArgs>(args: SelectSubset<T, SymptomCheckSessionCreateArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SymptomCheckSessions.
     * @param {SymptomCheckSessionCreateManyArgs} args - Arguments to create many SymptomCheckSessions.
     * @example
     * // Create many SymptomCheckSessions
     * const symptomCheckSession = await prisma.symptomCheckSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SymptomCheckSessionCreateManyArgs>(args?: SelectSubset<T, SymptomCheckSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SymptomCheckSessions and returns the data saved in the database.
     * @param {SymptomCheckSessionCreateManyAndReturnArgs} args - Arguments to create many SymptomCheckSessions.
     * @example
     * // Create many SymptomCheckSessions
     * const symptomCheckSession = await prisma.symptomCheckSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SymptomCheckSessions and only return the `id`
     * const symptomCheckSessionWithIdOnly = await prisma.symptomCheckSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SymptomCheckSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SymptomCheckSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SymptomCheckSession.
     * @param {SymptomCheckSessionDeleteArgs} args - Arguments to delete one SymptomCheckSession.
     * @example
     * // Delete one SymptomCheckSession
     * const SymptomCheckSession = await prisma.symptomCheckSession.delete({
     *   where: {
     *     // ... filter to delete one SymptomCheckSession
     *   }
     * })
     * 
     */
    delete<T extends SymptomCheckSessionDeleteArgs>(args: SelectSubset<T, SymptomCheckSessionDeleteArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SymptomCheckSession.
     * @param {SymptomCheckSessionUpdateArgs} args - Arguments to update one SymptomCheckSession.
     * @example
     * // Update one SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SymptomCheckSessionUpdateArgs>(args: SelectSubset<T, SymptomCheckSessionUpdateArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SymptomCheckSessions.
     * @param {SymptomCheckSessionDeleteManyArgs} args - Arguments to filter SymptomCheckSessions to delete.
     * @example
     * // Delete a few SymptomCheckSessions
     * const { count } = await prisma.symptomCheckSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SymptomCheckSessionDeleteManyArgs>(args?: SelectSubset<T, SymptomCheckSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SymptomCheckSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SymptomCheckSessions
     * const symptomCheckSession = await prisma.symptomCheckSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SymptomCheckSessionUpdateManyArgs>(args: SelectSubset<T, SymptomCheckSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SymptomCheckSession.
     * @param {SymptomCheckSessionUpsertArgs} args - Arguments to update or create a SymptomCheckSession.
     * @example
     * // Update or create a SymptomCheckSession
     * const symptomCheckSession = await prisma.symptomCheckSession.upsert({
     *   create: {
     *     // ... data to create a SymptomCheckSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SymptomCheckSession we want to update
     *   }
     * })
     */
    upsert<T extends SymptomCheckSessionUpsertArgs>(args: SelectSubset<T, SymptomCheckSessionUpsertArgs<ExtArgs>>): Prisma__SymptomCheckSessionClient<$Result.GetResult<Prisma.$SymptomCheckSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SymptomCheckSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionCountArgs} args - Arguments to filter SymptomCheckSessions to count.
     * @example
     * // Count the number of SymptomCheckSessions
     * const count = await prisma.symptomCheckSession.count({
     *   where: {
     *     // ... the filter for the SymptomCheckSessions we want to count
     *   }
     * })
    **/
    count<T extends SymptomCheckSessionCountArgs>(
      args?: Subset<T, SymptomCheckSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SymptomCheckSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SymptomCheckSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SymptomCheckSessionAggregateArgs>(args: Subset<T, SymptomCheckSessionAggregateArgs>): Prisma.PrismaPromise<GetSymptomCheckSessionAggregateType<T>>

    /**
     * Group by SymptomCheckSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SymptomCheckSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SymptomCheckSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SymptomCheckSessionGroupByArgs['orderBy'] }
        : { orderBy?: SymptomCheckSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SymptomCheckSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSymptomCheckSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SymptomCheckSession model
   */
  readonly fields: SymptomCheckSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SymptomCheckSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SymptomCheckSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SymptomCheckSession model
   */ 
  interface SymptomCheckSessionFieldRefs {
    readonly id: FieldRef<"SymptomCheckSession", 'Int'>
    readonly uuid: FieldRef<"SymptomCheckSession", 'String'>
    readonly userId: FieldRef<"SymptomCheckSession", 'Int'>
    readonly conversation: FieldRef<"SymptomCheckSession", 'String'>
    readonly result: FieldRef<"SymptomCheckSession", 'String'>
    readonly riskLevel: FieldRef<"SymptomCheckSession", 'String'>
    readonly createdAt: FieldRef<"SymptomCheckSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SymptomCheckSession findUnique
   */
  export type SymptomCheckSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter, which SymptomCheckSession to fetch.
     */
    where: SymptomCheckSessionWhereUniqueInput
  }

  /**
   * SymptomCheckSession findUniqueOrThrow
   */
  export type SymptomCheckSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter, which SymptomCheckSession to fetch.
     */
    where: SymptomCheckSessionWhereUniqueInput
  }

  /**
   * SymptomCheckSession findFirst
   */
  export type SymptomCheckSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter, which SymptomCheckSession to fetch.
     */
    where?: SymptomCheckSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomCheckSessions to fetch.
     */
    orderBy?: SymptomCheckSessionOrderByWithRelationInput | SymptomCheckSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymptomCheckSessions.
     */
    cursor?: SymptomCheckSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomCheckSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomCheckSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymptomCheckSessions.
     */
    distinct?: SymptomCheckSessionScalarFieldEnum | SymptomCheckSessionScalarFieldEnum[]
  }

  /**
   * SymptomCheckSession findFirstOrThrow
   */
  export type SymptomCheckSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter, which SymptomCheckSession to fetch.
     */
    where?: SymptomCheckSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomCheckSessions to fetch.
     */
    orderBy?: SymptomCheckSessionOrderByWithRelationInput | SymptomCheckSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SymptomCheckSessions.
     */
    cursor?: SymptomCheckSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomCheckSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomCheckSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SymptomCheckSessions.
     */
    distinct?: SymptomCheckSessionScalarFieldEnum | SymptomCheckSessionScalarFieldEnum[]
  }

  /**
   * SymptomCheckSession findMany
   */
  export type SymptomCheckSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter, which SymptomCheckSessions to fetch.
     */
    where?: SymptomCheckSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SymptomCheckSessions to fetch.
     */
    orderBy?: SymptomCheckSessionOrderByWithRelationInput | SymptomCheckSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SymptomCheckSessions.
     */
    cursor?: SymptomCheckSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SymptomCheckSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SymptomCheckSessions.
     */
    skip?: number
    distinct?: SymptomCheckSessionScalarFieldEnum | SymptomCheckSessionScalarFieldEnum[]
  }

  /**
   * SymptomCheckSession create
   */
  export type SymptomCheckSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a SymptomCheckSession.
     */
    data: XOR<SymptomCheckSessionCreateInput, SymptomCheckSessionUncheckedCreateInput>
  }

  /**
   * SymptomCheckSession createMany
   */
  export type SymptomCheckSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SymptomCheckSessions.
     */
    data: SymptomCheckSessionCreateManyInput | SymptomCheckSessionCreateManyInput[]
  }

  /**
   * SymptomCheckSession createManyAndReturn
   */
  export type SymptomCheckSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SymptomCheckSessions.
     */
    data: SymptomCheckSessionCreateManyInput | SymptomCheckSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SymptomCheckSession update
   */
  export type SymptomCheckSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a SymptomCheckSession.
     */
    data: XOR<SymptomCheckSessionUpdateInput, SymptomCheckSessionUncheckedUpdateInput>
    /**
     * Choose, which SymptomCheckSession to update.
     */
    where: SymptomCheckSessionWhereUniqueInput
  }

  /**
   * SymptomCheckSession updateMany
   */
  export type SymptomCheckSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SymptomCheckSessions.
     */
    data: XOR<SymptomCheckSessionUpdateManyMutationInput, SymptomCheckSessionUncheckedUpdateManyInput>
    /**
     * Filter which SymptomCheckSessions to update
     */
    where?: SymptomCheckSessionWhereInput
  }

  /**
   * SymptomCheckSession upsert
   */
  export type SymptomCheckSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the SymptomCheckSession to update in case it exists.
     */
    where: SymptomCheckSessionWhereUniqueInput
    /**
     * In case the SymptomCheckSession found by the `where` argument doesn't exist, create a new SymptomCheckSession with this data.
     */
    create: XOR<SymptomCheckSessionCreateInput, SymptomCheckSessionUncheckedCreateInput>
    /**
     * In case the SymptomCheckSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SymptomCheckSessionUpdateInput, SymptomCheckSessionUncheckedUpdateInput>
  }

  /**
   * SymptomCheckSession delete
   */
  export type SymptomCheckSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
    /**
     * Filter which SymptomCheckSession to delete.
     */
    where: SymptomCheckSessionWhereUniqueInput
  }

  /**
   * SymptomCheckSession deleteMany
   */
  export type SymptomCheckSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SymptomCheckSessions to delete
     */
    where?: SymptomCheckSessionWhereInput
  }

  /**
   * SymptomCheckSession without action
   */
  export type SymptomCheckSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SymptomCheckSession
     */
    select?: SymptomCheckSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SymptomCheckSessionInclude<ExtArgs> | null
  }


  /**
   * Model CoachSession
   */

  export type AggregateCoachSession = {
    _count: CoachSessionCountAggregateOutputType | null
    _avg: CoachSessionAvgAggregateOutputType | null
    _sum: CoachSessionSumAggregateOutputType | null
    _min: CoachSessionMinAggregateOutputType | null
    _max: CoachSessionMaxAggregateOutputType | null
  }

  export type CoachSessionAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CoachSessionSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type CoachSessionMinAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    conversation: string | null
    savedPlan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachSessionMaxAggregateOutputType = {
    id: number | null
    uuid: string | null
    userId: number | null
    conversation: string | null
    savedPlan: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CoachSessionCountAggregateOutputType = {
    id: number
    uuid: number
    userId: number
    conversation: number
    savedPlan: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CoachSessionAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CoachSessionSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type CoachSessionMinAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    savedPlan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachSessionMaxAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    savedPlan?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CoachSessionCountAggregateInputType = {
    id?: true
    uuid?: true
    userId?: true
    conversation?: true
    savedPlan?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CoachSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachSession to aggregate.
     */
    where?: CoachSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachSessions to fetch.
     */
    orderBy?: CoachSessionOrderByWithRelationInput | CoachSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CoachSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CoachSessions
    **/
    _count?: true | CoachSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CoachSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CoachSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CoachSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CoachSessionMaxAggregateInputType
  }

  export type GetCoachSessionAggregateType<T extends CoachSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateCoachSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCoachSession[P]>
      : GetScalarType<T[P], AggregateCoachSession[P]>
  }




  export type CoachSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CoachSessionWhereInput
    orderBy?: CoachSessionOrderByWithAggregationInput | CoachSessionOrderByWithAggregationInput[]
    by: CoachSessionScalarFieldEnum[] | CoachSessionScalarFieldEnum
    having?: CoachSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CoachSessionCountAggregateInputType | true
    _avg?: CoachSessionAvgAggregateInputType
    _sum?: CoachSessionSumAggregateInputType
    _min?: CoachSessionMinAggregateInputType
    _max?: CoachSessionMaxAggregateInputType
  }

  export type CoachSessionGroupByOutputType = {
    id: number
    uuid: string
    userId: number
    conversation: string
    savedPlan: string | null
    createdAt: Date
    updatedAt: Date
    _count: CoachSessionCountAggregateOutputType | null
    _avg: CoachSessionAvgAggregateOutputType | null
    _sum: CoachSessionSumAggregateOutputType | null
    _min: CoachSessionMinAggregateOutputType | null
    _max: CoachSessionMaxAggregateOutputType | null
  }

  type GetCoachSessionGroupByPayload<T extends CoachSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CoachSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CoachSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CoachSessionGroupByOutputType[P]>
            : GetScalarType<T[P], CoachSessionGroupByOutputType[P]>
        }
      >
    >


  export type CoachSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    savedPlan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachSession"]>

  export type CoachSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    savedPlan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["coachSession"]>

  export type CoachSessionSelectScalar = {
    id?: boolean
    uuid?: boolean
    userId?: boolean
    conversation?: boolean
    savedPlan?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CoachSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CoachSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CoachSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CoachSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      uuid: string
      userId: number
      conversation: string
      savedPlan: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["coachSession"]>
    composites: {}
  }

  type CoachSessionGetPayload<S extends boolean | null | undefined | CoachSessionDefaultArgs> = $Result.GetResult<Prisma.$CoachSessionPayload, S>

  type CoachSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CoachSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CoachSessionCountAggregateInputType | true
    }

  export interface CoachSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CoachSession'], meta: { name: 'CoachSession' } }
    /**
     * Find zero or one CoachSession that matches the filter.
     * @param {CoachSessionFindUniqueArgs} args - Arguments to find a CoachSession
     * @example
     * // Get one CoachSession
     * const coachSession = await prisma.coachSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CoachSessionFindUniqueArgs>(args: SelectSubset<T, CoachSessionFindUniqueArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CoachSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CoachSessionFindUniqueOrThrowArgs} args - Arguments to find a CoachSession
     * @example
     * // Get one CoachSession
     * const coachSession = await prisma.coachSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CoachSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, CoachSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CoachSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionFindFirstArgs} args - Arguments to find a CoachSession
     * @example
     * // Get one CoachSession
     * const coachSession = await prisma.coachSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CoachSessionFindFirstArgs>(args?: SelectSubset<T, CoachSessionFindFirstArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CoachSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionFindFirstOrThrowArgs} args - Arguments to find a CoachSession
     * @example
     * // Get one CoachSession
     * const coachSession = await prisma.coachSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CoachSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, CoachSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CoachSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CoachSessions
     * const coachSessions = await prisma.coachSession.findMany()
     * 
     * // Get first 10 CoachSessions
     * const coachSessions = await prisma.coachSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const coachSessionWithIdOnly = await prisma.coachSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CoachSessionFindManyArgs>(args?: SelectSubset<T, CoachSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CoachSession.
     * @param {CoachSessionCreateArgs} args - Arguments to create a CoachSession.
     * @example
     * // Create one CoachSession
     * const CoachSession = await prisma.coachSession.create({
     *   data: {
     *     // ... data to create a CoachSession
     *   }
     * })
     * 
     */
    create<T extends CoachSessionCreateArgs>(args: SelectSubset<T, CoachSessionCreateArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CoachSessions.
     * @param {CoachSessionCreateManyArgs} args - Arguments to create many CoachSessions.
     * @example
     * // Create many CoachSessions
     * const coachSession = await prisma.coachSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CoachSessionCreateManyArgs>(args?: SelectSubset<T, CoachSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CoachSessions and returns the data saved in the database.
     * @param {CoachSessionCreateManyAndReturnArgs} args - Arguments to create many CoachSessions.
     * @example
     * // Create many CoachSessions
     * const coachSession = await prisma.coachSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CoachSessions and only return the `id`
     * const coachSessionWithIdOnly = await prisma.coachSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CoachSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, CoachSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CoachSession.
     * @param {CoachSessionDeleteArgs} args - Arguments to delete one CoachSession.
     * @example
     * // Delete one CoachSession
     * const CoachSession = await prisma.coachSession.delete({
     *   where: {
     *     // ... filter to delete one CoachSession
     *   }
     * })
     * 
     */
    delete<T extends CoachSessionDeleteArgs>(args: SelectSubset<T, CoachSessionDeleteArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CoachSession.
     * @param {CoachSessionUpdateArgs} args - Arguments to update one CoachSession.
     * @example
     * // Update one CoachSession
     * const coachSession = await prisma.coachSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CoachSessionUpdateArgs>(args: SelectSubset<T, CoachSessionUpdateArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CoachSessions.
     * @param {CoachSessionDeleteManyArgs} args - Arguments to filter CoachSessions to delete.
     * @example
     * // Delete a few CoachSessions
     * const { count } = await prisma.coachSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CoachSessionDeleteManyArgs>(args?: SelectSubset<T, CoachSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CoachSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CoachSessions
     * const coachSession = await prisma.coachSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CoachSessionUpdateManyArgs>(args: SelectSubset<T, CoachSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CoachSession.
     * @param {CoachSessionUpsertArgs} args - Arguments to update or create a CoachSession.
     * @example
     * // Update or create a CoachSession
     * const coachSession = await prisma.coachSession.upsert({
     *   create: {
     *     // ... data to create a CoachSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CoachSession we want to update
     *   }
     * })
     */
    upsert<T extends CoachSessionUpsertArgs>(args: SelectSubset<T, CoachSessionUpsertArgs<ExtArgs>>): Prisma__CoachSessionClient<$Result.GetResult<Prisma.$CoachSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CoachSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionCountArgs} args - Arguments to filter CoachSessions to count.
     * @example
     * // Count the number of CoachSessions
     * const count = await prisma.coachSession.count({
     *   where: {
     *     // ... the filter for the CoachSessions we want to count
     *   }
     * })
    **/
    count<T extends CoachSessionCountArgs>(
      args?: Subset<T, CoachSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CoachSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CoachSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CoachSessionAggregateArgs>(args: Subset<T, CoachSessionAggregateArgs>): Prisma.PrismaPromise<GetCoachSessionAggregateType<T>>

    /**
     * Group by CoachSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CoachSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CoachSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CoachSessionGroupByArgs['orderBy'] }
        : { orderBy?: CoachSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CoachSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCoachSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CoachSession model
   */
  readonly fields: CoachSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CoachSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CoachSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CoachSession model
   */ 
  interface CoachSessionFieldRefs {
    readonly id: FieldRef<"CoachSession", 'Int'>
    readonly uuid: FieldRef<"CoachSession", 'String'>
    readonly userId: FieldRef<"CoachSession", 'Int'>
    readonly conversation: FieldRef<"CoachSession", 'String'>
    readonly savedPlan: FieldRef<"CoachSession", 'String'>
    readonly createdAt: FieldRef<"CoachSession", 'DateTime'>
    readonly updatedAt: FieldRef<"CoachSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CoachSession findUnique
   */
  export type CoachSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter, which CoachSession to fetch.
     */
    where: CoachSessionWhereUniqueInput
  }

  /**
   * CoachSession findUniqueOrThrow
   */
  export type CoachSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter, which CoachSession to fetch.
     */
    where: CoachSessionWhereUniqueInput
  }

  /**
   * CoachSession findFirst
   */
  export type CoachSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter, which CoachSession to fetch.
     */
    where?: CoachSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachSessions to fetch.
     */
    orderBy?: CoachSessionOrderByWithRelationInput | CoachSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachSessions.
     */
    cursor?: CoachSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachSessions.
     */
    distinct?: CoachSessionScalarFieldEnum | CoachSessionScalarFieldEnum[]
  }

  /**
   * CoachSession findFirstOrThrow
   */
  export type CoachSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter, which CoachSession to fetch.
     */
    where?: CoachSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachSessions to fetch.
     */
    orderBy?: CoachSessionOrderByWithRelationInput | CoachSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CoachSessions.
     */
    cursor?: CoachSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CoachSessions.
     */
    distinct?: CoachSessionScalarFieldEnum | CoachSessionScalarFieldEnum[]
  }

  /**
   * CoachSession findMany
   */
  export type CoachSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter, which CoachSessions to fetch.
     */
    where?: CoachSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CoachSessions to fetch.
     */
    orderBy?: CoachSessionOrderByWithRelationInput | CoachSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CoachSessions.
     */
    cursor?: CoachSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CoachSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CoachSessions.
     */
    skip?: number
    distinct?: CoachSessionScalarFieldEnum | CoachSessionScalarFieldEnum[]
  }

  /**
   * CoachSession create
   */
  export type CoachSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a CoachSession.
     */
    data: XOR<CoachSessionCreateInput, CoachSessionUncheckedCreateInput>
  }

  /**
   * CoachSession createMany
   */
  export type CoachSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CoachSessions.
     */
    data: CoachSessionCreateManyInput | CoachSessionCreateManyInput[]
  }

  /**
   * CoachSession createManyAndReturn
   */
  export type CoachSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CoachSessions.
     */
    data: CoachSessionCreateManyInput | CoachSessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CoachSession update
   */
  export type CoachSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a CoachSession.
     */
    data: XOR<CoachSessionUpdateInput, CoachSessionUncheckedUpdateInput>
    /**
     * Choose, which CoachSession to update.
     */
    where: CoachSessionWhereUniqueInput
  }

  /**
   * CoachSession updateMany
   */
  export type CoachSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CoachSessions.
     */
    data: XOR<CoachSessionUpdateManyMutationInput, CoachSessionUncheckedUpdateManyInput>
    /**
     * Filter which CoachSessions to update
     */
    where?: CoachSessionWhereInput
  }

  /**
   * CoachSession upsert
   */
  export type CoachSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the CoachSession to update in case it exists.
     */
    where: CoachSessionWhereUniqueInput
    /**
     * In case the CoachSession found by the `where` argument doesn't exist, create a new CoachSession with this data.
     */
    create: XOR<CoachSessionCreateInput, CoachSessionUncheckedCreateInput>
    /**
     * In case the CoachSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CoachSessionUpdateInput, CoachSessionUncheckedUpdateInput>
  }

  /**
   * CoachSession delete
   */
  export type CoachSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
    /**
     * Filter which CoachSession to delete.
     */
    where: CoachSessionWhereUniqueInput
  }

  /**
   * CoachSession deleteMany
   */
  export type CoachSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CoachSessions to delete
     */
    where?: CoachSessionWhereInput
  }

  /**
   * CoachSession without action
   */
  export type CoachSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CoachSession
     */
    select?: CoachSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CoachSessionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    email: 'email',
    phone: 'phone',
    passwordHash: 'passwordHash',
    fullName: 'fullName',
    profilePhotoUrl: 'profilePhotoUrl',
    dateOfBirth: 'dateOfBirth',
    gender: 'gender',
    bloodGroup: 'bloodGroup',
    city: 'city',
    state: 'state',
    country: 'country',
    address: 'address',
    abhaId: 'abhaId',
    isVerified: 'isVerified',
    isActive: 'isActive',
    role: 'role',
    lastLogin: 'lastLogin',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const HealthProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    heightCm: 'heightCm',
    weightKg: 'weightKg',
    bmi: 'bmi',
    bloodPressureSystolic: 'bloodPressureSystolic',
    bloodPressureDiastolic: 'bloodPressureDiastolic',
    heartRate: 'heartRate',
    conditions: 'conditions',
    allergies: 'allergies',
    medications: 'medications',
    vaccinationRecords: 'vaccinationRecords',
    healthScore: 'healthScore',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthProfileScalarFieldEnum = (typeof HealthProfileScalarFieldEnum)[keyof typeof HealthProfileScalarFieldEnum]


  export const DoctorScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    specialty: 'specialty',
    qualifications: 'qualifications',
    experienceYears: 'experienceYears',
    licenseNumber: 'licenseNumber',
    clinicName: 'clinicName',
    clinicAddress: 'clinicAddress',
    latitude: 'latitude',
    longitude: 'longitude',
    consultationFee: 'consultationFee',
    averageRating: 'averageRating',
    totalRatings: 'totalRatings',
    availability: 'availability',
    isVerified: 'isVerified',
    verificationDocuments: 'verificationDocuments',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DoctorScalarFieldEnum = (typeof DoctorScalarFieldEnum)[keyof typeof DoctorScalarFieldEnum]


  export const DoctorReviewScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    doctorId: 'doctorId',
    userId: 'userId',
    appointmentId: 'appointmentId',
    rating: 'rating',
    review: 'review',
    verified: 'verified',
    helpfulCount: 'helpfulCount',
    createdAt: 'createdAt'
  };

  export type DoctorReviewScalarFieldEnum = (typeof DoctorReviewScalarFieldEnum)[keyof typeof DoctorReviewScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    doctorId: 'doctorId',
    appointmentDate: 'appointmentDate',
    consultationType: 'consultationType',
    status: 'status',
    reason: 'reason',
    notes: 'notes',
    meetingLink: 'meetingLink',
    recordingUrl: 'recordingUrl',
    prescriptionId: 'prescriptionId',
    paymentId: 'paymentId',
    paymentStatus: 'paymentStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const PrescriptionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    appointmentId: 'appointmentId',
    doctorId: 'doctorId',
    userId: 'userId',
    medicines: 'medicines',
    instructions: 'instructions',
    validityDays: 'validityDays',
    issuedAt: 'issuedAt',
    createdAt: 'createdAt'
  };

  export type PrescriptionScalarFieldEnum = (typeof PrescriptionScalarFieldEnum)[keyof typeof PrescriptionScalarFieldEnum]


  export const CallSessionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    appointmentId: 'appointmentId',
    roomId: 'roomId',
    provider: 'provider',
    token: 'token',
    startedAt: 'startedAt',
    endedAt: 'endedAt',
    recordingUrl: 'recordingUrl',
    createdAt: 'createdAt'
  };

  export type CallSessionScalarFieldEnum = (typeof CallSessionScalarFieldEnum)[keyof typeof CallSessionScalarFieldEnum]


  export const MedicineScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    composition: 'composition',
    category: 'category',
    price: 'price',
    manufacturer: 'manufacturer',
    stockQty: 'stockQty',
    description: 'description',
    sideEffects: 'sideEffects',
    interactions: 'interactions',
    requiresPrescription: 'requiresPrescription',
    available: 'available',
    createdAt: 'createdAt'
  };

  export type MedicineScalarFieldEnum = (typeof MedicineScalarFieldEnum)[keyof typeof MedicineScalarFieldEnum]


  export const MedicineOrderScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    orderDate: 'orderDate',
    deliveryAddress: 'deliveryAddress',
    status: 'status',
    totalAmount: 'totalAmount',
    paymentMethod: 'paymentMethod',
    paymentStatus: 'paymentStatus',
    prescriptionUrl: 'prescriptionUrl',
    deliveryDate: 'deliveryDate',
    expectedDeliveryDate: 'expectedDeliveryDate',
    trackingNumber: 'trackingNumber',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MedicineOrderScalarFieldEnum = (typeof MedicineOrderScalarFieldEnum)[keyof typeof MedicineOrderScalarFieldEnum]


  export const MedicineOrderItemScalarFieldEnum: {
    id: 'id',
    orderId: 'orderId',
    medicineId: 'medicineId',
    quantity: 'quantity',
    price: 'price'
  };

  export type MedicineOrderItemScalarFieldEnum = (typeof MedicineOrderItemScalarFieldEnum)[keyof typeof MedicineOrderItemScalarFieldEnum]


  export const LabTestScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    name: 'name',
    category: 'category',
    price: 'price',
    description: 'description',
    preparation: 'preparation',
    parameters: 'parameters',
    turnaroundTime: 'turnaroundTime',
    available: 'available',
    createdAt: 'createdAt'
  };

  export type LabTestScalarFieldEnum = (typeof LabTestScalarFieldEnum)[keyof typeof LabTestScalarFieldEnum]


  export const LabBookingScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    bookingDate: 'bookingDate',
    collectionType: 'collectionType',
    address: 'address',
    status: 'status',
    totalAmount: 'totalAmount',
    paymentStatus: 'paymentStatus',
    reportUrl: 'reportUrl',
    reportReadyDate: 'reportReadyDate',
    createdAt: 'createdAt'
  };

  export type LabBookingScalarFieldEnum = (typeof LabBookingScalarFieldEnum)[keyof typeof LabBookingScalarFieldEnum]


  export const LabBookingTestScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    testId: 'testId'
  };

  export type LabBookingTestScalarFieldEnum = (typeof LabBookingTestScalarFieldEnum)[keyof typeof LabBookingTestScalarFieldEnum]


  export const LabReportScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    bookingId: 'bookingId',
    reportUrl: 'reportUrl',
    results: 'results',
    status: 'status',
    reviewedById: 'reviewedById',
    interpretation: 'interpretation',
    recommendations: 'recommendations',
    readyAt: 'readyAt',
    createdAt: 'createdAt'
  };

  export type LabReportScalarFieldEnum = (typeof LabReportScalarFieldEnum)[keyof typeof LabReportScalarFieldEnum]


  export const HealthRecordScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    recordType: 'recordType',
    title: 'title',
    description: 'description',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    fileType: 'fileType',
    fileSize: 'fileSize',
    doctorId: 'doctorId',
    appointmentId: 'appointmentId',
    documentDate: 'documentDate',
    isPublic: 'isPublic',
    sharedWith: 'sharedWith',
    createdAt: 'createdAt'
  };

  export type HealthRecordScalarFieldEnum = (typeof HealthRecordScalarFieldEnum)[keyof typeof HealthRecordScalarFieldEnum]


  export const ForumPostScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    title: 'title',
    content: 'content',
    category: 'category',
    status: 'status',
    upvotes: 'upvotes',
    downvotes: 'downvotes',
    views: 'views',
    commentsCount: 'commentsCount',
    pinned: 'pinned',
    verifiedDoctor: 'verifiedDoctor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumPostScalarFieldEnum = (typeof ForumPostScalarFieldEnum)[keyof typeof ForumPostScalarFieldEnum]


  export const ForumCommentScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    postId: 'postId',
    userId: 'userId',
    parentCommentId: 'parentCommentId',
    content: 'content',
    upvotes: 'upvotes',
    helpfulCount: 'helpfulCount',
    verifiedDoctor: 'verifiedDoctor',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ForumCommentScalarFieldEnum = (typeof ForumCommentScalarFieldEnum)[keyof typeof ForumCommentScalarFieldEnum]


  export const PostUpvoteScalarFieldEnum: {
    id: 'id',
    postId: 'postId',
    userId: 'userId',
    voteType: 'voteType'
  };

  export type PostUpvoteScalarFieldEnum = (typeof PostUpvoteScalarFieldEnum)[keyof typeof PostUpvoteScalarFieldEnum]


  export const CommentUpvoteScalarFieldEnum: {
    id: 'id',
    commentId: 'commentId',
    userId: 'userId',
    voteType: 'voteType'
  };

  export type CommentUpvoteScalarFieldEnum = (typeof CommentUpvoteScalarFieldEnum)[keyof typeof CommentUpvoteScalarFieldEnum]


  export const HealthArticleScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    title: 'title',
    slug: 'slug',
    content: 'content',
    category: 'category',
    authorId: 'authorId',
    featuredImageUrl: 'featuredImageUrl',
    status: 'status',
    views: 'views',
    publishedAt: 'publishedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type HealthArticleScalarFieldEnum = (typeof HealthArticleScalarFieldEnum)[keyof typeof HealthArticleScalarFieldEnum]


  export const ArticleCommentScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    articleId: 'articleId',
    userId: 'userId',
    content: 'content',
    upvotes: 'upvotes',
    createdAt: 'createdAt'
  };

  export type ArticleCommentScalarFieldEnum = (typeof ArticleCommentScalarFieldEnum)[keyof typeof ArticleCommentScalarFieldEnum]


  export const SavedArticleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    articleId: 'articleId',
    savedAt: 'savedAt'
  };

  export type SavedArticleScalarFieldEnum = (typeof SavedArticleScalarFieldEnum)[keyof typeof SavedArticleScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    type: 'type',
    title: 'title',
    message: 'message',
    data: 'data',
    read: 'read',
    actionUrl: 'actionUrl',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SymptomCheckSessionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    conversation: 'conversation',
    result: 'result',
    riskLevel: 'riskLevel',
    createdAt: 'createdAt'
  };

  export type SymptomCheckSessionScalarFieldEnum = (typeof SymptomCheckSessionScalarFieldEnum)[keyof typeof SymptomCheckSessionScalarFieldEnum]


  export const CoachSessionScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    userId: 'userId',
    conversation: 'conversation',
    savedPlan: 'savedPlan',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CoachSessionScalarFieldEnum = (typeof CoachSessionScalarFieldEnum)[keyof typeof CoachSessionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    uuid?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringNullableFilter<"User"> | string | null
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    bloodGroup?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    abhaId?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    healthProfile?: XOR<HealthProfileNullableRelationFilter, HealthProfileWhereInput> | null
    doctorProfile?: XOR<DoctorNullableRelationFilter, DoctorWhereInput> | null
    appointments?: AppointmentListRelationFilter
    appointmentsAsDoctor?: AppointmentListRelationFilter
    medicineOrders?: MedicineOrderListRelationFilter
    labBookings?: LabBookingListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumComments?: ForumCommentListRelationFilter
    postUpvotes?: PostUpvoteListRelationFilter
    commentUpvotes?: CommentUpvoteListRelationFilter
    articles?: HealthArticleListRelationFilter
    savedArticles?: SavedArticleListRelationFilter
    notifications?: NotificationListRelationFilter
    reviews?: DoctorReviewListRelationFilter
    symptomSessions?: SymptomCheckSessionListRelationFilter
    coachSessions?: CoachSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    abhaId?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    healthProfile?: HealthProfileOrderByWithRelationInput
    doctorProfile?: DoctorOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    appointmentsAsDoctor?: AppointmentOrderByRelationAggregateInput
    medicineOrders?: MedicineOrderOrderByRelationAggregateInput
    labBookings?: LabBookingOrderByRelationAggregateInput
    healthRecords?: HealthRecordOrderByRelationAggregateInput
    forumPosts?: ForumPostOrderByRelationAggregateInput
    forumComments?: ForumCommentOrderByRelationAggregateInput
    postUpvotes?: PostUpvoteOrderByRelationAggregateInput
    commentUpvotes?: CommentUpvoteOrderByRelationAggregateInput
    articles?: HealthArticleOrderByRelationAggregateInput
    savedArticles?: SavedArticleOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    reviews?: DoctorReviewOrderByRelationAggregateInput
    symptomSessions?: SymptomCheckSessionOrderByRelationAggregateInput
    coachSessions?: CoachSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    email?: string
    phone?: string
    abhaId?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringNullableFilter<"User"> | string | null
    fullName?: StringNullableFilter<"User"> | string | null
    profilePhotoUrl?: StringNullableFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"User"> | Date | string | null
    gender?: StringNullableFilter<"User"> | string | null
    bloodGroup?: StringNullableFilter<"User"> | string | null
    city?: StringNullableFilter<"User"> | string | null
    state?: StringNullableFilter<"User"> | string | null
    country?: StringNullableFilter<"User"> | string | null
    address?: StringNullableFilter<"User"> | string | null
    isVerified?: BoolFilter<"User"> | boolean
    isActive?: BoolFilter<"User"> | boolean
    role?: StringFilter<"User"> | string
    lastLogin?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    healthProfile?: XOR<HealthProfileNullableRelationFilter, HealthProfileWhereInput> | null
    doctorProfile?: XOR<DoctorNullableRelationFilter, DoctorWhereInput> | null
    appointments?: AppointmentListRelationFilter
    appointmentsAsDoctor?: AppointmentListRelationFilter
    medicineOrders?: MedicineOrderListRelationFilter
    labBookings?: LabBookingListRelationFilter
    healthRecords?: HealthRecordListRelationFilter
    forumPosts?: ForumPostListRelationFilter
    forumComments?: ForumCommentListRelationFilter
    postUpvotes?: PostUpvoteListRelationFilter
    commentUpvotes?: CommentUpvoteListRelationFilter
    articles?: HealthArticleListRelationFilter
    savedArticles?: SavedArticleListRelationFilter
    notifications?: NotificationListRelationFilter
    reviews?: DoctorReviewListRelationFilter
    symptomSessions?: SymptomCheckSessionListRelationFilter
    coachSessions?: CoachSessionListRelationFilter
  }, "id" | "uuid" | "email" | "phone" | "abhaId">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrderInput | SortOrder
    passwordHash?: SortOrderInput | SortOrder
    fullName?: SortOrderInput | SortOrder
    profilePhotoUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    bloodGroup?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    abhaId?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    uuid?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    passwordHash?: StringNullableWithAggregatesFilter<"User"> | string | null
    fullName?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePhotoUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    bloodGroup?: StringNullableWithAggregatesFilter<"User"> | string | null
    city?: StringNullableWithAggregatesFilter<"User"> | string | null
    state?: StringNullableWithAggregatesFilter<"User"> | string | null
    country?: StringNullableWithAggregatesFilter<"User"> | string | null
    address?: StringNullableWithAggregatesFilter<"User"> | string | null
    abhaId?: StringNullableWithAggregatesFilter<"User"> | string | null
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    role?: StringWithAggregatesFilter<"User"> | string
    lastLogin?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type HealthProfileWhereInput = {
    AND?: HealthProfileWhereInput | HealthProfileWhereInput[]
    OR?: HealthProfileWhereInput[]
    NOT?: HealthProfileWhereInput | HealthProfileWhereInput[]
    id?: IntFilter<"HealthProfile"> | number
    userId?: IntFilter<"HealthProfile"> | number
    heightCm?: FloatNullableFilter<"HealthProfile"> | number | null
    weightKg?: FloatNullableFilter<"HealthProfile"> | number | null
    bmi?: FloatNullableFilter<"HealthProfile"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"HealthProfile"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"HealthProfile"> | number | null
    heartRate?: IntNullableFilter<"HealthProfile"> | number | null
    conditions?: StringNullableFilter<"HealthProfile"> | string | null
    allergies?: StringNullableFilter<"HealthProfile"> | string | null
    medications?: StringNullableFilter<"HealthProfile"> | string | null
    vaccinationRecords?: StringNullableFilter<"HealthProfile"> | string | null
    healthScore?: IntFilter<"HealthProfile"> | number
    createdAt?: DateTimeFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeFilter<"HealthProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HealthProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    vaccinationRecords?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HealthProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId?: number
    AND?: HealthProfileWhereInput | HealthProfileWhereInput[]
    OR?: HealthProfileWhereInput[]
    NOT?: HealthProfileWhereInput | HealthProfileWhereInput[]
    heightCm?: FloatNullableFilter<"HealthProfile"> | number | null
    weightKg?: FloatNullableFilter<"HealthProfile"> | number | null
    bmi?: FloatNullableFilter<"HealthProfile"> | number | null
    bloodPressureSystolic?: IntNullableFilter<"HealthProfile"> | number | null
    bloodPressureDiastolic?: IntNullableFilter<"HealthProfile"> | number | null
    heartRate?: IntNullableFilter<"HealthProfile"> | number | null
    conditions?: StringNullableFilter<"HealthProfile"> | string | null
    allergies?: StringNullableFilter<"HealthProfile"> | string | null
    medications?: StringNullableFilter<"HealthProfile"> | string | null
    vaccinationRecords?: StringNullableFilter<"HealthProfile"> | string | null
    healthScore?: IntFilter<"HealthProfile"> | number
    createdAt?: DateTimeFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeFilter<"HealthProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type HealthProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrderInput | SortOrder
    weightKg?: SortOrderInput | SortOrder
    bmi?: SortOrderInput | SortOrder
    bloodPressureSystolic?: SortOrderInput | SortOrder
    bloodPressureDiastolic?: SortOrderInput | SortOrder
    heartRate?: SortOrderInput | SortOrder
    conditions?: SortOrderInput | SortOrder
    allergies?: SortOrderInput | SortOrder
    medications?: SortOrderInput | SortOrder
    vaccinationRecords?: SortOrderInput | SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthProfileCountOrderByAggregateInput
    _avg?: HealthProfileAvgOrderByAggregateInput
    _max?: HealthProfileMaxOrderByAggregateInput
    _min?: HealthProfileMinOrderByAggregateInput
    _sum?: HealthProfileSumOrderByAggregateInput
  }

  export type HealthProfileScalarWhereWithAggregatesInput = {
    AND?: HealthProfileScalarWhereWithAggregatesInput | HealthProfileScalarWhereWithAggregatesInput[]
    OR?: HealthProfileScalarWhereWithAggregatesInput[]
    NOT?: HealthProfileScalarWhereWithAggregatesInput | HealthProfileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthProfile"> | number
    userId?: IntWithAggregatesFilter<"HealthProfile"> | number
    heightCm?: FloatNullableWithAggregatesFilter<"HealthProfile"> | number | null
    weightKg?: FloatNullableWithAggregatesFilter<"HealthProfile"> | number | null
    bmi?: FloatNullableWithAggregatesFilter<"HealthProfile"> | number | null
    bloodPressureSystolic?: IntNullableWithAggregatesFilter<"HealthProfile"> | number | null
    bloodPressureDiastolic?: IntNullableWithAggregatesFilter<"HealthProfile"> | number | null
    heartRate?: IntNullableWithAggregatesFilter<"HealthProfile"> | number | null
    conditions?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    allergies?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    medications?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    vaccinationRecords?: StringNullableWithAggregatesFilter<"HealthProfile"> | string | null
    healthScore?: IntWithAggregatesFilter<"HealthProfile"> | number
    createdAt?: DateTimeWithAggregatesFilter<"HealthProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthProfile"> | Date | string
  }

  export type DoctorWhereInput = {
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    id?: IntFilter<"Doctor"> | number
    uuid?: StringFilter<"Doctor"> | string
    userId?: IntFilter<"Doctor"> | number
    specialty?: StringFilter<"Doctor"> | string
    qualifications?: StringNullableFilter<"Doctor"> | string | null
    experienceYears?: IntNullableFilter<"Doctor"> | number | null
    licenseNumber?: StringNullableFilter<"Doctor"> | string | null
    clinicName?: StringNullableFilter<"Doctor"> | string | null
    clinicAddress?: StringNullableFilter<"Doctor"> | string | null
    latitude?: FloatNullableFilter<"Doctor"> | number | null
    longitude?: FloatNullableFilter<"Doctor"> | number | null
    consultationFee?: FloatFilter<"Doctor"> | number
    averageRating?: FloatFilter<"Doctor"> | number
    totalRatings?: IntFilter<"Doctor"> | number
    availability?: StringNullableFilter<"Doctor"> | string | null
    isVerified?: BoolFilter<"Doctor"> | boolean
    verificationDocuments?: StringNullableFilter<"Doctor"> | string | null
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    reviews?: DoctorReviewListRelationFilter
  }

  export type DoctorOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    specialty?: SortOrder
    qualifications?: SortOrderInput | SortOrder
    experienceYears?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    clinicAddress?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    availability?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationDocuments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    appointments?: AppointmentOrderByRelationAggregateInput
    reviews?: DoctorReviewOrderByRelationAggregateInput
  }

  export type DoctorWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    userId?: number
    licenseNumber?: string
    AND?: DoctorWhereInput | DoctorWhereInput[]
    OR?: DoctorWhereInput[]
    NOT?: DoctorWhereInput | DoctorWhereInput[]
    specialty?: StringFilter<"Doctor"> | string
    qualifications?: StringNullableFilter<"Doctor"> | string | null
    experienceYears?: IntNullableFilter<"Doctor"> | number | null
    clinicName?: StringNullableFilter<"Doctor"> | string | null
    clinicAddress?: StringNullableFilter<"Doctor"> | string | null
    latitude?: FloatNullableFilter<"Doctor"> | number | null
    longitude?: FloatNullableFilter<"Doctor"> | number | null
    consultationFee?: FloatFilter<"Doctor"> | number
    averageRating?: FloatFilter<"Doctor"> | number
    totalRatings?: IntFilter<"Doctor"> | number
    availability?: StringNullableFilter<"Doctor"> | string | null
    isVerified?: BoolFilter<"Doctor"> | boolean
    verificationDocuments?: StringNullableFilter<"Doctor"> | string | null
    createdAt?: DateTimeFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeFilter<"Doctor"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    appointments?: AppointmentListRelationFilter
    reviews?: DoctorReviewListRelationFilter
  }, "id" | "uuid" | "userId" | "licenseNumber">

  export type DoctorOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    specialty?: SortOrder
    qualifications?: SortOrderInput | SortOrder
    experienceYears?: SortOrderInput | SortOrder
    licenseNumber?: SortOrderInput | SortOrder
    clinicName?: SortOrderInput | SortOrder
    clinicAddress?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    availability?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verificationDocuments?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DoctorCountOrderByAggregateInput
    _avg?: DoctorAvgOrderByAggregateInput
    _max?: DoctorMaxOrderByAggregateInput
    _min?: DoctorMinOrderByAggregateInput
    _sum?: DoctorSumOrderByAggregateInput
  }

  export type DoctorScalarWhereWithAggregatesInput = {
    AND?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    OR?: DoctorScalarWhereWithAggregatesInput[]
    NOT?: DoctorScalarWhereWithAggregatesInput | DoctorScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Doctor"> | number
    uuid?: StringWithAggregatesFilter<"Doctor"> | string
    userId?: IntWithAggregatesFilter<"Doctor"> | number
    specialty?: StringWithAggregatesFilter<"Doctor"> | string
    qualifications?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    experienceYears?: IntNullableWithAggregatesFilter<"Doctor"> | number | null
    licenseNumber?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    clinicName?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    clinicAddress?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    latitude?: FloatNullableWithAggregatesFilter<"Doctor"> | number | null
    longitude?: FloatNullableWithAggregatesFilter<"Doctor"> | number | null
    consultationFee?: FloatWithAggregatesFilter<"Doctor"> | number
    averageRating?: FloatWithAggregatesFilter<"Doctor"> | number
    totalRatings?: IntWithAggregatesFilter<"Doctor"> | number
    availability?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    isVerified?: BoolWithAggregatesFilter<"Doctor"> | boolean
    verificationDocuments?: StringNullableWithAggregatesFilter<"Doctor"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Doctor"> | Date | string
  }

  export type DoctorReviewWhereInput = {
    AND?: DoctorReviewWhereInput | DoctorReviewWhereInput[]
    OR?: DoctorReviewWhereInput[]
    NOT?: DoctorReviewWhereInput | DoctorReviewWhereInput[]
    id?: IntFilter<"DoctorReview"> | number
    uuid?: StringFilter<"DoctorReview"> | string
    doctorId?: IntFilter<"DoctorReview"> | number
    userId?: IntFilter<"DoctorReview"> | number
    appointmentId?: IntNullableFilter<"DoctorReview"> | number | null
    rating?: IntFilter<"DoctorReview"> | number
    review?: StringNullableFilter<"DoctorReview"> | string | null
    verified?: BoolFilter<"DoctorReview"> | boolean
    helpfulCount?: IntFilter<"DoctorReview"> | number
    createdAt?: DateTimeFilter<"DoctorReview"> | Date | string
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
  }

  export type DoctorReviewOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    verified?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    doctor?: DoctorOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type DoctorReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: DoctorReviewWhereInput | DoctorReviewWhereInput[]
    OR?: DoctorReviewWhereInput[]
    NOT?: DoctorReviewWhereInput | DoctorReviewWhereInput[]
    doctorId?: IntFilter<"DoctorReview"> | number
    userId?: IntFilter<"DoctorReview"> | number
    appointmentId?: IntNullableFilter<"DoctorReview"> | number | null
    rating?: IntFilter<"DoctorReview"> | number
    review?: StringNullableFilter<"DoctorReview"> | string | null
    verified?: BoolFilter<"DoctorReview"> | boolean
    helpfulCount?: IntFilter<"DoctorReview"> | number
    createdAt?: DateTimeFilter<"DoctorReview"> | Date | string
    doctor?: XOR<DoctorRelationFilter, DoctorWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    appointment?: XOR<AppointmentNullableRelationFilter, AppointmentWhereInput> | null
  }, "id" | "uuid">

  export type DoctorReviewOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    rating?: SortOrder
    review?: SortOrderInput | SortOrder
    verified?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    _count?: DoctorReviewCountOrderByAggregateInput
    _avg?: DoctorReviewAvgOrderByAggregateInput
    _max?: DoctorReviewMaxOrderByAggregateInput
    _min?: DoctorReviewMinOrderByAggregateInput
    _sum?: DoctorReviewSumOrderByAggregateInput
  }

  export type DoctorReviewScalarWhereWithAggregatesInput = {
    AND?: DoctorReviewScalarWhereWithAggregatesInput | DoctorReviewScalarWhereWithAggregatesInput[]
    OR?: DoctorReviewScalarWhereWithAggregatesInput[]
    NOT?: DoctorReviewScalarWhereWithAggregatesInput | DoctorReviewScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"DoctorReview"> | number
    uuid?: StringWithAggregatesFilter<"DoctorReview"> | string
    doctorId?: IntWithAggregatesFilter<"DoctorReview"> | number
    userId?: IntWithAggregatesFilter<"DoctorReview"> | number
    appointmentId?: IntNullableWithAggregatesFilter<"DoctorReview"> | number | null
    rating?: IntWithAggregatesFilter<"DoctorReview"> | number
    review?: StringNullableWithAggregatesFilter<"DoctorReview"> | string | null
    verified?: BoolWithAggregatesFilter<"DoctorReview"> | boolean
    helpfulCount?: IntWithAggregatesFilter<"DoctorReview"> | number
    createdAt?: DateTimeWithAggregatesFilter<"DoctorReview"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: IntFilter<"Appointment"> | number
    uuid?: StringFilter<"Appointment"> | string
    userId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    consultationType?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    meetingLink?: StringNullableFilter<"Appointment"> | string | null
    recordingUrl?: StringNullableFilter<"Appointment"> | string | null
    prescriptionId?: IntNullableFilter<"Appointment"> | number | null
    paymentId?: StringNullableFilter<"Appointment"> | string | null
    paymentStatus?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    doctorProfile?: XOR<DoctorRelationFilter, DoctorWhereInput>
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    callSession?: XOR<CallSessionNullableRelationFilter, CallSessionWhereInput> | null
    reviews?: DoctorReviewListRelationFilter
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    consultationType?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    doctor?: UserOrderByWithRelationInput
    doctorProfile?: DoctorOrderByWithRelationInput
    prescription?: PrescriptionOrderByWithRelationInput
    callSession?: CallSessionOrderByWithRelationInput
    reviews?: DoctorReviewOrderByRelationAggregateInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    userId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    consultationType?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    meetingLink?: StringNullableFilter<"Appointment"> | string | null
    recordingUrl?: StringNullableFilter<"Appointment"> | string | null
    prescriptionId?: IntNullableFilter<"Appointment"> | number | null
    paymentId?: StringNullableFilter<"Appointment"> | string | null
    paymentStatus?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    doctor?: XOR<UserRelationFilter, UserWhereInput>
    doctorProfile?: XOR<DoctorRelationFilter, DoctorWhereInput>
    prescription?: XOR<PrescriptionNullableRelationFilter, PrescriptionWhereInput> | null
    callSession?: XOR<CallSessionNullableRelationFilter, CallSessionWhereInput> | null
    reviews?: DoctorReviewListRelationFilter
  }, "id" | "uuid">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    consultationType?: SortOrder
    status?: SortOrder
    reason?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    prescriptionId?: SortOrderInput | SortOrder
    paymentId?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _avg?: AppointmentAvgOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
    _sum?: AppointmentSumOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Appointment"> | number
    uuid?: StringWithAggregatesFilter<"Appointment"> | string
    userId?: IntWithAggregatesFilter<"Appointment"> | number
    doctorId?: IntWithAggregatesFilter<"Appointment"> | number
    appointmentDate?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    consultationType?: StringWithAggregatesFilter<"Appointment"> | string
    status?: StringWithAggregatesFilter<"Appointment"> | string
    reason?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    meetingLink?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    prescriptionId?: IntNullableWithAggregatesFilter<"Appointment"> | number | null
    paymentId?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"Appointment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type PrescriptionWhereInput = {
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    id?: IntFilter<"Prescription"> | number
    uuid?: StringFilter<"Prescription"> | string
    appointmentId?: IntNullableFilter<"Prescription"> | number | null
    doctorId?: IntFilter<"Prescription"> | number
    userId?: IntFilter<"Prescription"> | number
    medicines?: StringFilter<"Prescription"> | string
    instructions?: StringNullableFilter<"Prescription"> | string | null
    validityDays?: IntFilter<"Prescription"> | number
    issuedAt?: DateTimeFilter<"Prescription"> | Date | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    appointments?: AppointmentListRelationFilter
  }

  export type PrescriptionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    medicines?: SortOrder
    instructions?: SortOrderInput | SortOrder
    validityDays?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
    appointments?: AppointmentOrderByRelationAggregateInput
  }

  export type PrescriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: PrescriptionWhereInput | PrescriptionWhereInput[]
    OR?: PrescriptionWhereInput[]
    NOT?: PrescriptionWhereInput | PrescriptionWhereInput[]
    appointmentId?: IntNullableFilter<"Prescription"> | number | null
    doctorId?: IntFilter<"Prescription"> | number
    userId?: IntFilter<"Prescription"> | number
    medicines?: StringFilter<"Prescription"> | string
    instructions?: StringNullableFilter<"Prescription"> | string | null
    validityDays?: IntFilter<"Prescription"> | number
    issuedAt?: DateTimeFilter<"Prescription"> | Date | string
    createdAt?: DateTimeFilter<"Prescription"> | Date | string
    appointments?: AppointmentListRelationFilter
  }, "id" | "uuid">

  export type PrescriptionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrderInput | SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    medicines?: SortOrder
    instructions?: SortOrderInput | SortOrder
    validityDays?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
    _count?: PrescriptionCountOrderByAggregateInput
    _avg?: PrescriptionAvgOrderByAggregateInput
    _max?: PrescriptionMaxOrderByAggregateInput
    _min?: PrescriptionMinOrderByAggregateInput
    _sum?: PrescriptionSumOrderByAggregateInput
  }

  export type PrescriptionScalarWhereWithAggregatesInput = {
    AND?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    OR?: PrescriptionScalarWhereWithAggregatesInput[]
    NOT?: PrescriptionScalarWhereWithAggregatesInput | PrescriptionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Prescription"> | number
    uuid?: StringWithAggregatesFilter<"Prescription"> | string
    appointmentId?: IntNullableWithAggregatesFilter<"Prescription"> | number | null
    doctorId?: IntWithAggregatesFilter<"Prescription"> | number
    userId?: IntWithAggregatesFilter<"Prescription"> | number
    medicines?: StringWithAggregatesFilter<"Prescription"> | string
    instructions?: StringNullableWithAggregatesFilter<"Prescription"> | string | null
    validityDays?: IntWithAggregatesFilter<"Prescription"> | number
    issuedAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Prescription"> | Date | string
  }

  export type CallSessionWhereInput = {
    AND?: CallSessionWhereInput | CallSessionWhereInput[]
    OR?: CallSessionWhereInput[]
    NOT?: CallSessionWhereInput | CallSessionWhereInput[]
    id?: IntFilter<"CallSession"> | number
    uuid?: StringFilter<"CallSession"> | string
    appointmentId?: IntFilter<"CallSession"> | number
    roomId?: StringNullableFilter<"CallSession"> | string | null
    provider?: StringNullableFilter<"CallSession"> | string | null
    token?: StringNullableFilter<"CallSession"> | string | null
    startedAt?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    recordingUrl?: StringNullableFilter<"CallSession"> | string | null
    createdAt?: DateTimeFilter<"CallSession"> | Date | string
    appointment?: XOR<AppointmentRelationFilter, AppointmentWhereInput>
  }

  export type CallSessionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    appointment?: AppointmentOrderByWithRelationInput
  }

  export type CallSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    appointmentId?: number
    AND?: CallSessionWhereInput | CallSessionWhereInput[]
    OR?: CallSessionWhereInput[]
    NOT?: CallSessionWhereInput | CallSessionWhereInput[]
    roomId?: StringNullableFilter<"CallSession"> | string | null
    provider?: StringNullableFilter<"CallSession"> | string | null
    token?: StringNullableFilter<"CallSession"> | string | null
    startedAt?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    endedAt?: DateTimeNullableFilter<"CallSession"> | Date | string | null
    recordingUrl?: StringNullableFilter<"CallSession"> | string | null
    createdAt?: DateTimeFilter<"CallSession"> | Date | string
    appointment?: XOR<AppointmentRelationFilter, AppointmentWhereInput>
  }, "id" | "uuid" | "appointmentId">

  export type CallSessionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    roomId?: SortOrderInput | SortOrder
    provider?: SortOrderInput | SortOrder
    token?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    endedAt?: SortOrderInput | SortOrder
    recordingUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: CallSessionCountOrderByAggregateInput
    _avg?: CallSessionAvgOrderByAggregateInput
    _max?: CallSessionMaxOrderByAggregateInput
    _min?: CallSessionMinOrderByAggregateInput
    _sum?: CallSessionSumOrderByAggregateInput
  }

  export type CallSessionScalarWhereWithAggregatesInput = {
    AND?: CallSessionScalarWhereWithAggregatesInput | CallSessionScalarWhereWithAggregatesInput[]
    OR?: CallSessionScalarWhereWithAggregatesInput[]
    NOT?: CallSessionScalarWhereWithAggregatesInput | CallSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CallSession"> | number
    uuid?: StringWithAggregatesFilter<"CallSession"> | string
    appointmentId?: IntWithAggregatesFilter<"CallSession"> | number
    roomId?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    provider?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    token?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"CallSession"> | Date | string | null
    endedAt?: DateTimeNullableWithAggregatesFilter<"CallSession"> | Date | string | null
    recordingUrl?: StringNullableWithAggregatesFilter<"CallSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CallSession"> | Date | string
  }

  export type MedicineWhereInput = {
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    id?: IntFilter<"Medicine"> | number
    uuid?: StringFilter<"Medicine"> | string
    name?: StringFilter<"Medicine"> | string
    composition?: StringNullableFilter<"Medicine"> | string | null
    category?: StringNullableFilter<"Medicine"> | string | null
    price?: FloatFilter<"Medicine"> | number
    manufacturer?: StringNullableFilter<"Medicine"> | string | null
    stockQty?: IntFilter<"Medicine"> | number
    description?: StringNullableFilter<"Medicine"> | string | null
    sideEffects?: StringNullableFilter<"Medicine"> | string | null
    interactions?: StringNullableFilter<"Medicine"> | string | null
    requiresPrescription?: BoolFilter<"Medicine"> | boolean
    available?: BoolFilter<"Medicine"> | boolean
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    orderItems?: MedicineOrderItemListRelationFilter
  }

  export type MedicineOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    composition?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    stockQty?: SortOrder
    description?: SortOrderInput | SortOrder
    sideEffects?: SortOrderInput | SortOrder
    interactions?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    orderItems?: MedicineOrderItemOrderByRelationAggregateInput
  }

  export type MedicineWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: MedicineWhereInput | MedicineWhereInput[]
    OR?: MedicineWhereInput[]
    NOT?: MedicineWhereInput | MedicineWhereInput[]
    name?: StringFilter<"Medicine"> | string
    composition?: StringNullableFilter<"Medicine"> | string | null
    category?: StringNullableFilter<"Medicine"> | string | null
    price?: FloatFilter<"Medicine"> | number
    manufacturer?: StringNullableFilter<"Medicine"> | string | null
    stockQty?: IntFilter<"Medicine"> | number
    description?: StringNullableFilter<"Medicine"> | string | null
    sideEffects?: StringNullableFilter<"Medicine"> | string | null
    interactions?: StringNullableFilter<"Medicine"> | string | null
    requiresPrescription?: BoolFilter<"Medicine"> | boolean
    available?: BoolFilter<"Medicine"> | boolean
    createdAt?: DateTimeFilter<"Medicine"> | Date | string
    orderItems?: MedicineOrderItemListRelationFilter
  }, "id" | "uuid">

  export type MedicineOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    composition?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    manufacturer?: SortOrderInput | SortOrder
    stockQty?: SortOrder
    description?: SortOrderInput | SortOrder
    sideEffects?: SortOrderInput | SortOrder
    interactions?: SortOrderInput | SortOrder
    requiresPrescription?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    _count?: MedicineCountOrderByAggregateInput
    _avg?: MedicineAvgOrderByAggregateInput
    _max?: MedicineMaxOrderByAggregateInput
    _min?: MedicineMinOrderByAggregateInput
    _sum?: MedicineSumOrderByAggregateInput
  }

  export type MedicineScalarWhereWithAggregatesInput = {
    AND?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    OR?: MedicineScalarWhereWithAggregatesInput[]
    NOT?: MedicineScalarWhereWithAggregatesInput | MedicineScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Medicine"> | number
    uuid?: StringWithAggregatesFilter<"Medicine"> | string
    name?: StringWithAggregatesFilter<"Medicine"> | string
    composition?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    category?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    price?: FloatWithAggregatesFilter<"Medicine"> | number
    manufacturer?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    stockQty?: IntWithAggregatesFilter<"Medicine"> | number
    description?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    sideEffects?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    interactions?: StringNullableWithAggregatesFilter<"Medicine"> | string | null
    requiresPrescription?: BoolWithAggregatesFilter<"Medicine"> | boolean
    available?: BoolWithAggregatesFilter<"Medicine"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Medicine"> | Date | string
  }

  export type MedicineOrderWhereInput = {
    AND?: MedicineOrderWhereInput | MedicineOrderWhereInput[]
    OR?: MedicineOrderWhereInput[]
    NOT?: MedicineOrderWhereInput | MedicineOrderWhereInput[]
    id?: IntFilter<"MedicineOrder"> | number
    uuid?: StringFilter<"MedicineOrder"> | string
    userId?: IntFilter<"MedicineOrder"> | number
    orderDate?: DateTimeFilter<"MedicineOrder"> | Date | string
    deliveryAddress?: StringFilter<"MedicineOrder"> | string
    status?: StringFilter<"MedicineOrder"> | string
    totalAmount?: FloatFilter<"MedicineOrder"> | number
    paymentMethod?: StringNullableFilter<"MedicineOrder"> | string | null
    paymentStatus?: StringFilter<"MedicineOrder"> | string
    prescriptionUrl?: StringNullableFilter<"MedicineOrder"> | string | null
    deliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    trackingNumber?: StringNullableFilter<"MedicineOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicineOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineOrder"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: MedicineOrderItemListRelationFilter
  }

  export type MedicineOrderOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    deliveryAddress?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    prescriptionUrl?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    items?: MedicineOrderItemOrderByRelationAggregateInput
  }

  export type MedicineOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: MedicineOrderWhereInput | MedicineOrderWhereInput[]
    OR?: MedicineOrderWhereInput[]
    NOT?: MedicineOrderWhereInput | MedicineOrderWhereInput[]
    userId?: IntFilter<"MedicineOrder"> | number
    orderDate?: DateTimeFilter<"MedicineOrder"> | Date | string
    deliveryAddress?: StringFilter<"MedicineOrder"> | string
    status?: StringFilter<"MedicineOrder"> | string
    totalAmount?: FloatFilter<"MedicineOrder"> | number
    paymentMethod?: StringNullableFilter<"MedicineOrder"> | string | null
    paymentStatus?: StringFilter<"MedicineOrder"> | string
    prescriptionUrl?: StringNullableFilter<"MedicineOrder"> | string | null
    deliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    trackingNumber?: StringNullableFilter<"MedicineOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicineOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineOrder"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    items?: MedicineOrderItemListRelationFilter
  }, "id" | "uuid">

  export type MedicineOrderOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    deliveryAddress?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    paymentStatus?: SortOrder
    prescriptionUrl?: SortOrderInput | SortOrder
    deliveryDate?: SortOrderInput | SortOrder
    expectedDeliveryDate?: SortOrderInput | SortOrder
    trackingNumber?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MedicineOrderCountOrderByAggregateInput
    _avg?: MedicineOrderAvgOrderByAggregateInput
    _max?: MedicineOrderMaxOrderByAggregateInput
    _min?: MedicineOrderMinOrderByAggregateInput
    _sum?: MedicineOrderSumOrderByAggregateInput
  }

  export type MedicineOrderScalarWhereWithAggregatesInput = {
    AND?: MedicineOrderScalarWhereWithAggregatesInput | MedicineOrderScalarWhereWithAggregatesInput[]
    OR?: MedicineOrderScalarWhereWithAggregatesInput[]
    NOT?: MedicineOrderScalarWhereWithAggregatesInput | MedicineOrderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineOrder"> | number
    uuid?: StringWithAggregatesFilter<"MedicineOrder"> | string
    userId?: IntWithAggregatesFilter<"MedicineOrder"> | number
    orderDate?: DateTimeWithAggregatesFilter<"MedicineOrder"> | Date | string
    deliveryAddress?: StringWithAggregatesFilter<"MedicineOrder"> | string
    status?: StringWithAggregatesFilter<"MedicineOrder"> | string
    totalAmount?: FloatWithAggregatesFilter<"MedicineOrder"> | number
    paymentMethod?: StringNullableWithAggregatesFilter<"MedicineOrder"> | string | null
    paymentStatus?: StringWithAggregatesFilter<"MedicineOrder"> | string
    prescriptionUrl?: StringNullableWithAggregatesFilter<"MedicineOrder"> | string | null
    deliveryDate?: DateTimeNullableWithAggregatesFilter<"MedicineOrder"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableWithAggregatesFilter<"MedicineOrder"> | Date | string | null
    trackingNumber?: StringNullableWithAggregatesFilter<"MedicineOrder"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MedicineOrder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MedicineOrder"> | Date | string
  }

  export type MedicineOrderItemWhereInput = {
    AND?: MedicineOrderItemWhereInput | MedicineOrderItemWhereInput[]
    OR?: MedicineOrderItemWhereInput[]
    NOT?: MedicineOrderItemWhereInput | MedicineOrderItemWhereInput[]
    id?: IntFilter<"MedicineOrderItem"> | number
    orderId?: IntFilter<"MedicineOrderItem"> | number
    medicineId?: IntFilter<"MedicineOrderItem"> | number
    quantity?: IntFilter<"MedicineOrderItem"> | number
    price?: FloatFilter<"MedicineOrderItem"> | number
    order?: XOR<MedicineOrderRelationFilter, MedicineOrderWhereInput>
    medicine?: XOR<MedicineRelationFilter, MedicineWhereInput>
  }

  export type MedicineOrderItemOrderByWithRelationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    order?: MedicineOrderOrderByWithRelationInput
    medicine?: MedicineOrderByWithRelationInput
  }

  export type MedicineOrderItemWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    orderId_medicineId?: MedicineOrderItemOrderIdMedicineIdCompoundUniqueInput
    AND?: MedicineOrderItemWhereInput | MedicineOrderItemWhereInput[]
    OR?: MedicineOrderItemWhereInput[]
    NOT?: MedicineOrderItemWhereInput | MedicineOrderItemWhereInput[]
    orderId?: IntFilter<"MedicineOrderItem"> | number
    medicineId?: IntFilter<"MedicineOrderItem"> | number
    quantity?: IntFilter<"MedicineOrderItem"> | number
    price?: FloatFilter<"MedicineOrderItem"> | number
    order?: XOR<MedicineOrderRelationFilter, MedicineOrderWhereInput>
    medicine?: XOR<MedicineRelationFilter, MedicineWhereInput>
  }, "id" | "orderId_medicineId">

  export type MedicineOrderItemOrderByWithAggregationInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
    _count?: MedicineOrderItemCountOrderByAggregateInput
    _avg?: MedicineOrderItemAvgOrderByAggregateInput
    _max?: MedicineOrderItemMaxOrderByAggregateInput
    _min?: MedicineOrderItemMinOrderByAggregateInput
    _sum?: MedicineOrderItemSumOrderByAggregateInput
  }

  export type MedicineOrderItemScalarWhereWithAggregatesInput = {
    AND?: MedicineOrderItemScalarWhereWithAggregatesInput | MedicineOrderItemScalarWhereWithAggregatesInput[]
    OR?: MedicineOrderItemScalarWhereWithAggregatesInput[]
    NOT?: MedicineOrderItemScalarWhereWithAggregatesInput | MedicineOrderItemScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MedicineOrderItem"> | number
    orderId?: IntWithAggregatesFilter<"MedicineOrderItem"> | number
    medicineId?: IntWithAggregatesFilter<"MedicineOrderItem"> | number
    quantity?: IntWithAggregatesFilter<"MedicineOrderItem"> | number
    price?: FloatWithAggregatesFilter<"MedicineOrderItem"> | number
  }

  export type LabTestWhereInput = {
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    id?: IntFilter<"LabTest"> | number
    uuid?: StringFilter<"LabTest"> | string
    name?: StringFilter<"LabTest"> | string
    category?: StringNullableFilter<"LabTest"> | string | null
    price?: FloatFilter<"LabTest"> | number
    description?: StringNullableFilter<"LabTest"> | string | null
    preparation?: StringNullableFilter<"LabTest"> | string | null
    parameters?: StringNullableFilter<"LabTest"> | string | null
    turnaroundTime?: StringNullableFilter<"LabTest"> | string | null
    available?: BoolFilter<"LabTest"> | boolean
    createdAt?: DateTimeFilter<"LabTest"> | Date | string
    bookings?: LabBookingTestListRelationFilter
  }

  export type LabTestOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    turnaroundTime?: SortOrderInput | SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    bookings?: LabBookingTestOrderByRelationAggregateInput
  }

  export type LabTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: LabTestWhereInput | LabTestWhereInput[]
    OR?: LabTestWhereInput[]
    NOT?: LabTestWhereInput | LabTestWhereInput[]
    name?: StringFilter<"LabTest"> | string
    category?: StringNullableFilter<"LabTest"> | string | null
    price?: FloatFilter<"LabTest"> | number
    description?: StringNullableFilter<"LabTest"> | string | null
    preparation?: StringNullableFilter<"LabTest"> | string | null
    parameters?: StringNullableFilter<"LabTest"> | string | null
    turnaroundTime?: StringNullableFilter<"LabTest"> | string | null
    available?: BoolFilter<"LabTest"> | boolean
    createdAt?: DateTimeFilter<"LabTest"> | Date | string
    bookings?: LabBookingTestListRelationFilter
  }, "id" | "uuid">

  export type LabTestOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    category?: SortOrderInput | SortOrder
    price?: SortOrder
    description?: SortOrderInput | SortOrder
    preparation?: SortOrderInput | SortOrder
    parameters?: SortOrderInput | SortOrder
    turnaroundTime?: SortOrderInput | SortOrder
    available?: SortOrder
    createdAt?: SortOrder
    _count?: LabTestCountOrderByAggregateInput
    _avg?: LabTestAvgOrderByAggregateInput
    _max?: LabTestMaxOrderByAggregateInput
    _min?: LabTestMinOrderByAggregateInput
    _sum?: LabTestSumOrderByAggregateInput
  }

  export type LabTestScalarWhereWithAggregatesInput = {
    AND?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    OR?: LabTestScalarWhereWithAggregatesInput[]
    NOT?: LabTestScalarWhereWithAggregatesInput | LabTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabTest"> | number
    uuid?: StringWithAggregatesFilter<"LabTest"> | string
    name?: StringWithAggregatesFilter<"LabTest"> | string
    category?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    price?: FloatWithAggregatesFilter<"LabTest"> | number
    description?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    preparation?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    parameters?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    turnaroundTime?: StringNullableWithAggregatesFilter<"LabTest"> | string | null
    available?: BoolWithAggregatesFilter<"LabTest"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"LabTest"> | Date | string
  }

  export type LabBookingWhereInput = {
    AND?: LabBookingWhereInput | LabBookingWhereInput[]
    OR?: LabBookingWhereInput[]
    NOT?: LabBookingWhereInput | LabBookingWhereInput[]
    id?: IntFilter<"LabBooking"> | number
    uuid?: StringFilter<"LabBooking"> | string
    userId?: IntFilter<"LabBooking"> | number
    bookingDate?: DateTimeFilter<"LabBooking"> | Date | string
    collectionType?: StringFilter<"LabBooking"> | string
    address?: StringNullableFilter<"LabBooking"> | string | null
    status?: StringFilter<"LabBooking"> | string
    totalAmount?: FloatFilter<"LabBooking"> | number
    paymentStatus?: StringFilter<"LabBooking"> | string
    reportUrl?: StringNullableFilter<"LabBooking"> | string | null
    reportReadyDate?: DateTimeNullableFilter<"LabBooking"> | Date | string | null
    createdAt?: DateTimeFilter<"LabBooking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tests?: LabBookingTestListRelationFilter
    report?: XOR<LabReportNullableRelationFilter, LabReportWhereInput> | null
  }

  export type LabBookingOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    bookingDate?: SortOrder
    collectionType?: SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    reportUrl?: SortOrderInput | SortOrder
    reportReadyDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    tests?: LabBookingTestOrderByRelationAggregateInput
    report?: LabReportOrderByWithRelationInput
  }

  export type LabBookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: LabBookingWhereInput | LabBookingWhereInput[]
    OR?: LabBookingWhereInput[]
    NOT?: LabBookingWhereInput | LabBookingWhereInput[]
    userId?: IntFilter<"LabBooking"> | number
    bookingDate?: DateTimeFilter<"LabBooking"> | Date | string
    collectionType?: StringFilter<"LabBooking"> | string
    address?: StringNullableFilter<"LabBooking"> | string | null
    status?: StringFilter<"LabBooking"> | string
    totalAmount?: FloatFilter<"LabBooking"> | number
    paymentStatus?: StringFilter<"LabBooking"> | string
    reportUrl?: StringNullableFilter<"LabBooking"> | string | null
    reportReadyDate?: DateTimeNullableFilter<"LabBooking"> | Date | string | null
    createdAt?: DateTimeFilter<"LabBooking"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    tests?: LabBookingTestListRelationFilter
    report?: XOR<LabReportNullableRelationFilter, LabReportWhereInput> | null
  }, "id" | "uuid">

  export type LabBookingOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    bookingDate?: SortOrder
    collectionType?: SortOrder
    address?: SortOrderInput | SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    reportUrl?: SortOrderInput | SortOrder
    reportReadyDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LabBookingCountOrderByAggregateInput
    _avg?: LabBookingAvgOrderByAggregateInput
    _max?: LabBookingMaxOrderByAggregateInput
    _min?: LabBookingMinOrderByAggregateInput
    _sum?: LabBookingSumOrderByAggregateInput
  }

  export type LabBookingScalarWhereWithAggregatesInput = {
    AND?: LabBookingScalarWhereWithAggregatesInput | LabBookingScalarWhereWithAggregatesInput[]
    OR?: LabBookingScalarWhereWithAggregatesInput[]
    NOT?: LabBookingScalarWhereWithAggregatesInput | LabBookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabBooking"> | number
    uuid?: StringWithAggregatesFilter<"LabBooking"> | string
    userId?: IntWithAggregatesFilter<"LabBooking"> | number
    bookingDate?: DateTimeWithAggregatesFilter<"LabBooking"> | Date | string
    collectionType?: StringWithAggregatesFilter<"LabBooking"> | string
    address?: StringNullableWithAggregatesFilter<"LabBooking"> | string | null
    status?: StringWithAggregatesFilter<"LabBooking"> | string
    totalAmount?: FloatWithAggregatesFilter<"LabBooking"> | number
    paymentStatus?: StringWithAggregatesFilter<"LabBooking"> | string
    reportUrl?: StringNullableWithAggregatesFilter<"LabBooking"> | string | null
    reportReadyDate?: DateTimeNullableWithAggregatesFilter<"LabBooking"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LabBooking"> | Date | string
  }

  export type LabBookingTestWhereInput = {
    AND?: LabBookingTestWhereInput | LabBookingTestWhereInput[]
    OR?: LabBookingTestWhereInput[]
    NOT?: LabBookingTestWhereInput | LabBookingTestWhereInput[]
    id?: IntFilter<"LabBookingTest"> | number
    bookingId?: IntFilter<"LabBookingTest"> | number
    testId?: IntFilter<"LabBookingTest"> | number
    booking?: XOR<LabBookingRelationFilter, LabBookingWhereInput>
    test?: XOR<LabTestRelationFilter, LabTestWhereInput>
  }

  export type LabBookingTestOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
    booking?: LabBookingOrderByWithRelationInput
    test?: LabTestOrderByWithRelationInput
  }

  export type LabBookingTestWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId_testId?: LabBookingTestBookingIdTestIdCompoundUniqueInput
    AND?: LabBookingTestWhereInput | LabBookingTestWhereInput[]
    OR?: LabBookingTestWhereInput[]
    NOT?: LabBookingTestWhereInput | LabBookingTestWhereInput[]
    bookingId?: IntFilter<"LabBookingTest"> | number
    testId?: IntFilter<"LabBookingTest"> | number
    booking?: XOR<LabBookingRelationFilter, LabBookingWhereInput>
    test?: XOR<LabTestRelationFilter, LabTestWhereInput>
  }, "id" | "bookingId_testId">

  export type LabBookingTestOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
    _count?: LabBookingTestCountOrderByAggregateInput
    _avg?: LabBookingTestAvgOrderByAggregateInput
    _max?: LabBookingTestMaxOrderByAggregateInput
    _min?: LabBookingTestMinOrderByAggregateInput
    _sum?: LabBookingTestSumOrderByAggregateInput
  }

  export type LabBookingTestScalarWhereWithAggregatesInput = {
    AND?: LabBookingTestScalarWhereWithAggregatesInput | LabBookingTestScalarWhereWithAggregatesInput[]
    OR?: LabBookingTestScalarWhereWithAggregatesInput[]
    NOT?: LabBookingTestScalarWhereWithAggregatesInput | LabBookingTestScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabBookingTest"> | number
    bookingId?: IntWithAggregatesFilter<"LabBookingTest"> | number
    testId?: IntWithAggregatesFilter<"LabBookingTest"> | number
  }

  export type LabReportWhereInput = {
    AND?: LabReportWhereInput | LabReportWhereInput[]
    OR?: LabReportWhereInput[]
    NOT?: LabReportWhereInput | LabReportWhereInput[]
    id?: IntFilter<"LabReport"> | number
    uuid?: StringFilter<"LabReport"> | string
    bookingId?: IntFilter<"LabReport"> | number
    reportUrl?: StringFilter<"LabReport"> | string
    results?: StringNullableFilter<"LabReport"> | string | null
    status?: StringFilter<"LabReport"> | string
    reviewedById?: IntNullableFilter<"LabReport"> | number | null
    interpretation?: StringNullableFilter<"LabReport"> | string | null
    recommendations?: StringNullableFilter<"LabReport"> | string | null
    readyAt?: DateTimeNullableFilter<"LabReport"> | Date | string | null
    createdAt?: DateTimeFilter<"LabReport"> | Date | string
    booking?: XOR<LabBookingRelationFilter, LabBookingWhereInput>
  }

  export type LabReportOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    bookingId?: SortOrder
    reportUrl?: SortOrder
    results?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    readyAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    booking?: LabBookingOrderByWithRelationInput
  }

  export type LabReportWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    bookingId?: number
    AND?: LabReportWhereInput | LabReportWhereInput[]
    OR?: LabReportWhereInput[]
    NOT?: LabReportWhereInput | LabReportWhereInput[]
    reportUrl?: StringFilter<"LabReport"> | string
    results?: StringNullableFilter<"LabReport"> | string | null
    status?: StringFilter<"LabReport"> | string
    reviewedById?: IntNullableFilter<"LabReport"> | number | null
    interpretation?: StringNullableFilter<"LabReport"> | string | null
    recommendations?: StringNullableFilter<"LabReport"> | string | null
    readyAt?: DateTimeNullableFilter<"LabReport"> | Date | string | null
    createdAt?: DateTimeFilter<"LabReport"> | Date | string
    booking?: XOR<LabBookingRelationFilter, LabBookingWhereInput>
  }, "id" | "uuid" | "bookingId">

  export type LabReportOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    bookingId?: SortOrder
    reportUrl?: SortOrder
    results?: SortOrderInput | SortOrder
    status?: SortOrder
    reviewedById?: SortOrderInput | SortOrder
    interpretation?: SortOrderInput | SortOrder
    recommendations?: SortOrderInput | SortOrder
    readyAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LabReportCountOrderByAggregateInput
    _avg?: LabReportAvgOrderByAggregateInput
    _max?: LabReportMaxOrderByAggregateInput
    _min?: LabReportMinOrderByAggregateInput
    _sum?: LabReportSumOrderByAggregateInput
  }

  export type LabReportScalarWhereWithAggregatesInput = {
    AND?: LabReportScalarWhereWithAggregatesInput | LabReportScalarWhereWithAggregatesInput[]
    OR?: LabReportScalarWhereWithAggregatesInput[]
    NOT?: LabReportScalarWhereWithAggregatesInput | LabReportScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"LabReport"> | number
    uuid?: StringWithAggregatesFilter<"LabReport"> | string
    bookingId?: IntWithAggregatesFilter<"LabReport"> | number
    reportUrl?: StringWithAggregatesFilter<"LabReport"> | string
    results?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    status?: StringWithAggregatesFilter<"LabReport"> | string
    reviewedById?: IntNullableWithAggregatesFilter<"LabReport"> | number | null
    interpretation?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    recommendations?: StringNullableWithAggregatesFilter<"LabReport"> | string | null
    readyAt?: DateTimeNullableWithAggregatesFilter<"LabReport"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LabReport"> | Date | string
  }

  export type HealthRecordWhereInput = {
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    id?: IntFilter<"HealthRecord"> | number
    uuid?: StringFilter<"HealthRecord"> | string
    userId?: IntFilter<"HealthRecord"> | number
    recordType?: StringFilter<"HealthRecord"> | string
    title?: StringFilter<"HealthRecord"> | string
    description?: StringNullableFilter<"HealthRecord"> | string | null
    fileUrl?: StringFilter<"HealthRecord"> | string
    fileName?: StringFilter<"HealthRecord"> | string
    fileType?: StringNullableFilter<"HealthRecord"> | string | null
    fileSize?: IntNullableFilter<"HealthRecord"> | number | null
    doctorId?: IntNullableFilter<"HealthRecord"> | number | null
    appointmentId?: IntNullableFilter<"HealthRecord"> | number | null
    documentDate?: DateTimeNullableFilter<"HealthRecord"> | Date | string | null
    isPublic?: BoolFilter<"HealthRecord"> | boolean
    sharedWith?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type HealthRecordOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type HealthRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: HealthRecordWhereInput | HealthRecordWhereInput[]
    OR?: HealthRecordWhereInput[]
    NOT?: HealthRecordWhereInput | HealthRecordWhereInput[]
    userId?: IntFilter<"HealthRecord"> | number
    recordType?: StringFilter<"HealthRecord"> | string
    title?: StringFilter<"HealthRecord"> | string
    description?: StringNullableFilter<"HealthRecord"> | string | null
    fileUrl?: StringFilter<"HealthRecord"> | string
    fileName?: StringFilter<"HealthRecord"> | string
    fileType?: StringNullableFilter<"HealthRecord"> | string | null
    fileSize?: IntNullableFilter<"HealthRecord"> | number | null
    doctorId?: IntNullableFilter<"HealthRecord"> | number | null
    appointmentId?: IntNullableFilter<"HealthRecord"> | number | null
    documentDate?: DateTimeNullableFilter<"HealthRecord"> | Date | string | null
    isPublic?: BoolFilter<"HealthRecord"> | boolean
    sharedWith?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "uuid">

  export type HealthRecordOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    doctorId?: SortOrderInput | SortOrder
    appointmentId?: SortOrderInput | SortOrder
    documentDate?: SortOrderInput | SortOrder
    isPublic?: SortOrder
    sharedWith?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: HealthRecordCountOrderByAggregateInput
    _avg?: HealthRecordAvgOrderByAggregateInput
    _max?: HealthRecordMaxOrderByAggregateInput
    _min?: HealthRecordMinOrderByAggregateInput
    _sum?: HealthRecordSumOrderByAggregateInput
  }

  export type HealthRecordScalarWhereWithAggregatesInput = {
    AND?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    OR?: HealthRecordScalarWhereWithAggregatesInput[]
    NOT?: HealthRecordScalarWhereWithAggregatesInput | HealthRecordScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthRecord"> | number
    uuid?: StringWithAggregatesFilter<"HealthRecord"> | string
    userId?: IntWithAggregatesFilter<"HealthRecord"> | number
    recordType?: StringWithAggregatesFilter<"HealthRecord"> | string
    title?: StringWithAggregatesFilter<"HealthRecord"> | string
    description?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    fileUrl?: StringWithAggregatesFilter<"HealthRecord"> | string
    fileName?: StringWithAggregatesFilter<"HealthRecord"> | string
    fileType?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"HealthRecord"> | number | null
    doctorId?: IntNullableWithAggregatesFilter<"HealthRecord"> | number | null
    appointmentId?: IntNullableWithAggregatesFilter<"HealthRecord"> | number | null
    documentDate?: DateTimeNullableWithAggregatesFilter<"HealthRecord"> | Date | string | null
    isPublic?: BoolWithAggregatesFilter<"HealthRecord"> | boolean
    sharedWith?: StringNullableWithAggregatesFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthRecord"> | Date | string
  }

  export type ForumPostWhereInput = {
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    id?: IntFilter<"ForumPost"> | number
    uuid?: StringFilter<"ForumPost"> | string
    userId?: IntFilter<"ForumPost"> | number
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringFilter<"ForumPost"> | string
    status?: StringFilter<"ForumPost"> | string
    upvotes?: IntFilter<"ForumPost"> | number
    downvotes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    commentsCount?: IntFilter<"ForumPost"> | number
    pinned?: BoolFilter<"ForumPost"> | boolean
    verifiedDoctor?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ForumCommentListRelationFilter
    upvotesByUser?: PostUpvoteListRelationFilter
  }

  export type ForumPostOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
    pinned?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    comments?: ForumCommentOrderByRelationAggregateInput
    upvotesByUser?: PostUpvoteOrderByRelationAggregateInput
  }

  export type ForumPostWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ForumPostWhereInput | ForumPostWhereInput[]
    OR?: ForumPostWhereInput[]
    NOT?: ForumPostWhereInput | ForumPostWhereInput[]
    userId?: IntFilter<"ForumPost"> | number
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringFilter<"ForumPost"> | string
    status?: StringFilter<"ForumPost"> | string
    upvotes?: IntFilter<"ForumPost"> | number
    downvotes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    commentsCount?: IntFilter<"ForumPost"> | number
    pinned?: BoolFilter<"ForumPost"> | boolean
    verifiedDoctor?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    comments?: ForumCommentListRelationFilter
    upvotesByUser?: PostUpvoteListRelationFilter
  }, "id" | "uuid">

  export type ForumPostOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
    pinned?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumPostCountOrderByAggregateInput
    _avg?: ForumPostAvgOrderByAggregateInput
    _max?: ForumPostMaxOrderByAggregateInput
    _min?: ForumPostMinOrderByAggregateInput
    _sum?: ForumPostSumOrderByAggregateInput
  }

  export type ForumPostScalarWhereWithAggregatesInput = {
    AND?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    OR?: ForumPostScalarWhereWithAggregatesInput[]
    NOT?: ForumPostScalarWhereWithAggregatesInput | ForumPostScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ForumPost"> | number
    uuid?: StringWithAggregatesFilter<"ForumPost"> | string
    userId?: IntWithAggregatesFilter<"ForumPost"> | number
    title?: StringWithAggregatesFilter<"ForumPost"> | string
    content?: StringWithAggregatesFilter<"ForumPost"> | string
    category?: StringWithAggregatesFilter<"ForumPost"> | string
    status?: StringWithAggregatesFilter<"ForumPost"> | string
    upvotes?: IntWithAggregatesFilter<"ForumPost"> | number
    downvotes?: IntWithAggregatesFilter<"ForumPost"> | number
    views?: IntWithAggregatesFilter<"ForumPost"> | number
    commentsCount?: IntWithAggregatesFilter<"ForumPost"> | number
    pinned?: BoolWithAggregatesFilter<"ForumPost"> | boolean
    verifiedDoctor?: BoolWithAggregatesFilter<"ForumPost"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentWhereInput = {
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    id?: IntFilter<"ForumComment"> | number
    uuid?: StringFilter<"ForumComment"> | string
    postId?: IntFilter<"ForumComment"> | number
    userId?: IntFilter<"ForumComment"> | number
    parentCommentId?: IntNullableFilter<"ForumComment"> | number | null
    content?: StringFilter<"ForumComment"> | string
    upvotes?: IntFilter<"ForumComment"> | number
    helpfulCount?: IntFilter<"ForumComment"> | number
    verifiedDoctor?: BoolFilter<"ForumComment"> | boolean
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parentComment?: XOR<ForumCommentNullableRelationFilter, ForumCommentWhereInput> | null
    replies?: ForumCommentListRelationFilter
    upvotesByUser?: CommentUpvoteListRelationFilter
  }

  export type ForumCommentOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    post?: ForumPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    parentComment?: ForumCommentOrderByWithRelationInput
    replies?: ForumCommentOrderByRelationAggregateInput
    upvotesByUser?: CommentUpvoteOrderByRelationAggregateInput
  }

  export type ForumCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ForumCommentWhereInput | ForumCommentWhereInput[]
    OR?: ForumCommentWhereInput[]
    NOT?: ForumCommentWhereInput | ForumCommentWhereInput[]
    postId?: IntFilter<"ForumComment"> | number
    userId?: IntFilter<"ForumComment"> | number
    parentCommentId?: IntNullableFilter<"ForumComment"> | number | null
    content?: StringFilter<"ForumComment"> | string
    upvotes?: IntFilter<"ForumComment"> | number
    helpfulCount?: IntFilter<"ForumComment"> | number
    verifiedDoctor?: BoolFilter<"ForumComment"> | boolean
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    parentComment?: XOR<ForumCommentNullableRelationFilter, ForumCommentWhereInput> | null
    replies?: ForumCommentListRelationFilter
    upvotesByUser?: CommentUpvoteListRelationFilter
  }, "id" | "uuid">

  export type ForumCommentOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrderInput | SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ForumCommentCountOrderByAggregateInput
    _avg?: ForumCommentAvgOrderByAggregateInput
    _max?: ForumCommentMaxOrderByAggregateInput
    _min?: ForumCommentMinOrderByAggregateInput
    _sum?: ForumCommentSumOrderByAggregateInput
  }

  export type ForumCommentScalarWhereWithAggregatesInput = {
    AND?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    OR?: ForumCommentScalarWhereWithAggregatesInput[]
    NOT?: ForumCommentScalarWhereWithAggregatesInput | ForumCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ForumComment"> | number
    uuid?: StringWithAggregatesFilter<"ForumComment"> | string
    postId?: IntWithAggregatesFilter<"ForumComment"> | number
    userId?: IntWithAggregatesFilter<"ForumComment"> | number
    parentCommentId?: IntNullableWithAggregatesFilter<"ForumComment"> | number | null
    content?: StringWithAggregatesFilter<"ForumComment"> | string
    upvotes?: IntWithAggregatesFilter<"ForumComment"> | number
    helpfulCount?: IntWithAggregatesFilter<"ForumComment"> | number
    verifiedDoctor?: BoolWithAggregatesFilter<"ForumComment"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ForumComment"> | Date | string
  }

  export type PostUpvoteWhereInput = {
    AND?: PostUpvoteWhereInput | PostUpvoteWhereInput[]
    OR?: PostUpvoteWhereInput[]
    NOT?: PostUpvoteWhereInput | PostUpvoteWhereInput[]
    id?: IntFilter<"PostUpvote"> | number
    postId?: IntFilter<"PostUpvote"> | number
    userId?: IntFilter<"PostUpvote"> | number
    voteType?: StringFilter<"PostUpvote"> | string
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PostUpvoteOrderByWithRelationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    post?: ForumPostOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type PostUpvoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    postId_userId?: PostUpvotePostIdUserIdCompoundUniqueInput
    AND?: PostUpvoteWhereInput | PostUpvoteWhereInput[]
    OR?: PostUpvoteWhereInput[]
    NOT?: PostUpvoteWhereInput | PostUpvoteWhereInput[]
    postId?: IntFilter<"PostUpvote"> | number
    userId?: IntFilter<"PostUpvote"> | number
    voteType?: StringFilter<"PostUpvote"> | string
    post?: XOR<ForumPostRelationFilter, ForumPostWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "postId_userId">

  export type PostUpvoteOrderByWithAggregationInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    _count?: PostUpvoteCountOrderByAggregateInput
    _avg?: PostUpvoteAvgOrderByAggregateInput
    _max?: PostUpvoteMaxOrderByAggregateInput
    _min?: PostUpvoteMinOrderByAggregateInput
    _sum?: PostUpvoteSumOrderByAggregateInput
  }

  export type PostUpvoteScalarWhereWithAggregatesInput = {
    AND?: PostUpvoteScalarWhereWithAggregatesInput | PostUpvoteScalarWhereWithAggregatesInput[]
    OR?: PostUpvoteScalarWhereWithAggregatesInput[]
    NOT?: PostUpvoteScalarWhereWithAggregatesInput | PostUpvoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"PostUpvote"> | number
    postId?: IntWithAggregatesFilter<"PostUpvote"> | number
    userId?: IntWithAggregatesFilter<"PostUpvote"> | number
    voteType?: StringWithAggregatesFilter<"PostUpvote"> | string
  }

  export type CommentUpvoteWhereInput = {
    AND?: CommentUpvoteWhereInput | CommentUpvoteWhereInput[]
    OR?: CommentUpvoteWhereInput[]
    NOT?: CommentUpvoteWhereInput | CommentUpvoteWhereInput[]
    id?: IntFilter<"CommentUpvote"> | number
    commentId?: IntFilter<"CommentUpvote"> | number
    userId?: IntFilter<"CommentUpvote"> | number
    voteType?: StringFilter<"CommentUpvote"> | string
    comment?: XOR<ForumCommentRelationFilter, ForumCommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CommentUpvoteOrderByWithRelationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    comment?: ForumCommentOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CommentUpvoteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    commentId_userId?: CommentUpvoteCommentIdUserIdCompoundUniqueInput
    AND?: CommentUpvoteWhereInput | CommentUpvoteWhereInput[]
    OR?: CommentUpvoteWhereInput[]
    NOT?: CommentUpvoteWhereInput | CommentUpvoteWhereInput[]
    commentId?: IntFilter<"CommentUpvote"> | number
    userId?: IntFilter<"CommentUpvote"> | number
    voteType?: StringFilter<"CommentUpvote"> | string
    comment?: XOR<ForumCommentRelationFilter, ForumCommentWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "commentId_userId">

  export type CommentUpvoteOrderByWithAggregationInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
    _count?: CommentUpvoteCountOrderByAggregateInput
    _avg?: CommentUpvoteAvgOrderByAggregateInput
    _max?: CommentUpvoteMaxOrderByAggregateInput
    _min?: CommentUpvoteMinOrderByAggregateInput
    _sum?: CommentUpvoteSumOrderByAggregateInput
  }

  export type CommentUpvoteScalarWhereWithAggregatesInput = {
    AND?: CommentUpvoteScalarWhereWithAggregatesInput | CommentUpvoteScalarWhereWithAggregatesInput[]
    OR?: CommentUpvoteScalarWhereWithAggregatesInput[]
    NOT?: CommentUpvoteScalarWhereWithAggregatesInput | CommentUpvoteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CommentUpvote"> | number
    commentId?: IntWithAggregatesFilter<"CommentUpvote"> | number
    userId?: IntWithAggregatesFilter<"CommentUpvote"> | number
    voteType?: StringWithAggregatesFilter<"CommentUpvote"> | string
  }

  export type HealthArticleWhereInput = {
    AND?: HealthArticleWhereInput | HealthArticleWhereInput[]
    OR?: HealthArticleWhereInput[]
    NOT?: HealthArticleWhereInput | HealthArticleWhereInput[]
    id?: IntFilter<"HealthArticle"> | number
    uuid?: StringFilter<"HealthArticle"> | string
    title?: StringFilter<"HealthArticle"> | string
    slug?: StringFilter<"HealthArticle"> | string
    content?: StringFilter<"HealthArticle"> | string
    category?: StringFilter<"HealthArticle"> | string
    authorId?: IntNullableFilter<"HealthArticle"> | number | null
    featuredImageUrl?: StringNullableFilter<"HealthArticle"> | string | null
    status?: StringFilter<"HealthArticle"> | string
    views?: IntFilter<"HealthArticle"> | number
    publishedAt?: DateTimeNullableFilter<"HealthArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"HealthArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HealthArticle"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comments?: ArticleCommentListRelationFilter
    savedBy?: SavedArticleListRelationFilter
  }

  export type HealthArticleOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    views?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    author?: UserOrderByWithRelationInput
    comments?: ArticleCommentOrderByRelationAggregateInput
    savedBy?: SavedArticleOrderByRelationAggregateInput
  }

  export type HealthArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    slug?: string
    AND?: HealthArticleWhereInput | HealthArticleWhereInput[]
    OR?: HealthArticleWhereInput[]
    NOT?: HealthArticleWhereInput | HealthArticleWhereInput[]
    title?: StringFilter<"HealthArticle"> | string
    content?: StringFilter<"HealthArticle"> | string
    category?: StringFilter<"HealthArticle"> | string
    authorId?: IntNullableFilter<"HealthArticle"> | number | null
    featuredImageUrl?: StringNullableFilter<"HealthArticle"> | string | null
    status?: StringFilter<"HealthArticle"> | string
    views?: IntFilter<"HealthArticle"> | number
    publishedAt?: DateTimeNullableFilter<"HealthArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"HealthArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HealthArticle"> | Date | string
    author?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    comments?: ArticleCommentListRelationFilter
    savedBy?: SavedArticleListRelationFilter
  }, "id" | "uuid" | "slug">

  export type HealthArticleOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrderInput | SortOrder
    featuredImageUrl?: SortOrderInput | SortOrder
    status?: SortOrder
    views?: SortOrder
    publishedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: HealthArticleCountOrderByAggregateInput
    _avg?: HealthArticleAvgOrderByAggregateInput
    _max?: HealthArticleMaxOrderByAggregateInput
    _min?: HealthArticleMinOrderByAggregateInput
    _sum?: HealthArticleSumOrderByAggregateInput
  }

  export type HealthArticleScalarWhereWithAggregatesInput = {
    AND?: HealthArticleScalarWhereWithAggregatesInput | HealthArticleScalarWhereWithAggregatesInput[]
    OR?: HealthArticleScalarWhereWithAggregatesInput[]
    NOT?: HealthArticleScalarWhereWithAggregatesInput | HealthArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"HealthArticle"> | number
    uuid?: StringWithAggregatesFilter<"HealthArticle"> | string
    title?: StringWithAggregatesFilter<"HealthArticle"> | string
    slug?: StringWithAggregatesFilter<"HealthArticle"> | string
    content?: StringWithAggregatesFilter<"HealthArticle"> | string
    category?: StringWithAggregatesFilter<"HealthArticle"> | string
    authorId?: IntNullableWithAggregatesFilter<"HealthArticle"> | number | null
    featuredImageUrl?: StringNullableWithAggregatesFilter<"HealthArticle"> | string | null
    status?: StringWithAggregatesFilter<"HealthArticle"> | string
    views?: IntWithAggregatesFilter<"HealthArticle"> | number
    publishedAt?: DateTimeNullableWithAggregatesFilter<"HealthArticle"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"HealthArticle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"HealthArticle"> | Date | string
  }

  export type ArticleCommentWhereInput = {
    AND?: ArticleCommentWhereInput | ArticleCommentWhereInput[]
    OR?: ArticleCommentWhereInput[]
    NOT?: ArticleCommentWhereInput | ArticleCommentWhereInput[]
    id?: IntFilter<"ArticleComment"> | number
    uuid?: StringFilter<"ArticleComment"> | string
    articleId?: IntFilter<"ArticleComment"> | number
    userId?: IntFilter<"ArticleComment"> | number
    content?: StringFilter<"ArticleComment"> | string
    upvotes?: IntFilter<"ArticleComment"> | number
    createdAt?: DateTimeFilter<"ArticleComment"> | Date | string
    article?: XOR<HealthArticleRelationFilter, HealthArticleWhereInput>
  }

  export type ArticleCommentOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    article?: HealthArticleOrderByWithRelationInput
  }

  export type ArticleCommentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: ArticleCommentWhereInput | ArticleCommentWhereInput[]
    OR?: ArticleCommentWhereInput[]
    NOT?: ArticleCommentWhereInput | ArticleCommentWhereInput[]
    articleId?: IntFilter<"ArticleComment"> | number
    userId?: IntFilter<"ArticleComment"> | number
    content?: StringFilter<"ArticleComment"> | string
    upvotes?: IntFilter<"ArticleComment"> | number
    createdAt?: DateTimeFilter<"ArticleComment"> | Date | string
    article?: XOR<HealthArticleRelationFilter, HealthArticleWhereInput>
  }, "id" | "uuid">

  export type ArticleCommentOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
    _count?: ArticleCommentCountOrderByAggregateInput
    _avg?: ArticleCommentAvgOrderByAggregateInput
    _max?: ArticleCommentMaxOrderByAggregateInput
    _min?: ArticleCommentMinOrderByAggregateInput
    _sum?: ArticleCommentSumOrderByAggregateInput
  }

  export type ArticleCommentScalarWhereWithAggregatesInput = {
    AND?: ArticleCommentScalarWhereWithAggregatesInput | ArticleCommentScalarWhereWithAggregatesInput[]
    OR?: ArticleCommentScalarWhereWithAggregatesInput[]
    NOT?: ArticleCommentScalarWhereWithAggregatesInput | ArticleCommentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ArticleComment"> | number
    uuid?: StringWithAggregatesFilter<"ArticleComment"> | string
    articleId?: IntWithAggregatesFilter<"ArticleComment"> | number
    userId?: IntWithAggregatesFilter<"ArticleComment"> | number
    content?: StringWithAggregatesFilter<"ArticleComment"> | string
    upvotes?: IntWithAggregatesFilter<"ArticleComment"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ArticleComment"> | Date | string
  }

  export type SavedArticleWhereInput = {
    AND?: SavedArticleWhereInput | SavedArticleWhereInput[]
    OR?: SavedArticleWhereInput[]
    NOT?: SavedArticleWhereInput | SavedArticleWhereInput[]
    id?: IntFilter<"SavedArticle"> | number
    userId?: IntFilter<"SavedArticle"> | number
    articleId?: IntFilter<"SavedArticle"> | number
    savedAt?: DateTimeFilter<"SavedArticle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<HealthArticleRelationFilter, HealthArticleWhereInput>
  }

  export type SavedArticleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    savedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    article?: HealthArticleOrderByWithRelationInput
  }

  export type SavedArticleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    userId_articleId?: SavedArticleUserIdArticleIdCompoundUniqueInput
    AND?: SavedArticleWhereInput | SavedArticleWhereInput[]
    OR?: SavedArticleWhereInput[]
    NOT?: SavedArticleWhereInput | SavedArticleWhereInput[]
    userId?: IntFilter<"SavedArticle"> | number
    articleId?: IntFilter<"SavedArticle"> | number
    savedAt?: DateTimeFilter<"SavedArticle"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    article?: XOR<HealthArticleRelationFilter, HealthArticleWhereInput>
  }, "id" | "userId_articleId">

  export type SavedArticleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    savedAt?: SortOrder
    _count?: SavedArticleCountOrderByAggregateInput
    _avg?: SavedArticleAvgOrderByAggregateInput
    _max?: SavedArticleMaxOrderByAggregateInput
    _min?: SavedArticleMinOrderByAggregateInput
    _sum?: SavedArticleSumOrderByAggregateInput
  }

  export type SavedArticleScalarWhereWithAggregatesInput = {
    AND?: SavedArticleScalarWhereWithAggregatesInput | SavedArticleScalarWhereWithAggregatesInput[]
    OR?: SavedArticleScalarWhereWithAggregatesInput[]
    NOT?: SavedArticleScalarWhereWithAggregatesInput | SavedArticleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SavedArticle"> | number
    userId?: IntWithAggregatesFilter<"SavedArticle"> | number
    articleId?: IntWithAggregatesFilter<"SavedArticle"> | number
    savedAt?: DateTimeWithAggregatesFilter<"SavedArticle"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    uuid?: StringFilter<"Notification"> | string
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "uuid">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrderInput | SortOrder
    read?: SortOrder
    actionUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    uuid?: StringWithAggregatesFilter<"Notification"> | string
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    actionUrl?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SymptomCheckSessionWhereInput = {
    AND?: SymptomCheckSessionWhereInput | SymptomCheckSessionWhereInput[]
    OR?: SymptomCheckSessionWhereInput[]
    NOT?: SymptomCheckSessionWhereInput | SymptomCheckSessionWhereInput[]
    id?: IntFilter<"SymptomCheckSession"> | number
    uuid?: StringFilter<"SymptomCheckSession"> | string
    userId?: IntFilter<"SymptomCheckSession"> | number
    conversation?: StringFilter<"SymptomCheckSession"> | string
    result?: StringNullableFilter<"SymptomCheckSession"> | string | null
    riskLevel?: StringNullableFilter<"SymptomCheckSession"> | string | null
    createdAt?: DateTimeFilter<"SymptomCheckSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type SymptomCheckSessionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    result?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SymptomCheckSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: SymptomCheckSessionWhereInput | SymptomCheckSessionWhereInput[]
    OR?: SymptomCheckSessionWhereInput[]
    NOT?: SymptomCheckSessionWhereInput | SymptomCheckSessionWhereInput[]
    userId?: IntFilter<"SymptomCheckSession"> | number
    conversation?: StringFilter<"SymptomCheckSession"> | string
    result?: StringNullableFilter<"SymptomCheckSession"> | string | null
    riskLevel?: StringNullableFilter<"SymptomCheckSession"> | string | null
    createdAt?: DateTimeFilter<"SymptomCheckSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "uuid">

  export type SymptomCheckSessionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    result?: SortOrderInput | SortOrder
    riskLevel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: SymptomCheckSessionCountOrderByAggregateInput
    _avg?: SymptomCheckSessionAvgOrderByAggregateInput
    _max?: SymptomCheckSessionMaxOrderByAggregateInput
    _min?: SymptomCheckSessionMinOrderByAggregateInput
    _sum?: SymptomCheckSessionSumOrderByAggregateInput
  }

  export type SymptomCheckSessionScalarWhereWithAggregatesInput = {
    AND?: SymptomCheckSessionScalarWhereWithAggregatesInput | SymptomCheckSessionScalarWhereWithAggregatesInput[]
    OR?: SymptomCheckSessionScalarWhereWithAggregatesInput[]
    NOT?: SymptomCheckSessionScalarWhereWithAggregatesInput | SymptomCheckSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SymptomCheckSession"> | number
    uuid?: StringWithAggregatesFilter<"SymptomCheckSession"> | string
    userId?: IntWithAggregatesFilter<"SymptomCheckSession"> | number
    conversation?: StringWithAggregatesFilter<"SymptomCheckSession"> | string
    result?: StringNullableWithAggregatesFilter<"SymptomCheckSession"> | string | null
    riskLevel?: StringNullableWithAggregatesFilter<"SymptomCheckSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"SymptomCheckSession"> | Date | string
  }

  export type CoachSessionWhereInput = {
    AND?: CoachSessionWhereInput | CoachSessionWhereInput[]
    OR?: CoachSessionWhereInput[]
    NOT?: CoachSessionWhereInput | CoachSessionWhereInput[]
    id?: IntFilter<"CoachSession"> | number
    uuid?: StringFilter<"CoachSession"> | string
    userId?: IntFilter<"CoachSession"> | number
    conversation?: StringFilter<"CoachSession"> | string
    savedPlan?: StringNullableFilter<"CoachSession"> | string | null
    createdAt?: DateTimeFilter<"CoachSession"> | Date | string
    updatedAt?: DateTimeFilter<"CoachSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type CoachSessionOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    savedPlan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type CoachSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    uuid?: string
    AND?: CoachSessionWhereInput | CoachSessionWhereInput[]
    OR?: CoachSessionWhereInput[]
    NOT?: CoachSessionWhereInput | CoachSessionWhereInput[]
    userId?: IntFilter<"CoachSession"> | number
    conversation?: StringFilter<"CoachSession"> | string
    savedPlan?: StringNullableFilter<"CoachSession"> | string | null
    createdAt?: DateTimeFilter<"CoachSession"> | Date | string
    updatedAt?: DateTimeFilter<"CoachSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "uuid">

  export type CoachSessionOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    savedPlan?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CoachSessionCountOrderByAggregateInput
    _avg?: CoachSessionAvgOrderByAggregateInput
    _max?: CoachSessionMaxOrderByAggregateInput
    _min?: CoachSessionMinOrderByAggregateInput
    _sum?: CoachSessionSumOrderByAggregateInput
  }

  export type CoachSessionScalarWhereWithAggregatesInput = {
    AND?: CoachSessionScalarWhereWithAggregatesInput | CoachSessionScalarWhereWithAggregatesInput[]
    OR?: CoachSessionScalarWhereWithAggregatesInput[]
    NOT?: CoachSessionScalarWhereWithAggregatesInput | CoachSessionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CoachSession"> | number
    uuid?: StringWithAggregatesFilter<"CoachSession"> | string
    userId?: IntWithAggregatesFilter<"CoachSession"> | number
    conversation?: StringWithAggregatesFilter<"CoachSession"> | string
    savedPlan?: StringNullableWithAggregatesFilter<"CoachSession"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"CoachSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CoachSession"> | Date | string
  }

  export type UserCreateInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileCreateInput = {
    heightCm?: number | null
    weightKg?: number | null
    bmi?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    conditions?: string | null
    allergies?: string | null
    medications?: string | null
    vaccinationRecords?: string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutHealthProfileInput
  }

  export type HealthProfileUncheckedCreateInput = {
    id?: number
    userId: number
    heightCm?: number | null
    weightKg?: number | null
    bmi?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    conditions?: string | null
    allergies?: string | null
    medications?: string | null
    vaccinationRecords?: string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUpdateInput = {
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHealthProfileNestedInput
  }

  export type HealthProfileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileCreateManyInput = {
    id?: number
    userId: number
    heightCm?: number | null
    weightKg?: number | null
    bmi?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    conditions?: string | null
    allergies?: string | null
    medications?: string | null
    vaccinationRecords?: string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUpdateManyMutationInput = {
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorCreateInput = {
    uuid?: string
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorProfileInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorProfileInput
    reviews?: DoctorReviewCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorProfileInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorProfileNestedInput
    reviews?: DoctorReviewUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorProfileNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewCreateInput = {
    uuid?: string
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
    appointment?: AppointmentCreateNestedOneWithoutReviewsInput
  }

  export type DoctorReviewUncheckedCreateInput = {
    id?: number
    uuid?: string
    doctorId: number
    userId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    appointment?: AppointmentUpdateOneWithoutReviewsNestedInput
  }

  export type DoctorReviewUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewCreateManyInput = {
    id?: number
    uuid?: string
    doctorId: number
    userId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionCreateInput = {
    uuid?: string
    appointmentId?: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions?: string | null
    validityDays?: number
    issuedAt?: Date | string
    createdAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUncheckedCreateInput = {
    id?: number
    uuid?: string
    appointmentId?: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions?: string | null
    validityDays?: number
    issuedAt?: Date | string
    createdAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPrescriptionInput
  }

  export type PrescriptionUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPrescriptionNestedInput
  }

  export type PrescriptionCreateManyInput = {
    id?: number
    uuid?: string
    appointmentId?: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions?: string | null
    validityDays?: number
    issuedAt?: Date | string
    createdAt?: Date | string
  }

  export type PrescriptionUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionCreateInput = {
    uuid?: string
    roomId?: string | null
    provider?: string | null
    token?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    createdAt?: Date | string
    appointment: AppointmentCreateNestedOneWithoutCallSessionInput
  }

  export type CallSessionUncheckedCreateInput = {
    id?: number
    uuid?: string
    appointmentId: number
    roomId?: string | null
    provider?: string | null
    token?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    createdAt?: Date | string
  }

  export type CallSessionUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointment?: AppointmentUpdateOneRequiredWithoutCallSessionNestedInput
  }

  export type CallSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionCreateManyInput = {
    id?: number
    uuid?: string
    appointmentId: number
    roomId?: string | null
    provider?: string | null
    token?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    createdAt?: Date | string
  }

  export type CallSessionUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: IntFieldUpdateOperationsInput | number
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineCreateInput = {
    uuid?: string
    name: string
    composition?: string | null
    category?: string | null
    price: number
    manufacturer?: string | null
    stockQty?: number
    description?: string | null
    sideEffects?: string | null
    interactions?: string | null
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: Date | string
    orderItems?: MedicineOrderItemCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUncheckedCreateInput = {
    id?: number
    uuid?: string
    name: string
    composition?: string | null
    category?: string | null
    price: number
    manufacturer?: string | null
    stockQty?: number
    description?: string | null
    sideEffects?: string | null
    interactions?: string | null
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: Date | string
    orderItems?: MedicineOrderItemUncheckedCreateNestedManyWithoutMedicineInput
  }

  export type MedicineUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: MedicineOrderItemUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    orderItems?: MedicineOrderItemUncheckedUpdateManyWithoutMedicineNestedInput
  }

  export type MedicineCreateManyInput = {
    id?: number
    uuid?: string
    name: string
    composition?: string | null
    category?: string | null
    price: number
    manufacturer?: string | null
    stockQty?: number
    description?: string | null
    sideEffects?: string | null
    interactions?: string | null
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: Date | string
  }

  export type MedicineUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineOrderCreateInput = {
    uuid?: string
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMedicineOrdersInput
    items?: MedicineOrderItemCreateNestedManyWithoutOrderInput
  }

  export type MedicineOrderUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MedicineOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type MedicineOrderUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMedicineOrdersNestedInput
    items?: MedicineOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type MedicineOrderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MedicineOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MedicineOrderCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineOrderUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineOrderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineOrderItemCreateInput = {
    quantity: number
    price: number
    order: MedicineOrderCreateNestedOneWithoutItemsInput
    medicine: MedicineCreateNestedOneWithoutOrderItemsInput
  }

  export type MedicineOrderItemUncheckedCreateInput = {
    id?: number
    orderId: number
    medicineId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemUpdateInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: MedicineOrderUpdateOneRequiredWithoutItemsNestedInput
    medicine?: MedicineUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type MedicineOrderItemUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineOrderItemCreateManyInput = {
    id?: number
    orderId: number
    medicineId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemUpdateManyMutationInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineOrderItemUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type LabTestCreateInput = {
    uuid?: string
    name: string
    category?: string | null
    price: number
    description?: string | null
    preparation?: string | null
    parameters?: string | null
    turnaroundTime?: string | null
    available?: boolean
    createdAt?: Date | string
    bookings?: LabBookingTestCreateNestedManyWithoutTestInput
  }

  export type LabTestUncheckedCreateInput = {
    id?: number
    uuid?: string
    name: string
    category?: string | null
    price: number
    description?: string | null
    preparation?: string | null
    parameters?: string | null
    turnaroundTime?: string | null
    available?: boolean
    createdAt?: Date | string
    bookings?: LabBookingTestUncheckedCreateNestedManyWithoutTestInput
  }

  export type LabTestUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: LabBookingTestUpdateManyWithoutTestNestedInput
  }

  export type LabTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: LabBookingTestUncheckedUpdateManyWithoutTestNestedInput
  }

  export type LabTestCreateManyInput = {
    id?: number
    uuid?: string
    name: string
    category?: string | null
    price: number
    description?: string | null
    preparation?: string | null
    parameters?: string | null
    turnaroundTime?: string | null
    available?: boolean
    createdAt?: Date | string
  }

  export type LabTestUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingCreateInput = {
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLabBookingsInput
    tests?: LabBookingTestCreateNestedManyWithoutBookingInput
    report?: LabReportCreateNestedOneWithoutBookingInput
  }

  export type LabBookingUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    tests?: LabBookingTestUncheckedCreateNestedManyWithoutBookingInput
    report?: LabReportUncheckedCreateNestedOneWithoutBookingInput
  }

  export type LabBookingUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabBookingsNestedInput
    tests?: LabBookingTestUpdateManyWithoutBookingNestedInput
    report?: LabReportUpdateOneWithoutBookingNestedInput
  }

  export type LabBookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tests?: LabBookingTestUncheckedUpdateManyWithoutBookingNestedInput
    report?: LabReportUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type LabBookingCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
  }

  export type LabBookingUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingTestCreateInput = {
    booking: LabBookingCreateNestedOneWithoutTestsInput
    test: LabTestCreateNestedOneWithoutBookingsInput
  }

  export type LabBookingTestUncheckedCreateInput = {
    id?: number
    bookingId: number
    testId: number
  }

  export type LabBookingTestUpdateInput = {
    booking?: LabBookingUpdateOneRequiredWithoutTestsNestedInput
    test?: LabTestUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type LabBookingTestUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type LabBookingTestCreateManyInput = {
    id?: number
    bookingId: number
    testId: number
  }

  export type LabBookingTestUpdateManyMutationInput = {

  }

  export type LabBookingTestUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type LabReportCreateInput = {
    uuid?: string
    reportUrl: string
    results?: string | null
    status?: string
    reviewedById?: number | null
    interpretation?: string | null
    recommendations?: string | null
    readyAt?: Date | string | null
    createdAt?: Date | string
    booking: LabBookingCreateNestedOneWithoutReportInput
  }

  export type LabReportUncheckedCreateInput = {
    id?: number
    uuid?: string
    bookingId: number
    reportUrl: string
    results?: string | null
    status?: string
    reviewedById?: number | null
    interpretation?: string | null
    recommendations?: string | null
    readyAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LabReportUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: LabBookingUpdateOneRequiredWithoutReportNestedInput
  }

  export type LabReportUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportCreateManyInput = {
    id?: number
    uuid?: string
    bookingId: number
    reportUrl: string
    results?: string | null
    status?: string
    reviewedById?: number | null
    interpretation?: string | null
    recommendations?: string | null
    readyAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LabReportUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    bookingId?: IntFieldUpdateOperationsInput | number
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateInput = {
    uuid?: string
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutHealthRecordsInput
  }

  export type HealthRecordUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
  }

  export type HealthRecordUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutHealthRecordsNestedInput
  }

  export type HealthRecordUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
  }

  export type HealthRecordUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostCreateInput = {
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
    upvotesByUser?: PostUpvoteCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
    upvotesByUser?: PostUpvoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
    upvotesByUser?: PostUpvoteUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
    upvotesByUser?: PostUpvoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumPostUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentCreateInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutForumCommentsInput
    parentComment?: ForumCommentCreateNestedOneWithoutRepliesInput
    replies?: ForumCommentCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUncheckedCreateInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    parentComment?: ForumCommentUpdateOneWithoutRepliesNestedInput
    replies?: ForumCommentUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentCreateManyInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpvoteCreateInput = {
    voteType: string
    post: ForumPostCreateNestedOneWithoutUpvotesByUserInput
    user: UserCreateNestedOneWithoutPostUpvotesInput
  }

  export type PostUpvoteUncheckedCreateInput = {
    id?: number
    postId: number
    userId: number
    voteType: string
  }

  export type PostUpvoteUpdateInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    post?: ForumPostUpdateOneRequiredWithoutUpvotesByUserNestedInput
    user?: UserUpdateOneRequiredWithoutPostUpvotesNestedInput
  }

  export type PostUpvoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpvoteCreateManyInput = {
    id?: number
    postId: number
    userId: number
    voteType: string
  }

  export type PostUpvoteUpdateManyMutationInput = {
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpvoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteCreateInput = {
    voteType: string
    comment: ForumCommentCreateNestedOneWithoutUpvotesByUserInput
    user: UserCreateNestedOneWithoutCommentUpvotesInput
  }

  export type CommentUpvoteUncheckedCreateInput = {
    id?: number
    commentId: number
    userId: number
    voteType: string
  }

  export type CommentUpvoteUpdateInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    comment?: ForumCommentUpdateOneRequiredWithoutUpvotesByUserNestedInput
    user?: UserUpdateOneRequiredWithoutCommentUpvotesNestedInput
  }

  export type CommentUpvoteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteCreateManyInput = {
    id?: number
    commentId: number
    userId: number
    voteType: string
  }

  export type CommentUpvoteUpdateManyMutationInput = {
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type HealthArticleCreateInput = {
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutArticlesInput
    comments?: ArticleCommentCreateNestedManyWithoutArticleInput
    savedBy?: SavedArticleCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleUncheckedCreateInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    authorId?: number | null
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    savedBy?: SavedArticleUncheckedCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutArticlesNestedInput
    comments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    savedBy?: SavedArticleUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    savedBy?: SavedArticleUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleCreateManyInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    authorId?: number | null
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthArticleUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCommentCreateInput = {
    uuid?: string
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
    article: HealthArticleCreateNestedOneWithoutCommentsInput
  }

  export type ArticleCommentUncheckedCreateInput = {
    id?: number
    uuid?: string
    articleId: number
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
  }

  export type ArticleCommentUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: HealthArticleUpdateOneRequiredWithoutCommentsNestedInput
  }

  export type ArticleCommentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCommentCreateManyInput = {
    id?: number
    uuid?: string
    articleId: number
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
  }

  export type ArticleCommentUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCommentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    articleId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleCreateInput = {
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedArticlesInput
    article: HealthArticleCreateNestedOneWithoutSavedByInput
  }

  export type SavedArticleUncheckedCreateInput = {
    id?: number
    userId: number
    articleId: number
    savedAt?: Date | string
  }

  export type SavedArticleUpdateInput = {
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedArticlesNestedInput
    article?: HealthArticleUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedArticleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleCreateManyInput = {
    id?: number
    userId: number
    articleId: number
    savedAt?: Date | string
  }

  export type SavedArticleUpdateManyMutationInput = {
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    uuid?: string
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionCreateInput = {
    uuid?: string
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutSymptomSessionsInput
  }

  export type SymptomCheckSessionUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
  }

  export type SymptomCheckSessionUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSymptomSessionsNestedInput
  }

  export type SymptomCheckSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
  }

  export type SymptomCheckSessionUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionCreateInput = {
    uuid?: string
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutCoachSessionsInput
  }

  export type CoachSessionUncheckedCreateInput = {
    id?: number
    uuid?: string
    userId: number
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachSessionUpdateInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCoachSessionsNestedInput
  }

  export type CoachSessionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionCreateManyInput = {
    id?: number
    uuid?: string
    userId: number
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachSessionUpdateManyMutationInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type HealthProfileNullableRelationFilter = {
    is?: HealthProfileWhereInput | null
    isNot?: HealthProfileWhereInput | null
  }

  export type DoctorNullableRelationFilter = {
    is?: DoctorWhereInput | null
    isNot?: DoctorWhereInput | null
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type MedicineOrderListRelationFilter = {
    every?: MedicineOrderWhereInput
    some?: MedicineOrderWhereInput
    none?: MedicineOrderWhereInput
  }

  export type LabBookingListRelationFilter = {
    every?: LabBookingWhereInput
    some?: LabBookingWhereInput
    none?: LabBookingWhereInput
  }

  export type HealthRecordListRelationFilter = {
    every?: HealthRecordWhereInput
    some?: HealthRecordWhereInput
    none?: HealthRecordWhereInput
  }

  export type ForumPostListRelationFilter = {
    every?: ForumPostWhereInput
    some?: ForumPostWhereInput
    none?: ForumPostWhereInput
  }

  export type ForumCommentListRelationFilter = {
    every?: ForumCommentWhereInput
    some?: ForumCommentWhereInput
    none?: ForumCommentWhereInput
  }

  export type PostUpvoteListRelationFilter = {
    every?: PostUpvoteWhereInput
    some?: PostUpvoteWhereInput
    none?: PostUpvoteWhereInput
  }

  export type CommentUpvoteListRelationFilter = {
    every?: CommentUpvoteWhereInput
    some?: CommentUpvoteWhereInput
    none?: CommentUpvoteWhereInput
  }

  export type HealthArticleListRelationFilter = {
    every?: HealthArticleWhereInput
    some?: HealthArticleWhereInput
    none?: HealthArticleWhereInput
  }

  export type SavedArticleListRelationFilter = {
    every?: SavedArticleWhereInput
    some?: SavedArticleWhereInput
    none?: SavedArticleWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type DoctorReviewListRelationFilter = {
    every?: DoctorReviewWhereInput
    some?: DoctorReviewWhereInput
    none?: DoctorReviewWhereInput
  }

  export type SymptomCheckSessionListRelationFilter = {
    every?: SymptomCheckSessionWhereInput
    some?: SymptomCheckSessionWhereInput
    none?: SymptomCheckSessionWhereInput
  }

  export type CoachSessionListRelationFilter = {
    every?: CoachSessionWhereInput
    some?: CoachSessionWhereInput
    none?: CoachSessionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabBookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthRecordOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumPostOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ForumCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PostUpvoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CommentUpvoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SavedArticleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DoctorReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SymptomCheckSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CoachSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    address?: SortOrder
    abhaId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    address?: SortOrder
    abhaId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    passwordHash?: SortOrder
    fullName?: SortOrder
    profilePhotoUrl?: SortOrder
    dateOfBirth?: SortOrder
    gender?: SortOrder
    bloodGroup?: SortOrder
    city?: SortOrder
    state?: SortOrder
    country?: SortOrder
    address?: SortOrder
    abhaId?: SortOrder
    isVerified?: SortOrder
    isActive?: SortOrder
    role?: SortOrder
    lastLogin?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type HealthProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrder
    weightKg?: SortOrder
    bmi?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    vaccinationRecords?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrder
    weightKg?: SortOrder
    bmi?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    healthScore?: SortOrder
  }

  export type HealthProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrder
    weightKg?: SortOrder
    bmi?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    vaccinationRecords?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrder
    weightKg?: SortOrder
    bmi?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    conditions?: SortOrder
    allergies?: SortOrder
    medications?: SortOrder
    vaccinationRecords?: SortOrder
    healthScore?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthProfileSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    heightCm?: SortOrder
    weightKg?: SortOrder
    bmi?: SortOrder
    bloodPressureSystolic?: SortOrder
    bloodPressureDiastolic?: SortOrder
    heartRate?: SortOrder
    healthScore?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type DoctorCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    specialty?: SortOrder
    qualifications?: SortOrder
    experienceYears?: SortOrder
    licenseNumber?: SortOrder
    clinicName?: SortOrder
    clinicAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    availability?: SortOrder
    isVerified?: SortOrder
    verificationDocuments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experienceYears?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
  }

  export type DoctorMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    specialty?: SortOrder
    qualifications?: SortOrder
    experienceYears?: SortOrder
    licenseNumber?: SortOrder
    clinicName?: SortOrder
    clinicAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    availability?: SortOrder
    isVerified?: SortOrder
    verificationDocuments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    specialty?: SortOrder
    qualifications?: SortOrder
    experienceYears?: SortOrder
    licenseNumber?: SortOrder
    clinicName?: SortOrder
    clinicAddress?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
    availability?: SortOrder
    isVerified?: SortOrder
    verificationDocuments?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DoctorSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    experienceYears?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    consultationFee?: SortOrder
    averageRating?: SortOrder
    totalRatings?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DoctorRelationFilter = {
    is?: DoctorWhereInput
    isNot?: DoctorWhereInput
  }

  export type AppointmentNullableRelationFilter = {
    is?: AppointmentWhereInput | null
    isNot?: AppointmentWhereInput | null
  }

  export type DoctorReviewCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    verified?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DoctorReviewAvgOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    rating?: SortOrder
    helpfulCount?: SortOrder
  }

  export type DoctorReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    verified?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DoctorReviewMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    rating?: SortOrder
    review?: SortOrder
    verified?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
  }

  export type DoctorReviewSumOrderByAggregateInput = {
    id?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    appointmentId?: SortOrder
    rating?: SortOrder
    helpfulCount?: SortOrder
  }

  export type PrescriptionNullableRelationFilter = {
    is?: PrescriptionWhereInput | null
    isNot?: PrescriptionWhereInput | null
  }

  export type CallSessionNullableRelationFilter = {
    is?: CallSessionWhereInput | null
    isNot?: CallSessionWhereInput | null
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    consultationType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    recordingUrl?: SortOrder
    prescriptionId?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    prescriptionId?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    consultationType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    recordingUrl?: SortOrder
    prescriptionId?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    appointmentDate?: SortOrder
    consultationType?: SortOrder
    status?: SortOrder
    reason?: SortOrder
    notes?: SortOrder
    meetingLink?: SortOrder
    recordingUrl?: SortOrder
    prescriptionId?: SortOrder
    paymentId?: SortOrder
    paymentStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    doctorId?: SortOrder
    prescriptionId?: SortOrder
  }

  export type PrescriptionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    medicines?: SortOrder
    instructions?: SortOrder
    validityDays?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionAvgOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    validityDays?: SortOrder
  }

  export type PrescriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    medicines?: SortOrder
    instructions?: SortOrder
    validityDays?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    medicines?: SortOrder
    instructions?: SortOrder
    validityDays?: SortOrder
    issuedAt?: SortOrder
    createdAt?: SortOrder
  }

  export type PrescriptionSumOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
    doctorId?: SortOrder
    userId?: SortOrder
    validityDays?: SortOrder
  }

  export type AppointmentRelationFilter = {
    is?: AppointmentWhereInput
    isNot?: AppointmentWhereInput
  }

  export type CallSessionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    roomId?: SortOrder
    provider?: SortOrder
    token?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CallSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
  }

  export type CallSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    roomId?: SortOrder
    provider?: SortOrder
    token?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CallSessionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    appointmentId?: SortOrder
    roomId?: SortOrder
    provider?: SortOrder
    token?: SortOrder
    startedAt?: SortOrder
    endedAt?: SortOrder
    recordingUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type CallSessionSumOrderByAggregateInput = {
    id?: SortOrder
    appointmentId?: SortOrder
  }

  export type MedicineOrderItemListRelationFilter = {
    every?: MedicineOrderItemWhereInput
    some?: MedicineOrderItemWhereInput
    none?: MedicineOrderItemWhereInput
  }

  export type MedicineOrderItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicineCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    composition?: SortOrder
    category?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    stockQty?: SortOrder
    description?: SortOrder
    sideEffects?: SortOrder
    interactions?: SortOrder
    requiresPrescription?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicineAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stockQty?: SortOrder
  }

  export type MedicineMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    composition?: SortOrder
    category?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    stockQty?: SortOrder
    description?: SortOrder
    sideEffects?: SortOrder
    interactions?: SortOrder
    requiresPrescription?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicineMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    composition?: SortOrder
    category?: SortOrder
    price?: SortOrder
    manufacturer?: SortOrder
    stockQty?: SortOrder
    description?: SortOrder
    sideEffects?: SortOrder
    interactions?: SortOrder
    requiresPrescription?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicineSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    stockQty?: SortOrder
  }

  export type MedicineOrderCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    deliveryAddress?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    prescriptionUrl?: SortOrder
    deliveryDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    trackingNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineOrderAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
  }

  export type MedicineOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    deliveryAddress?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    prescriptionUrl?: SortOrder
    deliveryDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    trackingNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineOrderMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    orderDate?: SortOrder
    deliveryAddress?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentMethod?: SortOrder
    paymentStatus?: SortOrder
    prescriptionUrl?: SortOrder
    deliveryDate?: SortOrder
    expectedDeliveryDate?: SortOrder
    trackingNumber?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MedicineOrderSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
  }

  export type MedicineOrderRelationFilter = {
    is?: MedicineOrderWhereInput
    isNot?: MedicineOrderWhereInput
  }

  export type MedicineRelationFilter = {
    is?: MedicineWhereInput
    isNot?: MedicineWhereInput
  }

  export type MedicineOrderItemOrderIdMedicineIdCompoundUniqueInput = {
    orderId: number
    medicineId: number
  }

  export type MedicineOrderItemCountOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MedicineOrderItemAvgOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MedicineOrderItemMaxOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MedicineOrderItemMinOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type MedicineOrderItemSumOrderByAggregateInput = {
    id?: SortOrder
    orderId?: SortOrder
    medicineId?: SortOrder
    quantity?: SortOrder
    price?: SortOrder
  }

  export type LabBookingTestListRelationFilter = {
    every?: LabBookingTestWhereInput
    some?: LabBookingTestWhereInput
    none?: LabBookingTestWhereInput
  }

  export type LabBookingTestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabTestCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    preparation?: SortOrder
    parameters?: SortOrder
    turnaroundTime?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type LabTestAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type LabTestMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    preparation?: SortOrder
    parameters?: SortOrder
    turnaroundTime?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type LabTestMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    name?: SortOrder
    category?: SortOrder
    price?: SortOrder
    description?: SortOrder
    preparation?: SortOrder
    parameters?: SortOrder
    turnaroundTime?: SortOrder
    available?: SortOrder
    createdAt?: SortOrder
  }

  export type LabTestSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
  }

  export type LabReportNullableRelationFilter = {
    is?: LabReportWhereInput | null
    isNot?: LabReportWhereInput | null
  }

  export type LabBookingCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    bookingDate?: SortOrder
    collectionType?: SortOrder
    address?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    reportUrl?: SortOrder
    reportReadyDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LabBookingAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
  }

  export type LabBookingMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    bookingDate?: SortOrder
    collectionType?: SortOrder
    address?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    reportUrl?: SortOrder
    reportReadyDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LabBookingMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    bookingDate?: SortOrder
    collectionType?: SortOrder
    address?: SortOrder
    status?: SortOrder
    totalAmount?: SortOrder
    paymentStatus?: SortOrder
    reportUrl?: SortOrder
    reportReadyDate?: SortOrder
    createdAt?: SortOrder
  }

  export type LabBookingSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    totalAmount?: SortOrder
  }

  export type LabBookingRelationFilter = {
    is?: LabBookingWhereInput
    isNot?: LabBookingWhereInput
  }

  export type LabTestRelationFilter = {
    is?: LabTestWhereInput
    isNot?: LabTestWhereInput
  }

  export type LabBookingTestBookingIdTestIdCompoundUniqueInput = {
    bookingId: number
    testId: number
  }

  export type LabBookingTestCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
  }

  export type LabBookingTestAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
  }

  export type LabBookingTestMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
  }

  export type LabBookingTestMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
  }

  export type LabBookingTestSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    testId?: SortOrder
  }

  export type LabReportCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    bookingId?: SortOrder
    reportUrl?: SortOrder
    results?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    interpretation?: SortOrder
    recommendations?: SortOrder
    readyAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LabReportAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reviewedById?: SortOrder
  }

  export type LabReportMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    bookingId?: SortOrder
    reportUrl?: SortOrder
    results?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    interpretation?: SortOrder
    recommendations?: SortOrder
    readyAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LabReportMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    bookingId?: SortOrder
    reportUrl?: SortOrder
    results?: SortOrder
    status?: SortOrder
    reviewedById?: SortOrder
    interpretation?: SortOrder
    recommendations?: SortOrder
    readyAt?: SortOrder
    createdAt?: SortOrder
  }

  export type LabReportSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    reviewedById?: SortOrder
  }

  export type HealthRecordCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    documentDate?: SortOrder
    isPublic?: SortOrder
    sharedWith?: SortOrder
    createdAt?: SortOrder
  }

  export type HealthRecordAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileSize?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type HealthRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    documentDate?: SortOrder
    isPublic?: SortOrder
    sharedWith?: SortOrder
    createdAt?: SortOrder
  }

  export type HealthRecordMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    recordType?: SortOrder
    title?: SortOrder
    description?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileType?: SortOrder
    fileSize?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
    documentDate?: SortOrder
    isPublic?: SortOrder
    sharedWith?: SortOrder
    createdAt?: SortOrder
  }

  export type HealthRecordSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    fileSize?: SortOrder
    doctorId?: SortOrder
    appointmentId?: SortOrder
  }

  export type ForumPostCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
    pinned?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
  }

  export type ForumPostMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
    pinned?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    title?: SortOrder
    content?: SortOrder
    category?: SortOrder
    status?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
    pinned?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumPostSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
    downvotes?: SortOrder
    views?: SortOrder
    commentsCount?: SortOrder
  }

  export type ForumPostRelationFilter = {
    is?: ForumPostWhereInput
    isNot?: ForumPostWhereInput
  }

  export type ForumCommentNullableRelationFilter = {
    is?: ForumCommentWhereInput | null
    isNot?: ForumCommentWhereInput | null
  }

  export type ForumCommentCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
  }

  export type ForumCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
    verifiedDoctor?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ForumCommentSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    parentCommentId?: SortOrder
    upvotes?: SortOrder
    helpfulCount?: SortOrder
  }

  export type PostUpvotePostIdUserIdCompoundUniqueInput = {
    postId: number
    userId: number
  }

  export type PostUpvoteCountOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type PostUpvoteAvgOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type PostUpvoteMaxOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type PostUpvoteMinOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type PostUpvoteSumOrderByAggregateInput = {
    id?: SortOrder
    postId?: SortOrder
    userId?: SortOrder
  }

  export type ForumCommentRelationFilter = {
    is?: ForumCommentWhereInput
    isNot?: ForumCommentWhereInput
  }

  export type CommentUpvoteCommentIdUserIdCompoundUniqueInput = {
    commentId: number
    userId: number
  }

  export type CommentUpvoteCountOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type CommentUpvoteAvgOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type CommentUpvoteMaxOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type CommentUpvoteMinOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
    voteType?: SortOrder
  }

  export type CommentUpvoteSumOrderByAggregateInput = {
    id?: SortOrder
    commentId?: SortOrder
    userId?: SortOrder
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type ArticleCommentListRelationFilter = {
    every?: ArticleCommentWhereInput
    some?: ArticleCommentWhereInput
    none?: ArticleCommentWhereInput
  }

  export type ArticleCommentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HealthArticleCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    featuredImageUrl?: SortOrder
    status?: SortOrder
    views?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
  }

  export type HealthArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    featuredImageUrl?: SortOrder
    status?: SortOrder
    views?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthArticleMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    content?: SortOrder
    category?: SortOrder
    authorId?: SortOrder
    featuredImageUrl?: SortOrder
    status?: SortOrder
    views?: SortOrder
    publishedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type HealthArticleSumOrderByAggregateInput = {
    id?: SortOrder
    authorId?: SortOrder
    views?: SortOrder
  }

  export type HealthArticleRelationFilter = {
    is?: HealthArticleWhereInput
    isNot?: HealthArticleWhereInput
  }

  export type ArticleCommentCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleCommentAvgOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
  }

  export type ArticleCommentMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleCommentMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    content?: SortOrder
    upvotes?: SortOrder
    createdAt?: SortOrder
  }

  export type ArticleCommentSumOrderByAggregateInput = {
    id?: SortOrder
    articleId?: SortOrder
    userId?: SortOrder
    upvotes?: SortOrder
  }

  export type SavedArticleUserIdArticleIdCompoundUniqueInput = {
    userId: number
    articleId: number
  }

  export type SavedArticleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    savedAt?: SortOrder
  }

  export type SavedArticleAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type SavedArticleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    savedAt?: SortOrder
  }

  export type SavedArticleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
    savedAt?: SortOrder
  }

  export type SavedArticleSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    articleId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    data?: SortOrder
    read?: SortOrder
    actionUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SymptomCheckSessionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    result?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type SymptomCheckSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type SymptomCheckSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    result?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type SymptomCheckSessionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    result?: SortOrder
    riskLevel?: SortOrder
    createdAt?: SortOrder
  }

  export type SymptomCheckSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CoachSessionCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    savedPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachSessionAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type CoachSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    savedPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachSessionMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    userId?: SortOrder
    conversation?: SortOrder
    savedPlan?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CoachSessionSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type HealthProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutUserInput
    connect?: HealthProfileWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicineOrderCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput> | MedicineOrderCreateWithoutUserInput[] | MedicineOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutUserInput | MedicineOrderCreateOrConnectWithoutUserInput[]
    createMany?: MedicineOrderCreateManyUserInputEnvelope
    connect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
  }

  export type LabBookingCreateNestedManyWithoutUserInput = {
    create?: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput> | LabBookingCreateWithoutUserInput[] | LabBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LabBookingCreateOrConnectWithoutUserInput | LabBookingCreateOrConnectWithoutUserInput[]
    createMany?: LabBookingCreateManyUserInputEnvelope
    connect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
  }

  export type HealthRecordCreateNestedManyWithoutUserInput = {
    create?: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput> | HealthRecordCreateWithoutUserInput[] | HealthRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutUserInput | HealthRecordCreateOrConnectWithoutUserInput[]
    createMany?: HealthRecordCreateManyUserInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type ForumPostCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type PostUpvoteCreateNestedManyWithoutUserInput = {
    create?: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput> | PostUpvoteCreateWithoutUserInput[] | PostUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutUserInput | PostUpvoteCreateOrConnectWithoutUserInput[]
    createMany?: PostUpvoteCreateManyUserInputEnvelope
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
  }

  export type CommentUpvoteCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput> | CommentUpvoteCreateWithoutUserInput[] | CommentUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutUserInput | CommentUpvoteCreateOrConnectWithoutUserInput[]
    createMany?: CommentUpvoteCreateManyUserInputEnvelope
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
  }

  export type HealthArticleCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput> | HealthArticleCreateWithoutAuthorInput[] | HealthArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HealthArticleCreateOrConnectWithoutAuthorInput | HealthArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: HealthArticleCreateManyAuthorInputEnvelope
    connect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
  }

  export type SavedArticleCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput> | SavedArticleCreateWithoutUserInput[] | SavedArticleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutUserInput | SavedArticleCreateOrConnectWithoutUserInput[]
    createMany?: SavedArticleCreateManyUserInputEnvelope
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DoctorReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput> | DoctorReviewCreateWithoutUserInput[] | DoctorReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutUserInput | DoctorReviewCreateOrConnectWithoutUserInput[]
    createMany?: DoctorReviewCreateManyUserInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type SymptomCheckSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput> | SymptomCheckSessionCreateWithoutUserInput[] | SymptomCheckSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCheckSessionCreateOrConnectWithoutUserInput | SymptomCheckSessionCreateOrConnectWithoutUserInput[]
    createMany?: SymptomCheckSessionCreateManyUserInputEnvelope
    connect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
  }

  export type CoachSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput> | CoachSessionCreateWithoutUserInput[] | CoachSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachSessionCreateOrConnectWithoutUserInput | CoachSessionCreateOrConnectWithoutUserInput[]
    createMany?: CoachSessionCreateManyUserInputEnvelope
    connect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
  }

  export type HealthProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutUserInput
    connect?: HealthProfileWhereUniqueInput
  }

  export type DoctorUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    connect?: DoctorWhereUniqueInput
  }

  export type AppointmentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicineOrderUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput> | MedicineOrderCreateWithoutUserInput[] | MedicineOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutUserInput | MedicineOrderCreateOrConnectWithoutUserInput[]
    createMany?: MedicineOrderCreateManyUserInputEnvelope
    connect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
  }

  export type LabBookingUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput> | LabBookingCreateWithoutUserInput[] | LabBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LabBookingCreateOrConnectWithoutUserInput | LabBookingCreateOrConnectWithoutUserInput[]
    createMany?: LabBookingCreateManyUserInputEnvelope
    connect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
  }

  export type HealthRecordUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput> | HealthRecordCreateWithoutUserInput[] | HealthRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutUserInput | HealthRecordCreateOrConnectWithoutUserInput[]
    createMany?: HealthRecordCreateManyUserInputEnvelope
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
  }

  export type ForumPostUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type PostUpvoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput> | PostUpvoteCreateWithoutUserInput[] | PostUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutUserInput | PostUpvoteCreateOrConnectWithoutUserInput[]
    createMany?: PostUpvoteCreateManyUserInputEnvelope
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
  }

  export type CommentUpvoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput> | CommentUpvoteCreateWithoutUserInput[] | CommentUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutUserInput | CommentUpvoteCreateOrConnectWithoutUserInput[]
    createMany?: CommentUpvoteCreateManyUserInputEnvelope
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
  }

  export type HealthArticleUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput> | HealthArticleCreateWithoutAuthorInput[] | HealthArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HealthArticleCreateOrConnectWithoutAuthorInput | HealthArticleCreateOrConnectWithoutAuthorInput[]
    createMany?: HealthArticleCreateManyAuthorInputEnvelope
    connect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
  }

  export type SavedArticleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput> | SavedArticleCreateWithoutUserInput[] | SavedArticleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutUserInput | SavedArticleCreateOrConnectWithoutUserInput[]
    createMany?: SavedArticleCreateManyUserInputEnvelope
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type DoctorReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput> | DoctorReviewCreateWithoutUserInput[] | DoctorReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutUserInput | DoctorReviewCreateOrConnectWithoutUserInput[]
    createMany?: DoctorReviewCreateManyUserInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput> | SymptomCheckSessionCreateWithoutUserInput[] | SymptomCheckSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCheckSessionCreateOrConnectWithoutUserInput | SymptomCheckSessionCreateOrConnectWithoutUserInput[]
    createMany?: SymptomCheckSessionCreateManyUserInputEnvelope
    connect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
  }

  export type CoachSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput> | CoachSessionCreateWithoutUserInput[] | CoachSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachSessionCreateOrConnectWithoutUserInput | CoachSessionCreateOrConnectWithoutUserInput[]
    createMany?: CoachSessionCreateManyUserInputEnvelope
    connect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type HealthProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutUserInput
    upsert?: HealthProfileUpsertWithoutUserInput
    disconnect?: HealthProfileWhereInput | boolean
    delete?: HealthProfileWhereInput | boolean
    connect?: HealthProfileWhereUniqueInput
    update?: XOR<XOR<HealthProfileUpdateToOneWithWhereWithoutUserInput, HealthProfileUpdateWithoutUserInput>, HealthProfileUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicineOrderUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput> | MedicineOrderCreateWithoutUserInput[] | MedicineOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutUserInput | MedicineOrderCreateOrConnectWithoutUserInput[]
    upsert?: MedicineOrderUpsertWithWhereUniqueWithoutUserInput | MedicineOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicineOrderCreateManyUserInputEnvelope
    set?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    disconnect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    delete?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    connect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    update?: MedicineOrderUpdateWithWhereUniqueWithoutUserInput | MedicineOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicineOrderUpdateManyWithWhereWithoutUserInput | MedicineOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicineOrderScalarWhereInput | MedicineOrderScalarWhereInput[]
  }

  export type LabBookingUpdateManyWithoutUserNestedInput = {
    create?: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput> | LabBookingCreateWithoutUserInput[] | LabBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LabBookingCreateOrConnectWithoutUserInput | LabBookingCreateOrConnectWithoutUserInput[]
    upsert?: LabBookingUpsertWithWhereUniqueWithoutUserInput | LabBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LabBookingCreateManyUserInputEnvelope
    set?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    disconnect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    delete?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    connect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    update?: LabBookingUpdateWithWhereUniqueWithoutUserInput | LabBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LabBookingUpdateManyWithWhereWithoutUserInput | LabBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LabBookingScalarWhereInput | LabBookingScalarWhereInput[]
  }

  export type HealthRecordUpdateManyWithoutUserNestedInput = {
    create?: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput> | HealthRecordCreateWithoutUserInput[] | HealthRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutUserInput | HealthRecordCreateOrConnectWithoutUserInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutUserInput | HealthRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HealthRecordCreateManyUserInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutUserInput | HealthRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutUserInput | HealthRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type ForumPostUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutUserInput | ForumPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutUserInput | ForumPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutUserInput | ForumPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutUserInput | ForumCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutUserInput | ForumCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutUserInput | ForumCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type PostUpvoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput> | PostUpvoteCreateWithoutUserInput[] | PostUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutUserInput | PostUpvoteCreateOrConnectWithoutUserInput[]
    upsert?: PostUpvoteUpsertWithWhereUniqueWithoutUserInput | PostUpvoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostUpvoteCreateManyUserInputEnvelope
    set?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    disconnect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    delete?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    update?: PostUpvoteUpdateWithWhereUniqueWithoutUserInput | PostUpvoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpvoteUpdateManyWithWhereWithoutUserInput | PostUpvoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
  }

  export type CommentUpvoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput> | CommentUpvoteCreateWithoutUserInput[] | CommentUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutUserInput | CommentUpvoteCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpvoteUpsertWithWhereUniqueWithoutUserInput | CommentUpvoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentUpvoteCreateManyUserInputEnvelope
    set?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    disconnect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    delete?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    update?: CommentUpvoteUpdateWithWhereUniqueWithoutUserInput | CommentUpvoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpvoteUpdateManyWithWhereWithoutUserInput | CommentUpvoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
  }

  export type HealthArticleUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput> | HealthArticleCreateWithoutAuthorInput[] | HealthArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HealthArticleCreateOrConnectWithoutAuthorInput | HealthArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: HealthArticleUpsertWithWhereUniqueWithoutAuthorInput | HealthArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HealthArticleCreateManyAuthorInputEnvelope
    set?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    disconnect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    delete?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    connect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    update?: HealthArticleUpdateWithWhereUniqueWithoutAuthorInput | HealthArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HealthArticleUpdateManyWithWhereWithoutAuthorInput | HealthArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HealthArticleScalarWhereInput | HealthArticleScalarWhereInput[]
  }

  export type SavedArticleUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput> | SavedArticleCreateWithoutUserInput[] | SavedArticleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutUserInput | SavedArticleCreateOrConnectWithoutUserInput[]
    upsert?: SavedArticleUpsertWithWhereUniqueWithoutUserInput | SavedArticleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedArticleCreateManyUserInputEnvelope
    set?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    disconnect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    delete?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    update?: SavedArticleUpdateWithWhereUniqueWithoutUserInput | SavedArticleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedArticleUpdateManyWithWhereWithoutUserInput | SavedArticleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DoctorReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput> | DoctorReviewCreateWithoutUserInput[] | DoctorReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutUserInput | DoctorReviewCreateOrConnectWithoutUserInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutUserInput | DoctorReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoctorReviewCreateManyUserInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutUserInput | DoctorReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutUserInput | DoctorReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type SymptomCheckSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput> | SymptomCheckSessionCreateWithoutUserInput[] | SymptomCheckSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCheckSessionCreateOrConnectWithoutUserInput | SymptomCheckSessionCreateOrConnectWithoutUserInput[]
    upsert?: SymptomCheckSessionUpsertWithWhereUniqueWithoutUserInput | SymptomCheckSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomCheckSessionCreateManyUserInputEnvelope
    set?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    disconnect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    delete?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    connect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    update?: SymptomCheckSessionUpdateWithWhereUniqueWithoutUserInput | SymptomCheckSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomCheckSessionUpdateManyWithWhereWithoutUserInput | SymptomCheckSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomCheckSessionScalarWhereInput | SymptomCheckSessionScalarWhereInput[]
  }

  export type CoachSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput> | CoachSessionCreateWithoutUserInput[] | CoachSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachSessionCreateOrConnectWithoutUserInput | CoachSessionCreateOrConnectWithoutUserInput[]
    upsert?: CoachSessionUpsertWithWhereUniqueWithoutUserInput | CoachSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachSessionCreateManyUserInputEnvelope
    set?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    disconnect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    delete?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    connect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    update?: CoachSessionUpdateWithWhereUniqueWithoutUserInput | CoachSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachSessionUpdateManyWithWhereWithoutUserInput | CoachSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachSessionScalarWhereInput | CoachSessionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type HealthProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: HealthProfileCreateOrConnectWithoutUserInput
    upsert?: HealthProfileUpsertWithoutUserInput
    disconnect?: HealthProfileWhereInput | boolean
    delete?: HealthProfileWhereInput | boolean
    connect?: HealthProfileWhereUniqueInput
    update?: XOR<XOR<HealthProfileUpdateToOneWithWhereWithoutUserInput, HealthProfileUpdateWithoutUserInput>, HealthProfileUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutUserInput
    upsert?: DoctorUpsertWithoutUserInput
    disconnect?: DoctorWhereInput | boolean
    delete?: DoctorWhereInput | boolean
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutUserInput, DoctorUpdateWithoutUserInput>, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput> | AppointmentCreateWithoutUserInput[] | AppointmentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutUserInput | AppointmentCreateOrConnectWithoutUserInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutUserInput | AppointmentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AppointmentCreateManyUserInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutUserInput | AppointmentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutUserInput | AppointmentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput> | AppointmentCreateWithoutDoctorInput[] | AppointmentUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorInput | AppointmentCreateOrConnectWithoutDoctorInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorInput | AppointmentUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: AppointmentCreateManyDoctorInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorInput | AppointmentUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorInput | AppointmentUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicineOrderUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput> | MedicineOrderCreateWithoutUserInput[] | MedicineOrderUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutUserInput | MedicineOrderCreateOrConnectWithoutUserInput[]
    upsert?: MedicineOrderUpsertWithWhereUniqueWithoutUserInput | MedicineOrderUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MedicineOrderCreateManyUserInputEnvelope
    set?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    disconnect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    delete?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    connect?: MedicineOrderWhereUniqueInput | MedicineOrderWhereUniqueInput[]
    update?: MedicineOrderUpdateWithWhereUniqueWithoutUserInput | MedicineOrderUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MedicineOrderUpdateManyWithWhereWithoutUserInput | MedicineOrderUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MedicineOrderScalarWhereInput | MedicineOrderScalarWhereInput[]
  }

  export type LabBookingUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput> | LabBookingCreateWithoutUserInput[] | LabBookingUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LabBookingCreateOrConnectWithoutUserInput | LabBookingCreateOrConnectWithoutUserInput[]
    upsert?: LabBookingUpsertWithWhereUniqueWithoutUserInput | LabBookingUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LabBookingCreateManyUserInputEnvelope
    set?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    disconnect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    delete?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    connect?: LabBookingWhereUniqueInput | LabBookingWhereUniqueInput[]
    update?: LabBookingUpdateWithWhereUniqueWithoutUserInput | LabBookingUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LabBookingUpdateManyWithWhereWithoutUserInput | LabBookingUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LabBookingScalarWhereInput | LabBookingScalarWhereInput[]
  }

  export type HealthRecordUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput> | HealthRecordCreateWithoutUserInput[] | HealthRecordUncheckedCreateWithoutUserInput[]
    connectOrCreate?: HealthRecordCreateOrConnectWithoutUserInput | HealthRecordCreateOrConnectWithoutUserInput[]
    upsert?: HealthRecordUpsertWithWhereUniqueWithoutUserInput | HealthRecordUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: HealthRecordCreateManyUserInputEnvelope
    set?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    disconnect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    delete?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    connect?: HealthRecordWhereUniqueInput | HealthRecordWhereUniqueInput[]
    update?: HealthRecordUpdateWithWhereUniqueWithoutUserInput | HealthRecordUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: HealthRecordUpdateManyWithWhereWithoutUserInput | HealthRecordUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
  }

  export type ForumPostUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput> | ForumPostCreateWithoutUserInput[] | ForumPostUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumPostCreateOrConnectWithoutUserInput | ForumPostCreateOrConnectWithoutUserInput[]
    upsert?: ForumPostUpsertWithWhereUniqueWithoutUserInput | ForumPostUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumPostCreateManyUserInputEnvelope
    set?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    disconnect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    delete?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    connect?: ForumPostWhereUniqueInput | ForumPostWhereUniqueInput[]
    update?: ForumPostUpdateWithWhereUniqueWithoutUserInput | ForumPostUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumPostUpdateManyWithWhereWithoutUserInput | ForumPostUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput> | ForumCommentCreateWithoutUserInput[] | ForumCommentUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUserInput | ForumCommentCreateOrConnectWithoutUserInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutUserInput | ForumCommentUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ForumCommentCreateManyUserInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutUserInput | ForumCommentUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutUserInput | ForumCommentUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type PostUpvoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput> | PostUpvoteCreateWithoutUserInput[] | PostUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutUserInput | PostUpvoteCreateOrConnectWithoutUserInput[]
    upsert?: PostUpvoteUpsertWithWhereUniqueWithoutUserInput | PostUpvoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PostUpvoteCreateManyUserInputEnvelope
    set?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    disconnect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    delete?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    update?: PostUpvoteUpdateWithWhereUniqueWithoutUserInput | PostUpvoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PostUpvoteUpdateManyWithWhereWithoutUserInput | PostUpvoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
  }

  export type CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput> | CommentUpvoteCreateWithoutUserInput[] | CommentUpvoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutUserInput | CommentUpvoteCreateOrConnectWithoutUserInput[]
    upsert?: CommentUpvoteUpsertWithWhereUniqueWithoutUserInput | CommentUpvoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CommentUpvoteCreateManyUserInputEnvelope
    set?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    disconnect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    delete?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    update?: CommentUpvoteUpdateWithWhereUniqueWithoutUserInput | CommentUpvoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CommentUpvoteUpdateManyWithWhereWithoutUserInput | CommentUpvoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
  }

  export type HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput> | HealthArticleCreateWithoutAuthorInput[] | HealthArticleUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: HealthArticleCreateOrConnectWithoutAuthorInput | HealthArticleCreateOrConnectWithoutAuthorInput[]
    upsert?: HealthArticleUpsertWithWhereUniqueWithoutAuthorInput | HealthArticleUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: HealthArticleCreateManyAuthorInputEnvelope
    set?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    disconnect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    delete?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    connect?: HealthArticleWhereUniqueInput | HealthArticleWhereUniqueInput[]
    update?: HealthArticleUpdateWithWhereUniqueWithoutAuthorInput | HealthArticleUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: HealthArticleUpdateManyWithWhereWithoutAuthorInput | HealthArticleUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: HealthArticleScalarWhereInput | HealthArticleScalarWhereInput[]
  }

  export type SavedArticleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput> | SavedArticleCreateWithoutUserInput[] | SavedArticleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutUserInput | SavedArticleCreateOrConnectWithoutUserInput[]
    upsert?: SavedArticleUpsertWithWhereUniqueWithoutUserInput | SavedArticleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SavedArticleCreateManyUserInputEnvelope
    set?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    disconnect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    delete?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    update?: SavedArticleUpdateWithWhereUniqueWithoutUserInput | SavedArticleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SavedArticleUpdateManyWithWhereWithoutUserInput | SavedArticleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type DoctorReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput> | DoctorReviewCreateWithoutUserInput[] | DoctorReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutUserInput | DoctorReviewCreateOrConnectWithoutUserInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutUserInput | DoctorReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DoctorReviewCreateManyUserInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutUserInput | DoctorReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutUserInput | DoctorReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput> | SymptomCheckSessionCreateWithoutUserInput[] | SymptomCheckSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SymptomCheckSessionCreateOrConnectWithoutUserInput | SymptomCheckSessionCreateOrConnectWithoutUserInput[]
    upsert?: SymptomCheckSessionUpsertWithWhereUniqueWithoutUserInput | SymptomCheckSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SymptomCheckSessionCreateManyUserInputEnvelope
    set?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    disconnect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    delete?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    connect?: SymptomCheckSessionWhereUniqueInput | SymptomCheckSessionWhereUniqueInput[]
    update?: SymptomCheckSessionUpdateWithWhereUniqueWithoutUserInput | SymptomCheckSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SymptomCheckSessionUpdateManyWithWhereWithoutUserInput | SymptomCheckSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SymptomCheckSessionScalarWhereInput | SymptomCheckSessionScalarWhereInput[]
  }

  export type CoachSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput> | CoachSessionCreateWithoutUserInput[] | CoachSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CoachSessionCreateOrConnectWithoutUserInput | CoachSessionCreateOrConnectWithoutUserInput[]
    upsert?: CoachSessionUpsertWithWhereUniqueWithoutUserInput | CoachSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CoachSessionCreateManyUserInputEnvelope
    set?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    disconnect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    delete?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    connect?: CoachSessionWhereUniqueInput | CoachSessionWhereUniqueInput[]
    update?: CoachSessionUpdateWithWhereUniqueWithoutUserInput | CoachSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CoachSessionUpdateManyWithWhereWithoutUserInput | CoachSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CoachSessionScalarWhereInput | CoachSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutHealthProfileInput = {
    create?: XOR<UserCreateWithoutHealthProfileInput, UserUncheckedCreateWithoutHealthProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutHealthProfileNestedInput = {
    create?: XOR<UserCreateWithoutHealthProfileInput, UserUncheckedCreateWithoutHealthProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthProfileInput
    upsert?: UserUpsertWithoutHealthProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHealthProfileInput, UserUpdateWithoutHealthProfileInput>, UserUncheckedUpdateWithoutHealthProfileInput>
  }

  export type UserCreateNestedOneWithoutDoctorProfileInput = {
    create?: XOR<UserCreateWithoutDoctorProfileInput, UserUncheckedCreateWithoutDoctorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorProfileInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedManyWithoutDoctorProfileInput = {
    create?: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput> | AppointmentCreateWithoutDoctorProfileInput[] | AppointmentUncheckedCreateWithoutDoctorProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorProfileInput | AppointmentCreateOrConnectWithoutDoctorProfileInput[]
    createMany?: AppointmentCreateManyDoctorProfileInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DoctorReviewCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput> | DoctorReviewCreateWithoutDoctorInput[] | DoctorReviewUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutDoctorInput | DoctorReviewCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorReviewCreateManyDoctorInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutDoctorProfileInput = {
    create?: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput> | AppointmentCreateWithoutDoctorProfileInput[] | AppointmentUncheckedCreateWithoutDoctorProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorProfileInput | AppointmentCreateOrConnectWithoutDoctorProfileInput[]
    createMany?: AppointmentCreateManyDoctorProfileInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type DoctorReviewUncheckedCreateNestedManyWithoutDoctorInput = {
    create?: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput> | DoctorReviewCreateWithoutDoctorInput[] | DoctorReviewUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutDoctorInput | DoctorReviewCreateOrConnectWithoutDoctorInput[]
    createMany?: DoctorReviewCreateManyDoctorInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDoctorProfileNestedInput = {
    create?: XOR<UserCreateWithoutDoctorProfileInput, UserUncheckedCreateWithoutDoctorProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDoctorProfileInput
    upsert?: UserUpsertWithoutDoctorProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDoctorProfileInput, UserUpdateWithoutDoctorProfileInput>, UserUncheckedUpdateWithoutDoctorProfileInput>
  }

  export type AppointmentUpdateManyWithoutDoctorProfileNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput> | AppointmentCreateWithoutDoctorProfileInput[] | AppointmentUncheckedCreateWithoutDoctorProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorProfileInput | AppointmentCreateOrConnectWithoutDoctorProfileInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorProfileInput | AppointmentUpsertWithWhereUniqueWithoutDoctorProfileInput[]
    createMany?: AppointmentCreateManyDoctorProfileInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorProfileInput | AppointmentUpdateWithWhereUniqueWithoutDoctorProfileInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorProfileInput | AppointmentUpdateManyWithWhereWithoutDoctorProfileInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type DoctorReviewUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput> | DoctorReviewCreateWithoutDoctorInput[] | DoctorReviewUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutDoctorInput | DoctorReviewCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutDoctorInput | DoctorReviewUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorReviewCreateManyDoctorInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutDoctorInput | DoctorReviewUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutDoctorInput | DoctorReviewUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorProfileNestedInput = {
    create?: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput> | AppointmentCreateWithoutDoctorProfileInput[] | AppointmentUncheckedCreateWithoutDoctorProfileInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutDoctorProfileInput | AppointmentCreateOrConnectWithoutDoctorProfileInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutDoctorProfileInput | AppointmentUpsertWithWhereUniqueWithoutDoctorProfileInput[]
    createMany?: AppointmentCreateManyDoctorProfileInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutDoctorProfileInput | AppointmentUpdateWithWhereUniqueWithoutDoctorProfileInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutDoctorProfileInput | AppointmentUpdateManyWithWhereWithoutDoctorProfileInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type DoctorReviewUncheckedUpdateManyWithoutDoctorNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput> | DoctorReviewCreateWithoutDoctorInput[] | DoctorReviewUncheckedCreateWithoutDoctorInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutDoctorInput | DoctorReviewCreateOrConnectWithoutDoctorInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutDoctorInput | DoctorReviewUpsertWithWhereUniqueWithoutDoctorInput[]
    createMany?: DoctorReviewCreateManyDoctorInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutDoctorInput | DoctorReviewUpdateWithWhereUniqueWithoutDoctorInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutDoctorInput | DoctorReviewUpdateManyWithWhereWithoutDoctorInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type DoctorCreateNestedOneWithoutReviewsInput = {
    create?: XOR<DoctorCreateWithoutReviewsInput, DoctorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutReviewsInput
    connect?: DoctorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type AppointmentCreateNestedOneWithoutReviewsInput = {
    create?: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewsInput
    connect?: AppointmentWhereUniqueInput
  }

  export type DoctorUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<DoctorCreateWithoutReviewsInput, DoctorUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutReviewsInput
    upsert?: DoctorUpsertWithoutReviewsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutReviewsInput, DoctorUpdateWithoutReviewsInput>, DoctorUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type AppointmentUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutReviewsInput
    upsert?: AppointmentUpsertWithoutReviewsInput
    disconnect?: AppointmentWhereInput | boolean
    delete?: AppointmentWhereInput | boolean
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutReviewsInput, AppointmentUpdateWithoutReviewsInput>, AppointmentUncheckedUpdateWithoutReviewsInput>
  }

  export type UserCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutAppointmentsAsDoctorInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsDoctorInput, UserUncheckedCreateWithoutAppointmentsAsDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsDoctorInput
    connect?: UserWhereUniqueInput
  }

  export type DoctorCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
  }

  export type PrescriptionCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentsInput, PrescriptionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentsInput
    connect?: PrescriptionWhereUniqueInput
  }

  export type CallSessionCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAppointmentInput
    connect?: CallSessionWhereUniqueInput
  }

  export type DoctorReviewCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput> | DoctorReviewCreateWithoutAppointmentInput[] | DoctorReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutAppointmentInput | DoctorReviewCreateOrConnectWithoutAppointmentInput[]
    createMany?: DoctorReviewCreateManyAppointmentInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type CallSessionUncheckedCreateNestedOneWithoutAppointmentInput = {
    create?: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAppointmentInput
    connect?: CallSessionWhereUniqueInput
  }

  export type DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput = {
    create?: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput> | DoctorReviewCreateWithoutAppointmentInput[] | DoctorReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutAppointmentInput | DoctorReviewCreateOrConnectWithoutAppointmentInput[]
    createMany?: DoctorReviewCreateManyAppointmentInputEnvelope
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsInput
    upsert?: UserUpsertWithoutAppointmentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsInput, UserUpdateWithoutAppointmentsInput>, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput = {
    create?: XOR<UserCreateWithoutAppointmentsAsDoctorInput, UserUncheckedCreateWithoutAppointmentsAsDoctorInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppointmentsAsDoctorInput
    upsert?: UserUpsertWithoutAppointmentsAsDoctorInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppointmentsAsDoctorInput, UserUpdateWithoutAppointmentsAsDoctorInput>, UserUncheckedUpdateWithoutAppointmentsAsDoctorInput>
  }

  export type DoctorUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: DoctorCreateOrConnectWithoutAppointmentsInput
    upsert?: DoctorUpsertWithoutAppointmentsInput
    connect?: DoctorWhereUniqueInput
    update?: XOR<XOR<DoctorUpdateToOneWithWhereWithoutAppointmentsInput, DoctorUpdateWithoutAppointmentsInput>, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PrescriptionUpdateOneWithoutAppointmentsNestedInput = {
    create?: XOR<PrescriptionCreateWithoutAppointmentsInput, PrescriptionUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PrescriptionCreateOrConnectWithoutAppointmentsInput
    upsert?: PrescriptionUpsertWithoutAppointmentsInput
    disconnect?: PrescriptionWhereInput | boolean
    delete?: PrescriptionWhereInput | boolean
    connect?: PrescriptionWhereUniqueInput
    update?: XOR<XOR<PrescriptionUpdateToOneWithWhereWithoutAppointmentsInput, PrescriptionUpdateWithoutAppointmentsInput>, PrescriptionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type CallSessionUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAppointmentInput
    upsert?: CallSessionUpsertWithoutAppointmentInput
    disconnect?: CallSessionWhereInput | boolean
    delete?: CallSessionWhereInput | boolean
    connect?: CallSessionWhereUniqueInput
    update?: XOR<XOR<CallSessionUpdateToOneWithWhereWithoutAppointmentInput, CallSessionUpdateWithoutAppointmentInput>, CallSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type DoctorReviewUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput> | DoctorReviewCreateWithoutAppointmentInput[] | DoctorReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutAppointmentInput | DoctorReviewCreateOrConnectWithoutAppointmentInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutAppointmentInput | DoctorReviewUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: DoctorReviewCreateManyAppointmentInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutAppointmentInput | DoctorReviewUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutAppointmentInput | DoctorReviewUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput = {
    create?: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
    connectOrCreate?: CallSessionCreateOrConnectWithoutAppointmentInput
    upsert?: CallSessionUpsertWithoutAppointmentInput
    disconnect?: CallSessionWhereInput | boolean
    delete?: CallSessionWhereInput | boolean
    connect?: CallSessionWhereUniqueInput
    update?: XOR<XOR<CallSessionUpdateToOneWithWhereWithoutAppointmentInput, CallSessionUpdateWithoutAppointmentInput>, CallSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput = {
    create?: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput> | DoctorReviewCreateWithoutAppointmentInput[] | DoctorReviewUncheckedCreateWithoutAppointmentInput[]
    connectOrCreate?: DoctorReviewCreateOrConnectWithoutAppointmentInput | DoctorReviewCreateOrConnectWithoutAppointmentInput[]
    upsert?: DoctorReviewUpsertWithWhereUniqueWithoutAppointmentInput | DoctorReviewUpsertWithWhereUniqueWithoutAppointmentInput[]
    createMany?: DoctorReviewCreateManyAppointmentInputEnvelope
    set?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    disconnect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    delete?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    connect?: DoctorReviewWhereUniqueInput | DoctorReviewWhereUniqueInput[]
    update?: DoctorReviewUpdateWithWhereUniqueWithoutAppointmentInput | DoctorReviewUpdateWithWhereUniqueWithoutAppointmentInput[]
    updateMany?: DoctorReviewUpdateManyWithWhereWithoutAppointmentInput | DoctorReviewUpdateManyWithWhereWithoutAppointmentInput[]
    deleteMany?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
  }

  export type AppointmentCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput> | AppointmentCreateWithoutPrescriptionInput[] | AppointmentUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionInput | AppointmentCreateOrConnectWithoutPrescriptionInput[]
    createMany?: AppointmentCreateManyPrescriptionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPrescriptionInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput> | AppointmentCreateWithoutPrescriptionInput[] | AppointmentUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionInput | AppointmentCreateOrConnectWithoutPrescriptionInput[]
    createMany?: AppointmentCreateManyPrescriptionInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type AppointmentUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput> | AppointmentCreateWithoutPrescriptionInput[] | AppointmentUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionInput | AppointmentCreateOrConnectWithoutPrescriptionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPrescriptionInput | AppointmentUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: AppointmentCreateManyPrescriptionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPrescriptionInput | AppointmentUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPrescriptionInput | AppointmentUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPrescriptionNestedInput = {
    create?: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput> | AppointmentCreateWithoutPrescriptionInput[] | AppointmentUncheckedCreateWithoutPrescriptionInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPrescriptionInput | AppointmentCreateOrConnectWithoutPrescriptionInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPrescriptionInput | AppointmentUpsertWithWhereUniqueWithoutPrescriptionInput[]
    createMany?: AppointmentCreateManyPrescriptionInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPrescriptionInput | AppointmentUpdateWithWhereUniqueWithoutPrescriptionInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPrescriptionInput | AppointmentUpdateManyWithWhereWithoutPrescriptionInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type AppointmentCreateNestedOneWithoutCallSessionInput = {
    create?: XOR<AppointmentCreateWithoutCallSessionInput, AppointmentUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCallSessionInput
    connect?: AppointmentWhereUniqueInput
  }

  export type AppointmentUpdateOneRequiredWithoutCallSessionNestedInput = {
    create?: XOR<AppointmentCreateWithoutCallSessionInput, AppointmentUncheckedCreateWithoutCallSessionInput>
    connectOrCreate?: AppointmentCreateOrConnectWithoutCallSessionInput
    upsert?: AppointmentUpsertWithoutCallSessionInput
    connect?: AppointmentWhereUniqueInput
    update?: XOR<XOR<AppointmentUpdateToOneWithWhereWithoutCallSessionInput, AppointmentUpdateWithoutCallSessionInput>, AppointmentUncheckedUpdateWithoutCallSessionInput>
  }

  export type MedicineOrderItemCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput> | MedicineOrderItemCreateWithoutMedicineInput[] | MedicineOrderItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutMedicineInput | MedicineOrderItemCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineOrderItemCreateManyMedicineInputEnvelope
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
  }

  export type MedicineOrderItemUncheckedCreateNestedManyWithoutMedicineInput = {
    create?: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput> | MedicineOrderItemCreateWithoutMedicineInput[] | MedicineOrderItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutMedicineInput | MedicineOrderItemCreateOrConnectWithoutMedicineInput[]
    createMany?: MedicineOrderItemCreateManyMedicineInputEnvelope
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
  }

  export type MedicineOrderItemUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput> | MedicineOrderItemCreateWithoutMedicineInput[] | MedicineOrderItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutMedicineInput | MedicineOrderItemCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineOrderItemUpsertWithWhereUniqueWithoutMedicineInput | MedicineOrderItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineOrderItemCreateManyMedicineInputEnvelope
    set?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    disconnect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    delete?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    update?: MedicineOrderItemUpdateWithWhereUniqueWithoutMedicineInput | MedicineOrderItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineOrderItemUpdateManyWithWhereWithoutMedicineInput | MedicineOrderItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
  }

  export type MedicineOrderItemUncheckedUpdateManyWithoutMedicineNestedInput = {
    create?: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput> | MedicineOrderItemCreateWithoutMedicineInput[] | MedicineOrderItemUncheckedCreateWithoutMedicineInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutMedicineInput | MedicineOrderItemCreateOrConnectWithoutMedicineInput[]
    upsert?: MedicineOrderItemUpsertWithWhereUniqueWithoutMedicineInput | MedicineOrderItemUpsertWithWhereUniqueWithoutMedicineInput[]
    createMany?: MedicineOrderItemCreateManyMedicineInputEnvelope
    set?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    disconnect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    delete?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    update?: MedicineOrderItemUpdateWithWhereUniqueWithoutMedicineInput | MedicineOrderItemUpdateWithWhereUniqueWithoutMedicineInput[]
    updateMany?: MedicineOrderItemUpdateManyWithWhereWithoutMedicineInput | MedicineOrderItemUpdateManyWithWhereWithoutMedicineInput[]
    deleteMany?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutMedicineOrdersInput = {
    create?: XOR<UserCreateWithoutMedicineOrdersInput, UserUncheckedCreateWithoutMedicineOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicineOrdersInput
    connect?: UserWhereUniqueInput
  }

  export type MedicineOrderItemCreateNestedManyWithoutOrderInput = {
    create?: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput> | MedicineOrderItemCreateWithoutOrderInput[] | MedicineOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutOrderInput | MedicineOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: MedicineOrderItemCreateManyOrderInputEnvelope
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
  }

  export type MedicineOrderItemUncheckedCreateNestedManyWithoutOrderInput = {
    create?: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput> | MedicineOrderItemCreateWithoutOrderInput[] | MedicineOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutOrderInput | MedicineOrderItemCreateOrConnectWithoutOrderInput[]
    createMany?: MedicineOrderItemCreateManyOrderInputEnvelope
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutMedicineOrdersNestedInput = {
    create?: XOR<UserCreateWithoutMedicineOrdersInput, UserUncheckedCreateWithoutMedicineOrdersInput>
    connectOrCreate?: UserCreateOrConnectWithoutMedicineOrdersInput
    upsert?: UserUpsertWithoutMedicineOrdersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMedicineOrdersInput, UserUpdateWithoutMedicineOrdersInput>, UserUncheckedUpdateWithoutMedicineOrdersInput>
  }

  export type MedicineOrderItemUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput> | MedicineOrderItemCreateWithoutOrderInput[] | MedicineOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutOrderInput | MedicineOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: MedicineOrderItemUpsertWithWhereUniqueWithoutOrderInput | MedicineOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MedicineOrderItemCreateManyOrderInputEnvelope
    set?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    disconnect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    delete?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    update?: MedicineOrderItemUpdateWithWhereUniqueWithoutOrderInput | MedicineOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MedicineOrderItemUpdateManyWithWhereWithoutOrderInput | MedicineOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
  }

  export type MedicineOrderItemUncheckedUpdateManyWithoutOrderNestedInput = {
    create?: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput> | MedicineOrderItemCreateWithoutOrderInput[] | MedicineOrderItemUncheckedCreateWithoutOrderInput[]
    connectOrCreate?: MedicineOrderItemCreateOrConnectWithoutOrderInput | MedicineOrderItemCreateOrConnectWithoutOrderInput[]
    upsert?: MedicineOrderItemUpsertWithWhereUniqueWithoutOrderInput | MedicineOrderItemUpsertWithWhereUniqueWithoutOrderInput[]
    createMany?: MedicineOrderItemCreateManyOrderInputEnvelope
    set?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    disconnect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    delete?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    connect?: MedicineOrderItemWhereUniqueInput | MedicineOrderItemWhereUniqueInput[]
    update?: MedicineOrderItemUpdateWithWhereUniqueWithoutOrderInput | MedicineOrderItemUpdateWithWhereUniqueWithoutOrderInput[]
    updateMany?: MedicineOrderItemUpdateManyWithWhereWithoutOrderInput | MedicineOrderItemUpdateManyWithWhereWithoutOrderInput[]
    deleteMany?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
  }

  export type MedicineOrderCreateNestedOneWithoutItemsInput = {
    create?: XOR<MedicineOrderCreateWithoutItemsInput, MedicineOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutItemsInput
    connect?: MedicineOrderWhereUniqueInput
  }

  export type MedicineCreateNestedOneWithoutOrderItemsInput = {
    create?: XOR<MedicineCreateWithoutOrderItemsInput, MedicineUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutOrderItemsInput
    connect?: MedicineWhereUniqueInput
  }

  export type MedicineOrderUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<MedicineOrderCreateWithoutItemsInput, MedicineOrderUncheckedCreateWithoutItemsInput>
    connectOrCreate?: MedicineOrderCreateOrConnectWithoutItemsInput
    upsert?: MedicineOrderUpsertWithoutItemsInput
    connect?: MedicineOrderWhereUniqueInput
    update?: XOR<XOR<MedicineOrderUpdateToOneWithWhereWithoutItemsInput, MedicineOrderUpdateWithoutItemsInput>, MedicineOrderUncheckedUpdateWithoutItemsInput>
  }

  export type MedicineUpdateOneRequiredWithoutOrderItemsNestedInput = {
    create?: XOR<MedicineCreateWithoutOrderItemsInput, MedicineUncheckedCreateWithoutOrderItemsInput>
    connectOrCreate?: MedicineCreateOrConnectWithoutOrderItemsInput
    upsert?: MedicineUpsertWithoutOrderItemsInput
    connect?: MedicineWhereUniqueInput
    update?: XOR<XOR<MedicineUpdateToOneWithWhereWithoutOrderItemsInput, MedicineUpdateWithoutOrderItemsInput>, MedicineUncheckedUpdateWithoutOrderItemsInput>
  }

  export type LabBookingTestCreateNestedManyWithoutTestInput = {
    create?: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput> | LabBookingTestCreateWithoutTestInput[] | LabBookingTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutTestInput | LabBookingTestCreateOrConnectWithoutTestInput[]
    createMany?: LabBookingTestCreateManyTestInputEnvelope
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
  }

  export type LabBookingTestUncheckedCreateNestedManyWithoutTestInput = {
    create?: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput> | LabBookingTestCreateWithoutTestInput[] | LabBookingTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutTestInput | LabBookingTestCreateOrConnectWithoutTestInput[]
    createMany?: LabBookingTestCreateManyTestInputEnvelope
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
  }

  export type LabBookingTestUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput> | LabBookingTestCreateWithoutTestInput[] | LabBookingTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutTestInput | LabBookingTestCreateOrConnectWithoutTestInput[]
    upsert?: LabBookingTestUpsertWithWhereUniqueWithoutTestInput | LabBookingTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabBookingTestCreateManyTestInputEnvelope
    set?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    disconnect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    delete?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    update?: LabBookingTestUpdateWithWhereUniqueWithoutTestInput | LabBookingTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabBookingTestUpdateManyWithWhereWithoutTestInput | LabBookingTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
  }

  export type LabBookingTestUncheckedUpdateManyWithoutTestNestedInput = {
    create?: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput> | LabBookingTestCreateWithoutTestInput[] | LabBookingTestUncheckedCreateWithoutTestInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutTestInput | LabBookingTestCreateOrConnectWithoutTestInput[]
    upsert?: LabBookingTestUpsertWithWhereUniqueWithoutTestInput | LabBookingTestUpsertWithWhereUniqueWithoutTestInput[]
    createMany?: LabBookingTestCreateManyTestInputEnvelope
    set?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    disconnect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    delete?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    update?: LabBookingTestUpdateWithWhereUniqueWithoutTestInput | LabBookingTestUpdateWithWhereUniqueWithoutTestInput[]
    updateMany?: LabBookingTestUpdateManyWithWhereWithoutTestInput | LabBookingTestUpdateManyWithWhereWithoutTestInput[]
    deleteMany?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutLabBookingsInput = {
    create?: XOR<UserCreateWithoutLabBookingsInput, UserUncheckedCreateWithoutLabBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type LabBookingTestCreateNestedManyWithoutBookingInput = {
    create?: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput> | LabBookingTestCreateWithoutBookingInput[] | LabBookingTestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutBookingInput | LabBookingTestCreateOrConnectWithoutBookingInput[]
    createMany?: LabBookingTestCreateManyBookingInputEnvelope
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
  }

  export type LabReportCreateNestedOneWithoutBookingInput = {
    create?: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutBookingInput
    connect?: LabReportWhereUniqueInput
  }

  export type LabBookingTestUncheckedCreateNestedManyWithoutBookingInput = {
    create?: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput> | LabBookingTestCreateWithoutBookingInput[] | LabBookingTestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutBookingInput | LabBookingTestCreateOrConnectWithoutBookingInput[]
    createMany?: LabBookingTestCreateManyBookingInputEnvelope
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
  }

  export type LabReportUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutBookingInput
    connect?: LabReportWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLabBookingsNestedInput = {
    create?: XOR<UserCreateWithoutLabBookingsInput, UserUncheckedCreateWithoutLabBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLabBookingsInput
    upsert?: UserUpsertWithoutLabBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLabBookingsInput, UserUpdateWithoutLabBookingsInput>, UserUncheckedUpdateWithoutLabBookingsInput>
  }

  export type LabBookingTestUpdateManyWithoutBookingNestedInput = {
    create?: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput> | LabBookingTestCreateWithoutBookingInput[] | LabBookingTestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutBookingInput | LabBookingTestCreateOrConnectWithoutBookingInput[]
    upsert?: LabBookingTestUpsertWithWhereUniqueWithoutBookingInput | LabBookingTestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: LabBookingTestCreateManyBookingInputEnvelope
    set?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    disconnect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    delete?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    update?: LabBookingTestUpdateWithWhereUniqueWithoutBookingInput | LabBookingTestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: LabBookingTestUpdateManyWithWhereWithoutBookingInput | LabBookingTestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
  }

  export type LabReportUpdateOneWithoutBookingNestedInput = {
    create?: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutBookingInput
    upsert?: LabReportUpsertWithoutBookingInput
    disconnect?: LabReportWhereInput | boolean
    delete?: LabReportWhereInput | boolean
    connect?: LabReportWhereUniqueInput
    update?: XOR<XOR<LabReportUpdateToOneWithWhereWithoutBookingInput, LabReportUpdateWithoutBookingInput>, LabReportUncheckedUpdateWithoutBookingInput>
  }

  export type LabBookingTestUncheckedUpdateManyWithoutBookingNestedInput = {
    create?: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput> | LabBookingTestCreateWithoutBookingInput[] | LabBookingTestUncheckedCreateWithoutBookingInput[]
    connectOrCreate?: LabBookingTestCreateOrConnectWithoutBookingInput | LabBookingTestCreateOrConnectWithoutBookingInput[]
    upsert?: LabBookingTestUpsertWithWhereUniqueWithoutBookingInput | LabBookingTestUpsertWithWhereUniqueWithoutBookingInput[]
    createMany?: LabBookingTestCreateManyBookingInputEnvelope
    set?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    disconnect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    delete?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    connect?: LabBookingTestWhereUniqueInput | LabBookingTestWhereUniqueInput[]
    update?: LabBookingTestUpdateWithWhereUniqueWithoutBookingInput | LabBookingTestUpdateWithWhereUniqueWithoutBookingInput[]
    updateMany?: LabBookingTestUpdateManyWithWhereWithoutBookingInput | LabBookingTestUpdateManyWithWhereWithoutBookingInput[]
    deleteMany?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
  }

  export type LabReportUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
    connectOrCreate?: LabReportCreateOrConnectWithoutBookingInput
    upsert?: LabReportUpsertWithoutBookingInput
    disconnect?: LabReportWhereInput | boolean
    delete?: LabReportWhereInput | boolean
    connect?: LabReportWhereUniqueInput
    update?: XOR<XOR<LabReportUpdateToOneWithWhereWithoutBookingInput, LabReportUpdateWithoutBookingInput>, LabReportUncheckedUpdateWithoutBookingInput>
  }

  export type LabBookingCreateNestedOneWithoutTestsInput = {
    create?: XOR<LabBookingCreateWithoutTestsInput, LabBookingUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabBookingCreateOrConnectWithoutTestsInput
    connect?: LabBookingWhereUniqueInput
  }

  export type LabTestCreateNestedOneWithoutBookingsInput = {
    create?: XOR<LabTestCreateWithoutBookingsInput, LabTestUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutBookingsInput
    connect?: LabTestWhereUniqueInput
  }

  export type LabBookingUpdateOneRequiredWithoutTestsNestedInput = {
    create?: XOR<LabBookingCreateWithoutTestsInput, LabBookingUncheckedCreateWithoutTestsInput>
    connectOrCreate?: LabBookingCreateOrConnectWithoutTestsInput
    upsert?: LabBookingUpsertWithoutTestsInput
    connect?: LabBookingWhereUniqueInput
    update?: XOR<XOR<LabBookingUpdateToOneWithWhereWithoutTestsInput, LabBookingUpdateWithoutTestsInput>, LabBookingUncheckedUpdateWithoutTestsInput>
  }

  export type LabTestUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<LabTestCreateWithoutBookingsInput, LabTestUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: LabTestCreateOrConnectWithoutBookingsInput
    upsert?: LabTestUpsertWithoutBookingsInput
    connect?: LabTestWhereUniqueInput
    update?: XOR<XOR<LabTestUpdateToOneWithWhereWithoutBookingsInput, LabTestUpdateWithoutBookingsInput>, LabTestUncheckedUpdateWithoutBookingsInput>
  }

  export type LabBookingCreateNestedOneWithoutReportInput = {
    create?: XOR<LabBookingCreateWithoutReportInput, LabBookingUncheckedCreateWithoutReportInput>
    connectOrCreate?: LabBookingCreateOrConnectWithoutReportInput
    connect?: LabBookingWhereUniqueInput
  }

  export type LabBookingUpdateOneRequiredWithoutReportNestedInput = {
    create?: XOR<LabBookingCreateWithoutReportInput, LabBookingUncheckedCreateWithoutReportInput>
    connectOrCreate?: LabBookingCreateOrConnectWithoutReportInput
    upsert?: LabBookingUpsertWithoutReportInput
    connect?: LabBookingWhereUniqueInput
    update?: XOR<XOR<LabBookingUpdateToOneWithWhereWithoutReportInput, LabBookingUpdateWithoutReportInput>, LabBookingUncheckedUpdateWithoutReportInput>
  }

  export type UserCreateNestedOneWithoutHealthRecordsInput = {
    create?: XOR<UserCreateWithoutHealthRecordsInput, UserUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthRecordsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutHealthRecordsNestedInput = {
    create?: XOR<UserCreateWithoutHealthRecordsInput, UserUncheckedCreateWithoutHealthRecordsInput>
    connectOrCreate?: UserCreateOrConnectWithoutHealthRecordsInput
    upsert?: UserUpsertWithoutHealthRecordsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutHealthRecordsInput, UserUpdateWithoutHealthRecordsInput>, UserUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type UserCreateNestedOneWithoutForumPostsInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumCommentCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type PostUpvoteCreateNestedManyWithoutPostInput = {
    create?: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput> | PostUpvoteCreateWithoutPostInput[] | PostUpvoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutPostInput | PostUpvoteCreateOrConnectWithoutPostInput[]
    createMany?: PostUpvoteCreateManyPostInputEnvelope
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type PostUpvoteUncheckedCreateNestedManyWithoutPostInput = {
    create?: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput> | PostUpvoteCreateWithoutPostInput[] | PostUpvoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutPostInput | PostUpvoteCreateOrConnectWithoutPostInput[]
    createMany?: PostUpvoteCreateManyPostInputEnvelope
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutForumPostsNestedInput = {
    create?: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumPostsInput
    upsert?: UserUpsertWithoutForumPostsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumPostsInput, UserUpdateWithoutForumPostsInput>, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type ForumCommentUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type PostUpvoteUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput> | PostUpvoteCreateWithoutPostInput[] | PostUpvoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutPostInput | PostUpvoteCreateOrConnectWithoutPostInput[]
    upsert?: PostUpvoteUpsertWithWhereUniqueWithoutPostInput | PostUpvoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostUpvoteCreateManyPostInputEnvelope
    set?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    disconnect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    delete?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    update?: PostUpvoteUpdateWithWhereUniqueWithoutPostInput | PostUpvoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostUpvoteUpdateManyWithWhereWithoutPostInput | PostUpvoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput> | ForumCommentCreateWithoutPostInput[] | ForumCommentUncheckedCreateWithoutPostInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutPostInput | ForumCommentCreateOrConnectWithoutPostInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutPostInput | ForumCommentUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: ForumCommentCreateManyPostInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutPostInput | ForumCommentUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutPostInput | ForumCommentUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type PostUpvoteUncheckedUpdateManyWithoutPostNestedInput = {
    create?: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput> | PostUpvoteCreateWithoutPostInput[] | PostUpvoteUncheckedCreateWithoutPostInput[]
    connectOrCreate?: PostUpvoteCreateOrConnectWithoutPostInput | PostUpvoteCreateOrConnectWithoutPostInput[]
    upsert?: PostUpvoteUpsertWithWhereUniqueWithoutPostInput | PostUpvoteUpsertWithWhereUniqueWithoutPostInput[]
    createMany?: PostUpvoteCreateManyPostInputEnvelope
    set?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    disconnect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    delete?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    connect?: PostUpvoteWhereUniqueInput | PostUpvoteWhereUniqueInput[]
    update?: PostUpvoteUpdateWithWhereUniqueWithoutPostInput | PostUpvoteUpdateWithWhereUniqueWithoutPostInput[]
    updateMany?: PostUpvoteUpdateManyWithWhereWithoutPostInput | PostUpvoteUpdateManyWithWhereWithoutPostInput[]
    deleteMany?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
  }

  export type ForumPostCreateNestedOneWithoutCommentsInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutForumCommentsInput = {
    create?: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumCommentsInput
    connect?: UserWhereUniqueInput
  }

  export type ForumCommentCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ForumCommentCreateWithoutRepliesInput, ForumCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumCommentCreateOrConnectWithoutRepliesInput
    connect?: ForumCommentWhereUniqueInput
  }

  export type ForumCommentCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput> | ForumCommentCreateWithoutParentCommentInput[] | ForumCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutParentCommentInput | ForumCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: ForumCommentCreateManyParentCommentInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type CommentUpvoteCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput> | CommentUpvoteCreateWithoutCommentInput[] | CommentUpvoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutCommentInput | CommentUpvoteCreateOrConnectWithoutCommentInput[]
    createMany?: CommentUpvoteCreateManyCommentInputEnvelope
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
  }

  export type ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput = {
    create?: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput> | ForumCommentCreateWithoutParentCommentInput[] | ForumCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutParentCommentInput | ForumCommentCreateOrConnectWithoutParentCommentInput[]
    createMany?: ForumCommentCreateManyParentCommentInputEnvelope
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
  }

  export type CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput = {
    create?: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput> | CommentUpvoteCreateWithoutCommentInput[] | CommentUpvoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutCommentInput | CommentUpvoteCreateOrConnectWithoutCommentInput[]
    createMany?: CommentUpvoteCreateManyCommentInputEnvelope
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
  }

  export type ForumPostUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutCommentsInput
    upsert?: ForumPostUpsertWithoutCommentsInput
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutCommentsInput, ForumPostUpdateWithoutCommentsInput>, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type UserUpdateOneRequiredWithoutForumCommentsNestedInput = {
    create?: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    connectOrCreate?: UserCreateOrConnectWithoutForumCommentsInput
    upsert?: UserUpsertWithoutForumCommentsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutForumCommentsInput, UserUpdateWithoutForumCommentsInput>, UserUncheckedUpdateWithoutForumCommentsInput>
  }

  export type ForumCommentUpdateOneWithoutRepliesNestedInput = {
    create?: XOR<ForumCommentCreateWithoutRepliesInput, ForumCommentUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ForumCommentCreateOrConnectWithoutRepliesInput
    upsert?: ForumCommentUpsertWithoutRepliesInput
    disconnect?: ForumCommentWhereInput | boolean
    delete?: ForumCommentWhereInput | boolean
    connect?: ForumCommentWhereUniqueInput
    update?: XOR<XOR<ForumCommentUpdateToOneWithWhereWithoutRepliesInput, ForumCommentUpdateWithoutRepliesInput>, ForumCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumCommentUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput> | ForumCommentCreateWithoutParentCommentInput[] | ForumCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutParentCommentInput | ForumCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutParentCommentInput | ForumCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: ForumCommentCreateManyParentCommentInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutParentCommentInput | ForumCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutParentCommentInput | ForumCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type CommentUpvoteUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput> | CommentUpvoteCreateWithoutCommentInput[] | CommentUpvoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutCommentInput | CommentUpvoteCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput | CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentUpvoteCreateManyCommentInputEnvelope
    set?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    disconnect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    delete?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    update?: CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput | CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpvoteUpdateManyWithWhereWithoutCommentInput | CommentUpvoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
  }

  export type ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput = {
    create?: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput> | ForumCommentCreateWithoutParentCommentInput[] | ForumCommentUncheckedCreateWithoutParentCommentInput[]
    connectOrCreate?: ForumCommentCreateOrConnectWithoutParentCommentInput | ForumCommentCreateOrConnectWithoutParentCommentInput[]
    upsert?: ForumCommentUpsertWithWhereUniqueWithoutParentCommentInput | ForumCommentUpsertWithWhereUniqueWithoutParentCommentInput[]
    createMany?: ForumCommentCreateManyParentCommentInputEnvelope
    set?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    disconnect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    delete?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    connect?: ForumCommentWhereUniqueInput | ForumCommentWhereUniqueInput[]
    update?: ForumCommentUpdateWithWhereUniqueWithoutParentCommentInput | ForumCommentUpdateWithWhereUniqueWithoutParentCommentInput[]
    updateMany?: ForumCommentUpdateManyWithWhereWithoutParentCommentInput | ForumCommentUpdateManyWithWhereWithoutParentCommentInput[]
    deleteMany?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
  }

  export type CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput = {
    create?: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput> | CommentUpvoteCreateWithoutCommentInput[] | CommentUpvoteUncheckedCreateWithoutCommentInput[]
    connectOrCreate?: CommentUpvoteCreateOrConnectWithoutCommentInput | CommentUpvoteCreateOrConnectWithoutCommentInput[]
    upsert?: CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput | CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput[]
    createMany?: CommentUpvoteCreateManyCommentInputEnvelope
    set?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    disconnect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    delete?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    connect?: CommentUpvoteWhereUniqueInput | CommentUpvoteWhereUniqueInput[]
    update?: CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput | CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput[]
    updateMany?: CommentUpvoteUpdateManyWithWhereWithoutCommentInput | CommentUpvoteUpdateManyWithWhereWithoutCommentInput[]
    deleteMany?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
  }

  export type ForumPostCreateNestedOneWithoutUpvotesByUserInput = {
    create?: XOR<ForumPostCreateWithoutUpvotesByUserInput, ForumPostUncheckedCreateWithoutUpvotesByUserInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutUpvotesByUserInput
    connect?: ForumPostWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPostUpvotesInput = {
    create?: XOR<UserCreateWithoutPostUpvotesInput, UserUncheckedCreateWithoutPostUpvotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostUpvotesInput
    connect?: UserWhereUniqueInput
  }

  export type ForumPostUpdateOneRequiredWithoutUpvotesByUserNestedInput = {
    create?: XOR<ForumPostCreateWithoutUpvotesByUserInput, ForumPostUncheckedCreateWithoutUpvotesByUserInput>
    connectOrCreate?: ForumPostCreateOrConnectWithoutUpvotesByUserInput
    upsert?: ForumPostUpsertWithoutUpvotesByUserInput
    connect?: ForumPostWhereUniqueInput
    update?: XOR<XOR<ForumPostUpdateToOneWithWhereWithoutUpvotesByUserInput, ForumPostUpdateWithoutUpvotesByUserInput>, ForumPostUncheckedUpdateWithoutUpvotesByUserInput>
  }

  export type UserUpdateOneRequiredWithoutPostUpvotesNestedInput = {
    create?: XOR<UserCreateWithoutPostUpvotesInput, UserUncheckedCreateWithoutPostUpvotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutPostUpvotesInput
    upsert?: UserUpsertWithoutPostUpvotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPostUpvotesInput, UserUpdateWithoutPostUpvotesInput>, UserUncheckedUpdateWithoutPostUpvotesInput>
  }

  export type ForumCommentCreateNestedOneWithoutUpvotesByUserInput = {
    create?: XOR<ForumCommentCreateWithoutUpvotesByUserInput, ForumCommentUncheckedCreateWithoutUpvotesByUserInput>
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUpvotesByUserInput
    connect?: ForumCommentWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCommentUpvotesInput = {
    create?: XOR<UserCreateWithoutCommentUpvotesInput, UserUncheckedCreateWithoutCommentUpvotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentUpvotesInput
    connect?: UserWhereUniqueInput
  }

  export type ForumCommentUpdateOneRequiredWithoutUpvotesByUserNestedInput = {
    create?: XOR<ForumCommentCreateWithoutUpvotesByUserInput, ForumCommentUncheckedCreateWithoutUpvotesByUserInput>
    connectOrCreate?: ForumCommentCreateOrConnectWithoutUpvotesByUserInput
    upsert?: ForumCommentUpsertWithoutUpvotesByUserInput
    connect?: ForumCommentWhereUniqueInput
    update?: XOR<XOR<ForumCommentUpdateToOneWithWhereWithoutUpvotesByUserInput, ForumCommentUpdateWithoutUpvotesByUserInput>, ForumCommentUncheckedUpdateWithoutUpvotesByUserInput>
  }

  export type UserUpdateOneRequiredWithoutCommentUpvotesNestedInput = {
    create?: XOR<UserCreateWithoutCommentUpvotesInput, UserUncheckedCreateWithoutCommentUpvotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCommentUpvotesInput
    upsert?: UserUpsertWithoutCommentUpvotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCommentUpvotesInput, UserUpdateWithoutCommentUpvotesInput>, UserUncheckedUpdateWithoutCommentUpvotesInput>
  }

  export type UserCreateNestedOneWithoutArticlesInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type ArticleCommentCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput> | ArticleCommentCreateWithoutArticleInput[] | ArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCommentCreateOrConnectWithoutArticleInput | ArticleCommentCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    connect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
  }

  export type SavedArticleCreateNestedManyWithoutArticleInput = {
    create?: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput> | SavedArticleCreateWithoutArticleInput[] | SavedArticleUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutArticleInput | SavedArticleCreateOrConnectWithoutArticleInput[]
    createMany?: SavedArticleCreateManyArticleInputEnvelope
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
  }

  export type ArticleCommentUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput> | ArticleCommentCreateWithoutArticleInput[] | ArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCommentCreateOrConnectWithoutArticleInput | ArticleCommentCreateOrConnectWithoutArticleInput[]
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    connect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
  }

  export type SavedArticleUncheckedCreateNestedManyWithoutArticleInput = {
    create?: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput> | SavedArticleCreateWithoutArticleInput[] | SavedArticleUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutArticleInput | SavedArticleCreateOrConnectWithoutArticleInput[]
    createMany?: SavedArticleCreateManyArticleInputEnvelope
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutArticlesNestedInput = {
    create?: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutArticlesInput
    upsert?: UserUpsertWithoutArticlesInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutArticlesInput, UserUpdateWithoutArticlesInput>, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type ArticleCommentUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput> | ArticleCommentCreateWithoutArticleInput[] | ArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCommentCreateOrConnectWithoutArticleInput | ArticleCommentCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleCommentUpsertWithWhereUniqueWithoutArticleInput | ArticleCommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    set?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    disconnect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    delete?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    connect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    update?: ArticleCommentUpdateWithWhereUniqueWithoutArticleInput | ArticleCommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleCommentUpdateManyWithWhereWithoutArticleInput | ArticleCommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleCommentScalarWhereInput | ArticleCommentScalarWhereInput[]
  }

  export type SavedArticleUpdateManyWithoutArticleNestedInput = {
    create?: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput> | SavedArticleCreateWithoutArticleInput[] | SavedArticleUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutArticleInput | SavedArticleCreateOrConnectWithoutArticleInput[]
    upsert?: SavedArticleUpsertWithWhereUniqueWithoutArticleInput | SavedArticleUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: SavedArticleCreateManyArticleInputEnvelope
    set?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    disconnect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    delete?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    update?: SavedArticleUpdateWithWhereUniqueWithoutArticleInput | SavedArticleUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: SavedArticleUpdateManyWithWhereWithoutArticleInput | SavedArticleUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
  }

  export type ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput> | ArticleCommentCreateWithoutArticleInput[] | ArticleCommentUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: ArticleCommentCreateOrConnectWithoutArticleInput | ArticleCommentCreateOrConnectWithoutArticleInput[]
    upsert?: ArticleCommentUpsertWithWhereUniqueWithoutArticleInput | ArticleCommentUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: ArticleCommentCreateManyArticleInputEnvelope
    set?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    disconnect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    delete?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    connect?: ArticleCommentWhereUniqueInput | ArticleCommentWhereUniqueInput[]
    update?: ArticleCommentUpdateWithWhereUniqueWithoutArticleInput | ArticleCommentUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: ArticleCommentUpdateManyWithWhereWithoutArticleInput | ArticleCommentUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: ArticleCommentScalarWhereInput | ArticleCommentScalarWhereInput[]
  }

  export type SavedArticleUncheckedUpdateManyWithoutArticleNestedInput = {
    create?: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput> | SavedArticleCreateWithoutArticleInput[] | SavedArticleUncheckedCreateWithoutArticleInput[]
    connectOrCreate?: SavedArticleCreateOrConnectWithoutArticleInput | SavedArticleCreateOrConnectWithoutArticleInput[]
    upsert?: SavedArticleUpsertWithWhereUniqueWithoutArticleInput | SavedArticleUpsertWithWhereUniqueWithoutArticleInput[]
    createMany?: SavedArticleCreateManyArticleInputEnvelope
    set?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    disconnect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    delete?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    connect?: SavedArticleWhereUniqueInput | SavedArticleWhereUniqueInput[]
    update?: SavedArticleUpdateWithWhereUniqueWithoutArticleInput | SavedArticleUpdateWithWhereUniqueWithoutArticleInput[]
    updateMany?: SavedArticleUpdateManyWithWhereWithoutArticleInput | SavedArticleUpdateManyWithWhereWithoutArticleInput[]
    deleteMany?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
  }

  export type HealthArticleCreateNestedOneWithoutCommentsInput = {
    create?: XOR<HealthArticleCreateWithoutCommentsInput, HealthArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: HealthArticleCreateOrConnectWithoutCommentsInput
    connect?: HealthArticleWhereUniqueInput
  }

  export type HealthArticleUpdateOneRequiredWithoutCommentsNestedInput = {
    create?: XOR<HealthArticleCreateWithoutCommentsInput, HealthArticleUncheckedCreateWithoutCommentsInput>
    connectOrCreate?: HealthArticleCreateOrConnectWithoutCommentsInput
    upsert?: HealthArticleUpsertWithoutCommentsInput
    connect?: HealthArticleWhereUniqueInput
    update?: XOR<XOR<HealthArticleUpdateToOneWithWhereWithoutCommentsInput, HealthArticleUpdateWithoutCommentsInput>, HealthArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type UserCreateNestedOneWithoutSavedArticlesInput = {
    create?: XOR<UserCreateWithoutSavedArticlesInput, UserUncheckedCreateWithoutSavedArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedArticlesInput
    connect?: UserWhereUniqueInput
  }

  export type HealthArticleCreateNestedOneWithoutSavedByInput = {
    create?: XOR<HealthArticleCreateWithoutSavedByInput, HealthArticleUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: HealthArticleCreateOrConnectWithoutSavedByInput
    connect?: HealthArticleWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSavedArticlesNestedInput = {
    create?: XOR<UserCreateWithoutSavedArticlesInput, UserUncheckedCreateWithoutSavedArticlesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSavedArticlesInput
    upsert?: UserUpsertWithoutSavedArticlesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSavedArticlesInput, UserUpdateWithoutSavedArticlesInput>, UserUncheckedUpdateWithoutSavedArticlesInput>
  }

  export type HealthArticleUpdateOneRequiredWithoutSavedByNestedInput = {
    create?: XOR<HealthArticleCreateWithoutSavedByInput, HealthArticleUncheckedCreateWithoutSavedByInput>
    connectOrCreate?: HealthArticleCreateOrConnectWithoutSavedByInput
    upsert?: HealthArticleUpsertWithoutSavedByInput
    connect?: HealthArticleWhereUniqueInput
    update?: XOR<XOR<HealthArticleUpdateToOneWithWhereWithoutSavedByInput, HealthArticleUpdateWithoutSavedByInput>, HealthArticleUncheckedUpdateWithoutSavedByInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutSymptomSessionsInput = {
    create?: XOR<UserCreateWithoutSymptomSessionsInput, UserUncheckedCreateWithoutSymptomSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSymptomSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSymptomSessionsInput, UserUncheckedCreateWithoutSymptomSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSymptomSessionsInput
    upsert?: UserUpsertWithoutSymptomSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSymptomSessionsInput, UserUpdateWithoutSymptomSessionsInput>, UserUncheckedUpdateWithoutSymptomSessionsInput>
  }

  export type UserCreateNestedOneWithoutCoachSessionsInput = {
    create?: XOR<UserCreateWithoutCoachSessionsInput, UserUncheckedCreateWithoutCoachSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCoachSessionsNestedInput = {
    create?: XOR<UserCreateWithoutCoachSessionsInput, UserUncheckedCreateWithoutCoachSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCoachSessionsInput
    upsert?: UserUpsertWithoutCoachSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCoachSessionsInput, UserUpdateWithoutCoachSessionsInput>, UserUncheckedUpdateWithoutCoachSessionsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type HealthProfileCreateWithoutUserInput = {
    heightCm?: number | null
    weightKg?: number | null
    bmi?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    conditions?: string | null
    allergies?: string | null
    medications?: string | null
    vaccinationRecords?: string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileUncheckedCreateWithoutUserInput = {
    id?: number
    heightCm?: number | null
    weightKg?: number | null
    bmi?: number | null
    bloodPressureSystolic?: number | null
    bloodPressureDiastolic?: number | null
    heartRate?: number | null
    conditions?: string | null
    allergies?: string | null
    medications?: string | null
    vaccinationRecords?: string | null
    healthScore?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HealthProfileCreateOrConnectWithoutUserInput = {
    where: HealthProfileWhereUniqueInput
    create: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
  }

  export type DoctorCreateWithoutUserInput = {
    uuid?: string
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentCreateNestedManyWithoutDoctorProfileInput
    reviews?: DoctorReviewCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorProfileInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutUserInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
  }

  export type AppointmentCreateWithoutUserInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentCreateManyUserInputEnvelope = {
    data: AppointmentCreateManyUserInput | AppointmentCreateManyUserInput[]
  }

  export type AppointmentCreateWithoutDoctorInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentCreateManyDoctorInputEnvelope = {
    data: AppointmentCreateManyDoctorInput | AppointmentCreateManyDoctorInput[]
  }

  export type MedicineOrderCreateWithoutUserInput = {
    uuid?: string
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MedicineOrderItemCreateNestedManyWithoutOrderInput
  }

  export type MedicineOrderUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    items?: MedicineOrderItemUncheckedCreateNestedManyWithoutOrderInput
  }

  export type MedicineOrderCreateOrConnectWithoutUserInput = {
    where: MedicineOrderWhereUniqueInput
    create: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput>
  }

  export type MedicineOrderCreateManyUserInputEnvelope = {
    data: MedicineOrderCreateManyUserInput | MedicineOrderCreateManyUserInput[]
  }

  export type LabBookingCreateWithoutUserInput = {
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    tests?: LabBookingTestCreateNestedManyWithoutBookingInput
    report?: LabReportCreateNestedOneWithoutBookingInput
  }

  export type LabBookingUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    tests?: LabBookingTestUncheckedCreateNestedManyWithoutBookingInput
    report?: LabReportUncheckedCreateNestedOneWithoutBookingInput
  }

  export type LabBookingCreateOrConnectWithoutUserInput = {
    where: LabBookingWhereUniqueInput
    create: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput>
  }

  export type LabBookingCreateManyUserInputEnvelope = {
    data: LabBookingCreateManyUserInput | LabBookingCreateManyUserInput[]
  }

  export type HealthRecordCreateWithoutUserInput = {
    uuid?: string
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
  }

  export type HealthRecordUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
  }

  export type HealthRecordCreateOrConnectWithoutUserInput = {
    where: HealthRecordWhereUniqueInput
    create: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput>
  }

  export type HealthRecordCreateManyUserInputEnvelope = {
    data: HealthRecordCreateManyUserInput | HealthRecordCreateManyUserInput[]
  }

  export type ForumPostCreateWithoutUserInput = {
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentCreateNestedManyWithoutPostInput
    upvotesByUser?: PostUpvoteCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
    upvotesByUser?: PostUpvoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput>
  }

  export type ForumPostCreateManyUserInputEnvelope = {
    data: ForumPostCreateManyUserInput | ForumPostCreateManyUserInput[]
  }

  export type ForumCommentCreateWithoutUserInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    parentComment?: ForumCommentCreateNestedOneWithoutRepliesInput
    replies?: ForumCommentCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    postId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentCreateOrConnectWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentCreateManyUserInputEnvelope = {
    data: ForumCommentCreateManyUserInput | ForumCommentCreateManyUserInput[]
  }

  export type PostUpvoteCreateWithoutUserInput = {
    voteType: string
    post: ForumPostCreateNestedOneWithoutUpvotesByUserInput
  }

  export type PostUpvoteUncheckedCreateWithoutUserInput = {
    id?: number
    postId: number
    voteType: string
  }

  export type PostUpvoteCreateOrConnectWithoutUserInput = {
    where: PostUpvoteWhereUniqueInput
    create: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput>
  }

  export type PostUpvoteCreateManyUserInputEnvelope = {
    data: PostUpvoteCreateManyUserInput | PostUpvoteCreateManyUserInput[]
  }

  export type CommentUpvoteCreateWithoutUserInput = {
    voteType: string
    comment: ForumCommentCreateNestedOneWithoutUpvotesByUserInput
  }

  export type CommentUpvoteUncheckedCreateWithoutUserInput = {
    id?: number
    commentId: number
    voteType: string
  }

  export type CommentUpvoteCreateOrConnectWithoutUserInput = {
    where: CommentUpvoteWhereUniqueInput
    create: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput>
  }

  export type CommentUpvoteCreateManyUserInputEnvelope = {
    data: CommentUpvoteCreateManyUserInput | CommentUpvoteCreateManyUserInput[]
  }

  export type HealthArticleCreateWithoutAuthorInput = {
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ArticleCommentCreateNestedManyWithoutArticleInput
    savedBy?: SavedArticleCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleUncheckedCreateWithoutAuthorInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
    savedBy?: SavedArticleUncheckedCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleCreateOrConnectWithoutAuthorInput = {
    where: HealthArticleWhereUniqueInput
    create: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput>
  }

  export type HealthArticleCreateManyAuthorInputEnvelope = {
    data: HealthArticleCreateManyAuthorInput | HealthArticleCreateManyAuthorInput[]
  }

  export type SavedArticleCreateWithoutUserInput = {
    savedAt?: Date | string
    article: HealthArticleCreateNestedOneWithoutSavedByInput
  }

  export type SavedArticleUncheckedCreateWithoutUserInput = {
    id?: number
    articleId: number
    savedAt?: Date | string
  }

  export type SavedArticleCreateOrConnectWithoutUserInput = {
    where: SavedArticleWhereUniqueInput
    create: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput>
  }

  export type SavedArticleCreateManyUserInputEnvelope = {
    data: SavedArticleCreateManyUserInput | SavedArticleCreateManyUserInput[]
  }

  export type NotificationCreateWithoutUserInput = {
    uuid?: string
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
  }

  export type DoctorReviewCreateWithoutUserInput = {
    uuid?: string
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutReviewsInput
    appointment?: AppointmentCreateNestedOneWithoutReviewsInput
  }

  export type DoctorReviewUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    doctorId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewCreateOrConnectWithoutUserInput = {
    where: DoctorReviewWhereUniqueInput
    create: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput>
  }

  export type DoctorReviewCreateManyUserInputEnvelope = {
    data: DoctorReviewCreateManyUserInput | DoctorReviewCreateManyUserInput[]
  }

  export type SymptomCheckSessionCreateWithoutUserInput = {
    uuid?: string
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
  }

  export type SymptomCheckSessionUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
  }

  export type SymptomCheckSessionCreateOrConnectWithoutUserInput = {
    where: SymptomCheckSessionWhereUniqueInput
    create: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput>
  }

  export type SymptomCheckSessionCreateManyUserInputEnvelope = {
    data: SymptomCheckSessionCreateManyUserInput | SymptomCheckSessionCreateManyUserInput[]
  }

  export type CoachSessionCreateWithoutUserInput = {
    uuid?: string
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachSessionUncheckedCreateWithoutUserInput = {
    id?: number
    uuid?: string
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CoachSessionCreateOrConnectWithoutUserInput = {
    where: CoachSessionWhereUniqueInput
    create: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput>
  }

  export type CoachSessionCreateManyUserInputEnvelope = {
    data: CoachSessionCreateManyUserInput | CoachSessionCreateManyUserInput[]
  }

  export type HealthProfileUpsertWithoutUserInput = {
    update: XOR<HealthProfileUpdateWithoutUserInput, HealthProfileUncheckedUpdateWithoutUserInput>
    create: XOR<HealthProfileCreateWithoutUserInput, HealthProfileUncheckedCreateWithoutUserInput>
    where?: HealthProfileWhereInput
  }

  export type HealthProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: HealthProfileWhereInput
    data: XOR<HealthProfileUpdateWithoutUserInput, HealthProfileUncheckedUpdateWithoutUserInput>
  }

  export type HealthProfileUpdateWithoutUserInput = {
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthProfileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    heightCm?: NullableFloatFieldUpdateOperationsInput | number | null
    weightKg?: NullableFloatFieldUpdateOperationsInput | number | null
    bmi?: NullableFloatFieldUpdateOperationsInput | number | null
    bloodPressureSystolic?: NullableIntFieldUpdateOperationsInput | number | null
    bloodPressureDiastolic?: NullableIntFieldUpdateOperationsInput | number | null
    heartRate?: NullableIntFieldUpdateOperationsInput | number | null
    conditions?: NullableStringFieldUpdateOperationsInput | string | null
    allergies?: NullableStringFieldUpdateOperationsInput | string | null
    medications?: NullableStringFieldUpdateOperationsInput | string | null
    vaccinationRecords?: NullableStringFieldUpdateOperationsInput | string | null
    healthScore?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorUpsertWithoutUserInput = {
    update: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorCreateWithoutUserInput, DoctorUncheckedCreateWithoutUserInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutUserInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutUserInput, DoctorUncheckedUpdateWithoutUserInput>
  }

  export type DoctorUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUpdateManyWithoutDoctorProfileNestedInput
    reviews?: DoctorReviewUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorProfileNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
    create: XOR<AppointmentCreateWithoutUserInput, AppointmentUncheckedCreateWithoutUserInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutUserInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutUserInput, AppointmentUncheckedUpdateWithoutUserInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutUserInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutUserInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: IntFilter<"Appointment"> | number
    uuid?: StringFilter<"Appointment"> | string
    userId?: IntFilter<"Appointment"> | number
    doctorId?: IntFilter<"Appointment"> | number
    appointmentDate?: DateTimeFilter<"Appointment"> | Date | string
    consultationType?: StringFilter<"Appointment"> | string
    status?: StringFilter<"Appointment"> | string
    reason?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    meetingLink?: StringNullableFilter<"Appointment"> | string | null
    recordingUrl?: StringNullableFilter<"Appointment"> | string | null
    prescriptionId?: IntNullableFilter<"Appointment"> | number | null
    paymentId?: StringNullableFilter<"Appointment"> | string | null
    paymentStatus?: StringFilter<"Appointment"> | string
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
    create: XOR<AppointmentCreateWithoutDoctorInput, AppointmentUncheckedCreateWithoutDoctorInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorInput, AppointmentUncheckedUpdateWithoutDoctorInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorInput>
  }

  export type MedicineOrderUpsertWithWhereUniqueWithoutUserInput = {
    where: MedicineOrderWhereUniqueInput
    update: XOR<MedicineOrderUpdateWithoutUserInput, MedicineOrderUncheckedUpdateWithoutUserInput>
    create: XOR<MedicineOrderCreateWithoutUserInput, MedicineOrderUncheckedCreateWithoutUserInput>
  }

  export type MedicineOrderUpdateWithWhereUniqueWithoutUserInput = {
    where: MedicineOrderWhereUniqueInput
    data: XOR<MedicineOrderUpdateWithoutUserInput, MedicineOrderUncheckedUpdateWithoutUserInput>
  }

  export type MedicineOrderUpdateManyWithWhereWithoutUserInput = {
    where: MedicineOrderScalarWhereInput
    data: XOR<MedicineOrderUpdateManyMutationInput, MedicineOrderUncheckedUpdateManyWithoutUserInput>
  }

  export type MedicineOrderScalarWhereInput = {
    AND?: MedicineOrderScalarWhereInput | MedicineOrderScalarWhereInput[]
    OR?: MedicineOrderScalarWhereInput[]
    NOT?: MedicineOrderScalarWhereInput | MedicineOrderScalarWhereInput[]
    id?: IntFilter<"MedicineOrder"> | number
    uuid?: StringFilter<"MedicineOrder"> | string
    userId?: IntFilter<"MedicineOrder"> | number
    orderDate?: DateTimeFilter<"MedicineOrder"> | Date | string
    deliveryAddress?: StringFilter<"MedicineOrder"> | string
    status?: StringFilter<"MedicineOrder"> | string
    totalAmount?: FloatFilter<"MedicineOrder"> | number
    paymentMethod?: StringNullableFilter<"MedicineOrder"> | string | null
    paymentStatus?: StringFilter<"MedicineOrder"> | string
    prescriptionUrl?: StringNullableFilter<"MedicineOrder"> | string | null
    deliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    expectedDeliveryDate?: DateTimeNullableFilter<"MedicineOrder"> | Date | string | null
    trackingNumber?: StringNullableFilter<"MedicineOrder"> | string | null
    createdAt?: DateTimeFilter<"MedicineOrder"> | Date | string
    updatedAt?: DateTimeFilter<"MedicineOrder"> | Date | string
  }

  export type LabBookingUpsertWithWhereUniqueWithoutUserInput = {
    where: LabBookingWhereUniqueInput
    update: XOR<LabBookingUpdateWithoutUserInput, LabBookingUncheckedUpdateWithoutUserInput>
    create: XOR<LabBookingCreateWithoutUserInput, LabBookingUncheckedCreateWithoutUserInput>
  }

  export type LabBookingUpdateWithWhereUniqueWithoutUserInput = {
    where: LabBookingWhereUniqueInput
    data: XOR<LabBookingUpdateWithoutUserInput, LabBookingUncheckedUpdateWithoutUserInput>
  }

  export type LabBookingUpdateManyWithWhereWithoutUserInput = {
    where: LabBookingScalarWhereInput
    data: XOR<LabBookingUpdateManyMutationInput, LabBookingUncheckedUpdateManyWithoutUserInput>
  }

  export type LabBookingScalarWhereInput = {
    AND?: LabBookingScalarWhereInput | LabBookingScalarWhereInput[]
    OR?: LabBookingScalarWhereInput[]
    NOT?: LabBookingScalarWhereInput | LabBookingScalarWhereInput[]
    id?: IntFilter<"LabBooking"> | number
    uuid?: StringFilter<"LabBooking"> | string
    userId?: IntFilter<"LabBooking"> | number
    bookingDate?: DateTimeFilter<"LabBooking"> | Date | string
    collectionType?: StringFilter<"LabBooking"> | string
    address?: StringNullableFilter<"LabBooking"> | string | null
    status?: StringFilter<"LabBooking"> | string
    totalAmount?: FloatFilter<"LabBooking"> | number
    paymentStatus?: StringFilter<"LabBooking"> | string
    reportUrl?: StringNullableFilter<"LabBooking"> | string | null
    reportReadyDate?: DateTimeNullableFilter<"LabBooking"> | Date | string | null
    createdAt?: DateTimeFilter<"LabBooking"> | Date | string
  }

  export type HealthRecordUpsertWithWhereUniqueWithoutUserInput = {
    where: HealthRecordWhereUniqueInput
    update: XOR<HealthRecordUpdateWithoutUserInput, HealthRecordUncheckedUpdateWithoutUserInput>
    create: XOR<HealthRecordCreateWithoutUserInput, HealthRecordUncheckedCreateWithoutUserInput>
  }

  export type HealthRecordUpdateWithWhereUniqueWithoutUserInput = {
    where: HealthRecordWhereUniqueInput
    data: XOR<HealthRecordUpdateWithoutUserInput, HealthRecordUncheckedUpdateWithoutUserInput>
  }

  export type HealthRecordUpdateManyWithWhereWithoutUserInput = {
    where: HealthRecordScalarWhereInput
    data: XOR<HealthRecordUpdateManyMutationInput, HealthRecordUncheckedUpdateManyWithoutUserInput>
  }

  export type HealthRecordScalarWhereInput = {
    AND?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    OR?: HealthRecordScalarWhereInput[]
    NOT?: HealthRecordScalarWhereInput | HealthRecordScalarWhereInput[]
    id?: IntFilter<"HealthRecord"> | number
    uuid?: StringFilter<"HealthRecord"> | string
    userId?: IntFilter<"HealthRecord"> | number
    recordType?: StringFilter<"HealthRecord"> | string
    title?: StringFilter<"HealthRecord"> | string
    description?: StringNullableFilter<"HealthRecord"> | string | null
    fileUrl?: StringFilter<"HealthRecord"> | string
    fileName?: StringFilter<"HealthRecord"> | string
    fileType?: StringNullableFilter<"HealthRecord"> | string | null
    fileSize?: IntNullableFilter<"HealthRecord"> | number | null
    doctorId?: IntNullableFilter<"HealthRecord"> | number | null
    appointmentId?: IntNullableFilter<"HealthRecord"> | number | null
    documentDate?: DateTimeNullableFilter<"HealthRecord"> | Date | string | null
    isPublic?: BoolFilter<"HealthRecord"> | boolean
    sharedWith?: StringNullableFilter<"HealthRecord"> | string | null
    createdAt?: DateTimeFilter<"HealthRecord"> | Date | string
  }

  export type ForumPostUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    update: XOR<ForumPostUpdateWithoutUserInput, ForumPostUncheckedUpdateWithoutUserInput>
    create: XOR<ForumPostCreateWithoutUserInput, ForumPostUncheckedCreateWithoutUserInput>
  }

  export type ForumPostUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumPostWhereUniqueInput
    data: XOR<ForumPostUpdateWithoutUserInput, ForumPostUncheckedUpdateWithoutUserInput>
  }

  export type ForumPostUpdateManyWithWhereWithoutUserInput = {
    where: ForumPostScalarWhereInput
    data: XOR<ForumPostUpdateManyMutationInput, ForumPostUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumPostScalarWhereInput = {
    AND?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    OR?: ForumPostScalarWhereInput[]
    NOT?: ForumPostScalarWhereInput | ForumPostScalarWhereInput[]
    id?: IntFilter<"ForumPost"> | number
    uuid?: StringFilter<"ForumPost"> | string
    userId?: IntFilter<"ForumPost"> | number
    title?: StringFilter<"ForumPost"> | string
    content?: StringFilter<"ForumPost"> | string
    category?: StringFilter<"ForumPost"> | string
    status?: StringFilter<"ForumPost"> | string
    upvotes?: IntFilter<"ForumPost"> | number
    downvotes?: IntFilter<"ForumPost"> | number
    views?: IntFilter<"ForumPost"> | number
    commentsCount?: IntFilter<"ForumPost"> | number
    pinned?: BoolFilter<"ForumPost"> | boolean
    verifiedDoctor?: BoolFilter<"ForumPost"> | boolean
    createdAt?: DateTimeFilter<"ForumPost"> | Date | string
    updatedAt?: DateTimeFilter<"ForumPost"> | Date | string
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutUserInput, ForumCommentUncheckedUpdateWithoutUserInput>
    create: XOR<ForumCommentCreateWithoutUserInput, ForumCommentUncheckedCreateWithoutUserInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutUserInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutUserInput, ForumCommentUncheckedUpdateWithoutUserInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutUserInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutUserInput>
  }

  export type ForumCommentScalarWhereInput = {
    AND?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    OR?: ForumCommentScalarWhereInput[]
    NOT?: ForumCommentScalarWhereInput | ForumCommentScalarWhereInput[]
    id?: IntFilter<"ForumComment"> | number
    uuid?: StringFilter<"ForumComment"> | string
    postId?: IntFilter<"ForumComment"> | number
    userId?: IntFilter<"ForumComment"> | number
    parentCommentId?: IntNullableFilter<"ForumComment"> | number | null
    content?: StringFilter<"ForumComment"> | string
    upvotes?: IntFilter<"ForumComment"> | number
    helpfulCount?: IntFilter<"ForumComment"> | number
    verifiedDoctor?: BoolFilter<"ForumComment"> | boolean
    createdAt?: DateTimeFilter<"ForumComment"> | Date | string
    updatedAt?: DateTimeFilter<"ForumComment"> | Date | string
  }

  export type PostUpvoteUpsertWithWhereUniqueWithoutUserInput = {
    where: PostUpvoteWhereUniqueInput
    update: XOR<PostUpvoteUpdateWithoutUserInput, PostUpvoteUncheckedUpdateWithoutUserInput>
    create: XOR<PostUpvoteCreateWithoutUserInput, PostUpvoteUncheckedCreateWithoutUserInput>
  }

  export type PostUpvoteUpdateWithWhereUniqueWithoutUserInput = {
    where: PostUpvoteWhereUniqueInput
    data: XOR<PostUpvoteUpdateWithoutUserInput, PostUpvoteUncheckedUpdateWithoutUserInput>
  }

  export type PostUpvoteUpdateManyWithWhereWithoutUserInput = {
    where: PostUpvoteScalarWhereInput
    data: XOR<PostUpvoteUpdateManyMutationInput, PostUpvoteUncheckedUpdateManyWithoutUserInput>
  }

  export type PostUpvoteScalarWhereInput = {
    AND?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
    OR?: PostUpvoteScalarWhereInput[]
    NOT?: PostUpvoteScalarWhereInput | PostUpvoteScalarWhereInput[]
    id?: IntFilter<"PostUpvote"> | number
    postId?: IntFilter<"PostUpvote"> | number
    userId?: IntFilter<"PostUpvote"> | number
    voteType?: StringFilter<"PostUpvote"> | string
  }

  export type CommentUpvoteUpsertWithWhereUniqueWithoutUserInput = {
    where: CommentUpvoteWhereUniqueInput
    update: XOR<CommentUpvoteUpdateWithoutUserInput, CommentUpvoteUncheckedUpdateWithoutUserInput>
    create: XOR<CommentUpvoteCreateWithoutUserInput, CommentUpvoteUncheckedCreateWithoutUserInput>
  }

  export type CommentUpvoteUpdateWithWhereUniqueWithoutUserInput = {
    where: CommentUpvoteWhereUniqueInput
    data: XOR<CommentUpvoteUpdateWithoutUserInput, CommentUpvoteUncheckedUpdateWithoutUserInput>
  }

  export type CommentUpvoteUpdateManyWithWhereWithoutUserInput = {
    where: CommentUpvoteScalarWhereInput
    data: XOR<CommentUpvoteUpdateManyMutationInput, CommentUpvoteUncheckedUpdateManyWithoutUserInput>
  }

  export type CommentUpvoteScalarWhereInput = {
    AND?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
    OR?: CommentUpvoteScalarWhereInput[]
    NOT?: CommentUpvoteScalarWhereInput | CommentUpvoteScalarWhereInput[]
    id?: IntFilter<"CommentUpvote"> | number
    commentId?: IntFilter<"CommentUpvote"> | number
    userId?: IntFilter<"CommentUpvote"> | number
    voteType?: StringFilter<"CommentUpvote"> | string
  }

  export type HealthArticleUpsertWithWhereUniqueWithoutAuthorInput = {
    where: HealthArticleWhereUniqueInput
    update: XOR<HealthArticleUpdateWithoutAuthorInput, HealthArticleUncheckedUpdateWithoutAuthorInput>
    create: XOR<HealthArticleCreateWithoutAuthorInput, HealthArticleUncheckedCreateWithoutAuthorInput>
  }

  export type HealthArticleUpdateWithWhereUniqueWithoutAuthorInput = {
    where: HealthArticleWhereUniqueInput
    data: XOR<HealthArticleUpdateWithoutAuthorInput, HealthArticleUncheckedUpdateWithoutAuthorInput>
  }

  export type HealthArticleUpdateManyWithWhereWithoutAuthorInput = {
    where: HealthArticleScalarWhereInput
    data: XOR<HealthArticleUpdateManyMutationInput, HealthArticleUncheckedUpdateManyWithoutAuthorInput>
  }

  export type HealthArticleScalarWhereInput = {
    AND?: HealthArticleScalarWhereInput | HealthArticleScalarWhereInput[]
    OR?: HealthArticleScalarWhereInput[]
    NOT?: HealthArticleScalarWhereInput | HealthArticleScalarWhereInput[]
    id?: IntFilter<"HealthArticle"> | number
    uuid?: StringFilter<"HealthArticle"> | string
    title?: StringFilter<"HealthArticle"> | string
    slug?: StringFilter<"HealthArticle"> | string
    content?: StringFilter<"HealthArticle"> | string
    category?: StringFilter<"HealthArticle"> | string
    authorId?: IntNullableFilter<"HealthArticle"> | number | null
    featuredImageUrl?: StringNullableFilter<"HealthArticle"> | string | null
    status?: StringFilter<"HealthArticle"> | string
    views?: IntFilter<"HealthArticle"> | number
    publishedAt?: DateTimeNullableFilter<"HealthArticle"> | Date | string | null
    createdAt?: DateTimeFilter<"HealthArticle"> | Date | string
    updatedAt?: DateTimeFilter<"HealthArticle"> | Date | string
  }

  export type SavedArticleUpsertWithWhereUniqueWithoutUserInput = {
    where: SavedArticleWhereUniqueInput
    update: XOR<SavedArticleUpdateWithoutUserInput, SavedArticleUncheckedUpdateWithoutUserInput>
    create: XOR<SavedArticleCreateWithoutUserInput, SavedArticleUncheckedCreateWithoutUserInput>
  }

  export type SavedArticleUpdateWithWhereUniqueWithoutUserInput = {
    where: SavedArticleWhereUniqueInput
    data: XOR<SavedArticleUpdateWithoutUserInput, SavedArticleUncheckedUpdateWithoutUserInput>
  }

  export type SavedArticleUpdateManyWithWhereWithoutUserInput = {
    where: SavedArticleScalarWhereInput
    data: XOR<SavedArticleUpdateManyMutationInput, SavedArticleUncheckedUpdateManyWithoutUserInput>
  }

  export type SavedArticleScalarWhereInput = {
    AND?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
    OR?: SavedArticleScalarWhereInput[]
    NOT?: SavedArticleScalarWhereInput | SavedArticleScalarWhereInput[]
    id?: IntFilter<"SavedArticle"> | number
    userId?: IntFilter<"SavedArticle"> | number
    articleId?: IntFilter<"SavedArticle"> | number
    savedAt?: DateTimeFilter<"SavedArticle"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    uuid?: StringFilter<"Notification"> | string
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    data?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    actionUrl?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type DoctorReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: DoctorReviewWhereUniqueInput
    update: XOR<DoctorReviewUpdateWithoutUserInput, DoctorReviewUncheckedUpdateWithoutUserInput>
    create: XOR<DoctorReviewCreateWithoutUserInput, DoctorReviewUncheckedCreateWithoutUserInput>
  }

  export type DoctorReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: DoctorReviewWhereUniqueInput
    data: XOR<DoctorReviewUpdateWithoutUserInput, DoctorReviewUncheckedUpdateWithoutUserInput>
  }

  export type DoctorReviewUpdateManyWithWhereWithoutUserInput = {
    where: DoctorReviewScalarWhereInput
    data: XOR<DoctorReviewUpdateManyMutationInput, DoctorReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type DoctorReviewScalarWhereInput = {
    AND?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
    OR?: DoctorReviewScalarWhereInput[]
    NOT?: DoctorReviewScalarWhereInput | DoctorReviewScalarWhereInput[]
    id?: IntFilter<"DoctorReview"> | number
    uuid?: StringFilter<"DoctorReview"> | string
    doctorId?: IntFilter<"DoctorReview"> | number
    userId?: IntFilter<"DoctorReview"> | number
    appointmentId?: IntNullableFilter<"DoctorReview"> | number | null
    rating?: IntFilter<"DoctorReview"> | number
    review?: StringNullableFilter<"DoctorReview"> | string | null
    verified?: BoolFilter<"DoctorReview"> | boolean
    helpfulCount?: IntFilter<"DoctorReview"> | number
    createdAt?: DateTimeFilter<"DoctorReview"> | Date | string
  }

  export type SymptomCheckSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SymptomCheckSessionWhereUniqueInput
    update: XOR<SymptomCheckSessionUpdateWithoutUserInput, SymptomCheckSessionUncheckedUpdateWithoutUserInput>
    create: XOR<SymptomCheckSessionCreateWithoutUserInput, SymptomCheckSessionUncheckedCreateWithoutUserInput>
  }

  export type SymptomCheckSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SymptomCheckSessionWhereUniqueInput
    data: XOR<SymptomCheckSessionUpdateWithoutUserInput, SymptomCheckSessionUncheckedUpdateWithoutUserInput>
  }

  export type SymptomCheckSessionUpdateManyWithWhereWithoutUserInput = {
    where: SymptomCheckSessionScalarWhereInput
    data: XOR<SymptomCheckSessionUpdateManyMutationInput, SymptomCheckSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SymptomCheckSessionScalarWhereInput = {
    AND?: SymptomCheckSessionScalarWhereInput | SymptomCheckSessionScalarWhereInput[]
    OR?: SymptomCheckSessionScalarWhereInput[]
    NOT?: SymptomCheckSessionScalarWhereInput | SymptomCheckSessionScalarWhereInput[]
    id?: IntFilter<"SymptomCheckSession"> | number
    uuid?: StringFilter<"SymptomCheckSession"> | string
    userId?: IntFilter<"SymptomCheckSession"> | number
    conversation?: StringFilter<"SymptomCheckSession"> | string
    result?: StringNullableFilter<"SymptomCheckSession"> | string | null
    riskLevel?: StringNullableFilter<"SymptomCheckSession"> | string | null
    createdAt?: DateTimeFilter<"SymptomCheckSession"> | Date | string
  }

  export type CoachSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: CoachSessionWhereUniqueInput
    update: XOR<CoachSessionUpdateWithoutUserInput, CoachSessionUncheckedUpdateWithoutUserInput>
    create: XOR<CoachSessionCreateWithoutUserInput, CoachSessionUncheckedCreateWithoutUserInput>
  }

  export type CoachSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: CoachSessionWhereUniqueInput
    data: XOR<CoachSessionUpdateWithoutUserInput, CoachSessionUncheckedUpdateWithoutUserInput>
  }

  export type CoachSessionUpdateManyWithWhereWithoutUserInput = {
    where: CoachSessionScalarWhereInput
    data: XOR<CoachSessionUpdateManyMutationInput, CoachSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type CoachSessionScalarWhereInput = {
    AND?: CoachSessionScalarWhereInput | CoachSessionScalarWhereInput[]
    OR?: CoachSessionScalarWhereInput[]
    NOT?: CoachSessionScalarWhereInput | CoachSessionScalarWhereInput[]
    id?: IntFilter<"CoachSession"> | number
    uuid?: StringFilter<"CoachSession"> | string
    userId?: IntFilter<"CoachSession"> | number
    conversation?: StringFilter<"CoachSession"> | string
    savedPlan?: StringNullableFilter<"CoachSession"> | string | null
    createdAt?: DateTimeFilter<"CoachSession"> | Date | string
    updatedAt?: DateTimeFilter<"CoachSession"> | Date | string
  }

  export type UserCreateWithoutHealthProfileInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHealthProfileInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHealthProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHealthProfileInput, UserUncheckedCreateWithoutHealthProfileInput>
  }

  export type UserUpsertWithoutHealthProfileInput = {
    update: XOR<UserUpdateWithoutHealthProfileInput, UserUncheckedUpdateWithoutHealthProfileInput>
    create: XOR<UserCreateWithoutHealthProfileInput, UserUncheckedCreateWithoutHealthProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHealthProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHealthProfileInput, UserUncheckedUpdateWithoutHealthProfileInput>
  }

  export type UserUpdateWithoutHealthProfileInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHealthProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutDoctorProfileInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDoctorProfileInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDoctorProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDoctorProfileInput, UserUncheckedCreateWithoutDoctorProfileInput>
  }

  export type AppointmentCreateWithoutDoctorProfileInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutDoctorProfileInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutDoctorProfileInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput>
  }

  export type AppointmentCreateManyDoctorProfileInputEnvelope = {
    data: AppointmentCreateManyDoctorProfileInput | AppointmentCreateManyDoctorProfileInput[]
  }

  export type DoctorReviewCreateWithoutDoctorInput = {
    uuid?: string
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewsInput
    appointment?: AppointmentCreateNestedOneWithoutReviewsInput
  }

  export type DoctorReviewUncheckedCreateWithoutDoctorInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewCreateOrConnectWithoutDoctorInput = {
    where: DoctorReviewWhereUniqueInput
    create: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorReviewCreateManyDoctorInputEnvelope = {
    data: DoctorReviewCreateManyDoctorInput | DoctorReviewCreateManyDoctorInput[]
  }

  export type UserUpsertWithoutDoctorProfileInput = {
    update: XOR<UserUpdateWithoutDoctorProfileInput, UserUncheckedUpdateWithoutDoctorProfileInput>
    create: XOR<UserCreateWithoutDoctorProfileInput, UserUncheckedCreateWithoutDoctorProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDoctorProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDoctorProfileInput, UserUncheckedUpdateWithoutDoctorProfileInput>
  }

  export type UserUpdateWithoutDoctorProfileInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDoctorProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithWhereUniqueWithoutDoctorProfileInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutDoctorProfileInput, AppointmentUncheckedUpdateWithoutDoctorProfileInput>
    create: XOR<AppointmentCreateWithoutDoctorProfileInput, AppointmentUncheckedCreateWithoutDoctorProfileInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutDoctorProfileInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutDoctorProfileInput, AppointmentUncheckedUpdateWithoutDoctorProfileInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutDoctorProfileInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutDoctorProfileInput>
  }

  export type DoctorReviewUpsertWithWhereUniqueWithoutDoctorInput = {
    where: DoctorReviewWhereUniqueInput
    update: XOR<DoctorReviewUpdateWithoutDoctorInput, DoctorReviewUncheckedUpdateWithoutDoctorInput>
    create: XOR<DoctorReviewCreateWithoutDoctorInput, DoctorReviewUncheckedCreateWithoutDoctorInput>
  }

  export type DoctorReviewUpdateWithWhereUniqueWithoutDoctorInput = {
    where: DoctorReviewWhereUniqueInput
    data: XOR<DoctorReviewUpdateWithoutDoctorInput, DoctorReviewUncheckedUpdateWithoutDoctorInput>
  }

  export type DoctorReviewUpdateManyWithWhereWithoutDoctorInput = {
    where: DoctorReviewScalarWhereInput
    data: XOR<DoctorReviewUpdateManyMutationInput, DoctorReviewUncheckedUpdateManyWithoutDoctorInput>
  }

  export type DoctorCreateWithoutReviewsInput = {
    uuid?: string
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorProfileInput
    appointments?: AppointmentCreateNestedManyWithoutDoctorProfileInput
  }

  export type DoctorUncheckedCreateWithoutReviewsInput = {
    id?: number
    uuid?: string
    userId: number
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutDoctorProfileInput
  }

  export type DoctorCreateOrConnectWithoutReviewsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutReviewsInput, DoctorUncheckedCreateWithoutReviewsInput>
  }

  export type UserCreateWithoutReviewsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type AppointmentCreateWithoutReviewsInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutReviewsInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutReviewsInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
  }

  export type DoctorUpsertWithoutReviewsInput = {
    update: XOR<DoctorUpdateWithoutReviewsInput, DoctorUncheckedUpdateWithoutReviewsInput>
    create: XOR<DoctorCreateWithoutReviewsInput, DoctorUncheckedCreateWithoutReviewsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutReviewsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutReviewsInput, DoctorUncheckedUpdateWithoutReviewsInput>
  }

  export type DoctorUpdateWithoutReviewsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorProfileNestedInput
    appointments?: AppointmentUpdateManyWithoutDoctorProfileNestedInput
  }

  export type DoctorUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutDoctorProfileNestedInput
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentUpsertWithoutReviewsInput = {
    update: XOR<AppointmentUpdateWithoutReviewsInput, AppointmentUncheckedUpdateWithoutReviewsInput>
    create: XOR<AppointmentCreateWithoutReviewsInput, AppointmentUncheckedCreateWithoutReviewsInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutReviewsInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutReviewsInput, AppointmentUncheckedUpdateWithoutReviewsInput>
  }

  export type AppointmentUpdateWithoutReviewsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutReviewsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
  }

  export type UserCreateWithoutAppointmentsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
  }

  export type UserCreateWithoutAppointmentsAsDoctorInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppointmentsAsDoctorInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppointmentsAsDoctorInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppointmentsAsDoctorInput, UserUncheckedCreateWithoutAppointmentsAsDoctorInput>
  }

  export type DoctorCreateWithoutAppointmentsInput = {
    uuid?: string
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDoctorProfileInput
    reviews?: DoctorReviewCreateNestedManyWithoutDoctorInput
  }

  export type DoctorUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    uuid?: string
    userId: number
    specialty: string
    qualifications?: string | null
    experienceYears?: number | null
    licenseNumber?: string | null
    clinicName?: string | null
    clinicAddress?: string | null
    latitude?: number | null
    longitude?: number | null
    consultationFee?: number
    averageRating?: number
    totalRatings?: number
    availability?: string | null
    isVerified?: boolean
    verificationDocuments?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutDoctorInput
  }

  export type DoctorCreateOrConnectWithoutAppointmentsInput = {
    where: DoctorWhereUniqueInput
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
  }

  export type PrescriptionCreateWithoutAppointmentsInput = {
    uuid?: string
    appointmentId?: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions?: string | null
    validityDays?: number
    issuedAt?: Date | string
    createdAt?: Date | string
  }

  export type PrescriptionUncheckedCreateWithoutAppointmentsInput = {
    id?: number
    uuid?: string
    appointmentId?: number | null
    doctorId: number
    userId: number
    medicines: string
    instructions?: string | null
    validityDays?: number
    issuedAt?: Date | string
    createdAt?: Date | string
  }

  export type PrescriptionCreateOrConnectWithoutAppointmentsInput = {
    where: PrescriptionWhereUniqueInput
    create: XOR<PrescriptionCreateWithoutAppointmentsInput, PrescriptionUncheckedCreateWithoutAppointmentsInput>
  }

  export type CallSessionCreateWithoutAppointmentInput = {
    uuid?: string
    roomId?: string | null
    provider?: string | null
    token?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    createdAt?: Date | string
  }

  export type CallSessionUncheckedCreateWithoutAppointmentInput = {
    id?: number
    uuid?: string
    roomId?: string | null
    provider?: string | null
    token?: string | null
    startedAt?: Date | string | null
    endedAt?: Date | string | null
    recordingUrl?: string | null
    createdAt?: Date | string
  }

  export type CallSessionCreateOrConnectWithoutAppointmentInput = {
    where: CallSessionWhereUniqueInput
    create: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
  }

  export type DoctorReviewCreateWithoutAppointmentInput = {
    uuid?: string
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    doctor: DoctorCreateNestedOneWithoutReviewsInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type DoctorReviewUncheckedCreateWithoutAppointmentInput = {
    id?: number
    uuid?: string
    doctorId: number
    userId: number
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewCreateOrConnectWithoutAppointmentInput = {
    where: DoctorReviewWhereUniqueInput
    create: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput>
  }

  export type DoctorReviewCreateManyAppointmentInputEnvelope = {
    data: DoctorReviewCreateManyAppointmentInput | DoctorReviewCreateManyAppointmentInput[]
  }

  export type UserUpsertWithoutAppointmentsInput = {
    update: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<UserCreateWithoutAppointmentsInput, UserUncheckedCreateWithoutAppointmentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsInput, UserUncheckedUpdateWithoutAppointmentsInput>
  }

  export type UserUpdateWithoutAppointmentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUpsertWithoutAppointmentsAsDoctorInput = {
    update: XOR<UserUpdateWithoutAppointmentsAsDoctorInput, UserUncheckedUpdateWithoutAppointmentsAsDoctorInput>
    create: XOR<UserCreateWithoutAppointmentsAsDoctorInput, UserUncheckedCreateWithoutAppointmentsAsDoctorInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppointmentsAsDoctorInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppointmentsAsDoctorInput, UserUncheckedUpdateWithoutAppointmentsAsDoctorInput>
  }

  export type UserUpdateWithoutAppointmentsAsDoctorInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppointmentsAsDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type DoctorUpsertWithoutAppointmentsInput = {
    update: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<DoctorCreateWithoutAppointmentsInput, DoctorUncheckedCreateWithoutAppointmentsInput>
    where?: DoctorWhereInput
  }

  export type DoctorUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: DoctorWhereInput
    data: XOR<DoctorUpdateWithoutAppointmentsInput, DoctorUncheckedUpdateWithoutAppointmentsInput>
  }

  export type DoctorUpdateWithoutAppointmentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDoctorProfileNestedInput
    reviews?: DoctorReviewUpdateManyWithoutDoctorNestedInput
  }

  export type DoctorUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    specialty?: StringFieldUpdateOperationsInput | string
    qualifications?: NullableStringFieldUpdateOperationsInput | string | null
    experienceYears?: NullableIntFieldUpdateOperationsInput | number | null
    licenseNumber?: NullableStringFieldUpdateOperationsInput | string | null
    clinicName?: NullableStringFieldUpdateOperationsInput | string | null
    clinicAddress?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableFloatFieldUpdateOperationsInput | number | null
    longitude?: NullableFloatFieldUpdateOperationsInput | number | null
    consultationFee?: FloatFieldUpdateOperationsInput | number
    averageRating?: FloatFieldUpdateOperationsInput | number
    totalRatings?: IntFieldUpdateOperationsInput | number
    availability?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verificationDocuments?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: DoctorReviewUncheckedUpdateManyWithoutDoctorNestedInput
  }

  export type PrescriptionUpsertWithoutAppointmentsInput = {
    update: XOR<PrescriptionUpdateWithoutAppointmentsInput, PrescriptionUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PrescriptionCreateWithoutAppointmentsInput, PrescriptionUncheckedCreateWithoutAppointmentsInput>
    where?: PrescriptionWhereInput
  }

  export type PrescriptionUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PrescriptionWhereInput
    data: XOR<PrescriptionUpdateWithoutAppointmentsInput, PrescriptionUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PrescriptionUpdateWithoutAppointmentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrescriptionUncheckedUpdateWithoutAppointmentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    medicines?: StringFieldUpdateOperationsInput | string
    instructions?: NullableStringFieldUpdateOperationsInput | string | null
    validityDays?: IntFieldUpdateOperationsInput | number
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUpsertWithoutAppointmentInput = {
    update: XOR<CallSessionUpdateWithoutAppointmentInput, CallSessionUncheckedUpdateWithoutAppointmentInput>
    create: XOR<CallSessionCreateWithoutAppointmentInput, CallSessionUncheckedCreateWithoutAppointmentInput>
    where?: CallSessionWhereInput
  }

  export type CallSessionUpdateToOneWithWhereWithoutAppointmentInput = {
    where?: CallSessionWhereInput
    data: XOR<CallSessionUpdateWithoutAppointmentInput, CallSessionUncheckedUpdateWithoutAppointmentInput>
  }

  export type CallSessionUpdateWithoutAppointmentInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CallSessionUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    roomId?: NullableStringFieldUpdateOperationsInput | string | null
    provider?: NullableStringFieldUpdateOperationsInput | string | null
    token?: NullableStringFieldUpdateOperationsInput | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    endedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUpsertWithWhereUniqueWithoutAppointmentInput = {
    where: DoctorReviewWhereUniqueInput
    update: XOR<DoctorReviewUpdateWithoutAppointmentInput, DoctorReviewUncheckedUpdateWithoutAppointmentInput>
    create: XOR<DoctorReviewCreateWithoutAppointmentInput, DoctorReviewUncheckedCreateWithoutAppointmentInput>
  }

  export type DoctorReviewUpdateWithWhereUniqueWithoutAppointmentInput = {
    where: DoctorReviewWhereUniqueInput
    data: XOR<DoctorReviewUpdateWithoutAppointmentInput, DoctorReviewUncheckedUpdateWithoutAppointmentInput>
  }

  export type DoctorReviewUpdateManyWithWhereWithoutAppointmentInput = {
    where: DoctorReviewScalarWhereInput
    data: XOR<DoctorReviewUpdateManyMutationInput, DoctorReviewUncheckedUpdateManyWithoutAppointmentInput>
  }

  export type AppointmentCreateWithoutPrescriptionInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    callSession?: CallSessionCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutPrescriptionInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    callSession?: CallSessionUncheckedCreateNestedOneWithoutAppointmentInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutPrescriptionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput>
  }

  export type AppointmentCreateManyPrescriptionInputEnvelope = {
    data: AppointmentCreateManyPrescriptionInput | AppointmentCreateManyPrescriptionInput[]
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPrescriptionInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPrescriptionInput, AppointmentUncheckedUpdateWithoutPrescriptionInput>
    create: XOR<AppointmentCreateWithoutPrescriptionInput, AppointmentUncheckedCreateWithoutPrescriptionInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPrescriptionInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPrescriptionInput, AppointmentUncheckedUpdateWithoutPrescriptionInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPrescriptionInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPrescriptionInput>
  }

  export type AppointmentCreateWithoutCallSessionInput = {
    uuid?: string
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAppointmentsInput
    doctor: UserCreateNestedOneWithoutAppointmentsAsDoctorInput
    doctorProfile: DoctorCreateNestedOneWithoutAppointmentsInput
    prescription?: PrescriptionCreateNestedOneWithoutAppointmentsInput
    reviews?: DoctorReviewCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentUncheckedCreateWithoutCallSessionInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutAppointmentInput
  }

  export type AppointmentCreateOrConnectWithoutCallSessionInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutCallSessionInput, AppointmentUncheckedCreateWithoutCallSessionInput>
  }

  export type AppointmentUpsertWithoutCallSessionInput = {
    update: XOR<AppointmentUpdateWithoutCallSessionInput, AppointmentUncheckedUpdateWithoutCallSessionInput>
    create: XOR<AppointmentCreateWithoutCallSessionInput, AppointmentUncheckedCreateWithoutCallSessionInput>
    where?: AppointmentWhereInput
  }

  export type AppointmentUpdateToOneWithWhereWithoutCallSessionInput = {
    where?: AppointmentWhereInput
    data: XOR<AppointmentUpdateWithoutCallSessionInput, AppointmentUncheckedUpdateWithoutCallSessionInput>
  }

  export type AppointmentUpdateWithoutCallSessionInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutCallSessionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type MedicineOrderItemCreateWithoutMedicineInput = {
    quantity: number
    price: number
    order: MedicineOrderCreateNestedOneWithoutItemsInput
  }

  export type MedicineOrderItemUncheckedCreateWithoutMedicineInput = {
    id?: number
    orderId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemCreateOrConnectWithoutMedicineInput = {
    where: MedicineOrderItemWhereUniqueInput
    create: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineOrderItemCreateManyMedicineInputEnvelope = {
    data: MedicineOrderItemCreateManyMedicineInput | MedicineOrderItemCreateManyMedicineInput[]
  }

  export type MedicineOrderItemUpsertWithWhereUniqueWithoutMedicineInput = {
    where: MedicineOrderItemWhereUniqueInput
    update: XOR<MedicineOrderItemUpdateWithoutMedicineInput, MedicineOrderItemUncheckedUpdateWithoutMedicineInput>
    create: XOR<MedicineOrderItemCreateWithoutMedicineInput, MedicineOrderItemUncheckedCreateWithoutMedicineInput>
  }

  export type MedicineOrderItemUpdateWithWhereUniqueWithoutMedicineInput = {
    where: MedicineOrderItemWhereUniqueInput
    data: XOR<MedicineOrderItemUpdateWithoutMedicineInput, MedicineOrderItemUncheckedUpdateWithoutMedicineInput>
  }

  export type MedicineOrderItemUpdateManyWithWhereWithoutMedicineInput = {
    where: MedicineOrderItemScalarWhereInput
    data: XOR<MedicineOrderItemUpdateManyMutationInput, MedicineOrderItemUncheckedUpdateManyWithoutMedicineInput>
  }

  export type MedicineOrderItemScalarWhereInput = {
    AND?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
    OR?: MedicineOrderItemScalarWhereInput[]
    NOT?: MedicineOrderItemScalarWhereInput | MedicineOrderItemScalarWhereInput[]
    id?: IntFilter<"MedicineOrderItem"> | number
    orderId?: IntFilter<"MedicineOrderItem"> | number
    medicineId?: IntFilter<"MedicineOrderItem"> | number
    quantity?: IntFilter<"MedicineOrderItem"> | number
    price?: FloatFilter<"MedicineOrderItem"> | number
  }

  export type UserCreateWithoutMedicineOrdersInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMedicineOrdersInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMedicineOrdersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMedicineOrdersInput, UserUncheckedCreateWithoutMedicineOrdersInput>
  }

  export type MedicineOrderItemCreateWithoutOrderInput = {
    quantity: number
    price: number
    medicine: MedicineCreateNestedOneWithoutOrderItemsInput
  }

  export type MedicineOrderItemUncheckedCreateWithoutOrderInput = {
    id?: number
    medicineId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemCreateOrConnectWithoutOrderInput = {
    where: MedicineOrderItemWhereUniqueInput
    create: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type MedicineOrderItemCreateManyOrderInputEnvelope = {
    data: MedicineOrderItemCreateManyOrderInput | MedicineOrderItemCreateManyOrderInput[]
  }

  export type UserUpsertWithoutMedicineOrdersInput = {
    update: XOR<UserUpdateWithoutMedicineOrdersInput, UserUncheckedUpdateWithoutMedicineOrdersInput>
    create: XOR<UserCreateWithoutMedicineOrdersInput, UserUncheckedCreateWithoutMedicineOrdersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMedicineOrdersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMedicineOrdersInput, UserUncheckedUpdateWithoutMedicineOrdersInput>
  }

  export type UserUpdateWithoutMedicineOrdersInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMedicineOrdersInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MedicineOrderItemUpsertWithWhereUniqueWithoutOrderInput = {
    where: MedicineOrderItemWhereUniqueInput
    update: XOR<MedicineOrderItemUpdateWithoutOrderInput, MedicineOrderItemUncheckedUpdateWithoutOrderInput>
    create: XOR<MedicineOrderItemCreateWithoutOrderInput, MedicineOrderItemUncheckedCreateWithoutOrderInput>
  }

  export type MedicineOrderItemUpdateWithWhereUniqueWithoutOrderInput = {
    where: MedicineOrderItemWhereUniqueInput
    data: XOR<MedicineOrderItemUpdateWithoutOrderInput, MedicineOrderItemUncheckedUpdateWithoutOrderInput>
  }

  export type MedicineOrderItemUpdateManyWithWhereWithoutOrderInput = {
    where: MedicineOrderItemScalarWhereInput
    data: XOR<MedicineOrderItemUpdateManyMutationInput, MedicineOrderItemUncheckedUpdateManyWithoutOrderInput>
  }

  export type MedicineOrderCreateWithoutItemsInput = {
    uuid?: string
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutMedicineOrdersInput
  }

  export type MedicineOrderUncheckedCreateWithoutItemsInput = {
    id?: number
    uuid?: string
    userId: number
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineOrderCreateOrConnectWithoutItemsInput = {
    where: MedicineOrderWhereUniqueInput
    create: XOR<MedicineOrderCreateWithoutItemsInput, MedicineOrderUncheckedCreateWithoutItemsInput>
  }

  export type MedicineCreateWithoutOrderItemsInput = {
    uuid?: string
    name: string
    composition?: string | null
    category?: string | null
    price: number
    manufacturer?: string | null
    stockQty?: number
    description?: string | null
    sideEffects?: string | null
    interactions?: string | null
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: Date | string
  }

  export type MedicineUncheckedCreateWithoutOrderItemsInput = {
    id?: number
    uuid?: string
    name: string
    composition?: string | null
    category?: string | null
    price: number
    manufacturer?: string | null
    stockQty?: number
    description?: string | null
    sideEffects?: string | null
    interactions?: string | null
    requiresPrescription?: boolean
    available?: boolean
    createdAt?: Date | string
  }

  export type MedicineCreateOrConnectWithoutOrderItemsInput = {
    where: MedicineWhereUniqueInput
    create: XOR<MedicineCreateWithoutOrderItemsInput, MedicineUncheckedCreateWithoutOrderItemsInput>
  }

  export type MedicineOrderUpsertWithoutItemsInput = {
    update: XOR<MedicineOrderUpdateWithoutItemsInput, MedicineOrderUncheckedUpdateWithoutItemsInput>
    create: XOR<MedicineOrderCreateWithoutItemsInput, MedicineOrderUncheckedCreateWithoutItemsInput>
    where?: MedicineOrderWhereInput
  }

  export type MedicineOrderUpdateToOneWithWhereWithoutItemsInput = {
    where?: MedicineOrderWhereInput
    data: XOR<MedicineOrderUpdateWithoutItemsInput, MedicineOrderUncheckedUpdateWithoutItemsInput>
  }

  export type MedicineOrderUpdateWithoutItemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMedicineOrdersNestedInput
  }

  export type MedicineOrderUncheckedUpdateWithoutItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUpsertWithoutOrderItemsInput = {
    update: XOR<MedicineUpdateWithoutOrderItemsInput, MedicineUncheckedUpdateWithoutOrderItemsInput>
    create: XOR<MedicineCreateWithoutOrderItemsInput, MedicineUncheckedCreateWithoutOrderItemsInput>
    where?: MedicineWhereInput
  }

  export type MedicineUpdateToOneWithWhereWithoutOrderItemsInput = {
    where?: MedicineWhereInput
    data: XOR<MedicineUpdateWithoutOrderItemsInput, MedicineUncheckedUpdateWithoutOrderItemsInput>
  }

  export type MedicineUpdateWithoutOrderItemsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineUncheckedUpdateWithoutOrderItemsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    composition?: NullableStringFieldUpdateOperationsInput | string | null
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    manufacturer?: NullableStringFieldUpdateOperationsInput | string | null
    stockQty?: IntFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sideEffects?: NullableStringFieldUpdateOperationsInput | string | null
    interactions?: NullableStringFieldUpdateOperationsInput | string | null
    requiresPrescription?: BoolFieldUpdateOperationsInput | boolean
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingTestCreateWithoutTestInput = {
    booking: LabBookingCreateNestedOneWithoutTestsInput
  }

  export type LabBookingTestUncheckedCreateWithoutTestInput = {
    id?: number
    bookingId: number
  }

  export type LabBookingTestCreateOrConnectWithoutTestInput = {
    where: LabBookingTestWhereUniqueInput
    create: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput>
  }

  export type LabBookingTestCreateManyTestInputEnvelope = {
    data: LabBookingTestCreateManyTestInput | LabBookingTestCreateManyTestInput[]
  }

  export type LabBookingTestUpsertWithWhereUniqueWithoutTestInput = {
    where: LabBookingTestWhereUniqueInput
    update: XOR<LabBookingTestUpdateWithoutTestInput, LabBookingTestUncheckedUpdateWithoutTestInput>
    create: XOR<LabBookingTestCreateWithoutTestInput, LabBookingTestUncheckedCreateWithoutTestInput>
  }

  export type LabBookingTestUpdateWithWhereUniqueWithoutTestInput = {
    where: LabBookingTestWhereUniqueInput
    data: XOR<LabBookingTestUpdateWithoutTestInput, LabBookingTestUncheckedUpdateWithoutTestInput>
  }

  export type LabBookingTestUpdateManyWithWhereWithoutTestInput = {
    where: LabBookingTestScalarWhereInput
    data: XOR<LabBookingTestUpdateManyMutationInput, LabBookingTestUncheckedUpdateManyWithoutTestInput>
  }

  export type LabBookingTestScalarWhereInput = {
    AND?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
    OR?: LabBookingTestScalarWhereInput[]
    NOT?: LabBookingTestScalarWhereInput | LabBookingTestScalarWhereInput[]
    id?: IntFilter<"LabBookingTest"> | number
    bookingId?: IntFilter<"LabBookingTest"> | number
    testId?: IntFilter<"LabBookingTest"> | number
  }

  export type UserCreateWithoutLabBookingsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLabBookingsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLabBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLabBookingsInput, UserUncheckedCreateWithoutLabBookingsInput>
  }

  export type LabBookingTestCreateWithoutBookingInput = {
    test: LabTestCreateNestedOneWithoutBookingsInput
  }

  export type LabBookingTestUncheckedCreateWithoutBookingInput = {
    id?: number
    testId: number
  }

  export type LabBookingTestCreateOrConnectWithoutBookingInput = {
    where: LabBookingTestWhereUniqueInput
    create: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput>
  }

  export type LabBookingTestCreateManyBookingInputEnvelope = {
    data: LabBookingTestCreateManyBookingInput | LabBookingTestCreateManyBookingInput[]
  }

  export type LabReportCreateWithoutBookingInput = {
    uuid?: string
    reportUrl: string
    results?: string | null
    status?: string
    reviewedById?: number | null
    interpretation?: string | null
    recommendations?: string | null
    readyAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LabReportUncheckedCreateWithoutBookingInput = {
    id?: number
    uuid?: string
    reportUrl: string
    results?: string | null
    status?: string
    reviewedById?: number | null
    interpretation?: string | null
    recommendations?: string | null
    readyAt?: Date | string | null
    createdAt?: Date | string
  }

  export type LabReportCreateOrConnectWithoutBookingInput = {
    where: LabReportWhereUniqueInput
    create: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
  }

  export type UserUpsertWithoutLabBookingsInput = {
    update: XOR<UserUpdateWithoutLabBookingsInput, UserUncheckedUpdateWithoutLabBookingsInput>
    create: XOR<UserCreateWithoutLabBookingsInput, UserUncheckedCreateWithoutLabBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLabBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLabBookingsInput, UserUncheckedUpdateWithoutLabBookingsInput>
  }

  export type UserUpdateWithoutLabBookingsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLabBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LabBookingTestUpsertWithWhereUniqueWithoutBookingInput = {
    where: LabBookingTestWhereUniqueInput
    update: XOR<LabBookingTestUpdateWithoutBookingInput, LabBookingTestUncheckedUpdateWithoutBookingInput>
    create: XOR<LabBookingTestCreateWithoutBookingInput, LabBookingTestUncheckedCreateWithoutBookingInput>
  }

  export type LabBookingTestUpdateWithWhereUniqueWithoutBookingInput = {
    where: LabBookingTestWhereUniqueInput
    data: XOR<LabBookingTestUpdateWithoutBookingInput, LabBookingTestUncheckedUpdateWithoutBookingInput>
  }

  export type LabBookingTestUpdateManyWithWhereWithoutBookingInput = {
    where: LabBookingTestScalarWhereInput
    data: XOR<LabBookingTestUpdateManyMutationInput, LabBookingTestUncheckedUpdateManyWithoutBookingInput>
  }

  export type LabReportUpsertWithoutBookingInput = {
    update: XOR<LabReportUpdateWithoutBookingInput, LabReportUncheckedUpdateWithoutBookingInput>
    create: XOR<LabReportCreateWithoutBookingInput, LabReportUncheckedCreateWithoutBookingInput>
    where?: LabReportWhereInput
  }

  export type LabReportUpdateToOneWithWhereWithoutBookingInput = {
    where?: LabReportWhereInput
    data: XOR<LabReportUpdateWithoutBookingInput, LabReportUncheckedUpdateWithoutBookingInput>
  }

  export type LabReportUpdateWithoutBookingInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabReportUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    reportUrl?: StringFieldUpdateOperationsInput | string
    results?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    reviewedById?: NullableIntFieldUpdateOperationsInput | number | null
    interpretation?: NullableStringFieldUpdateOperationsInput | string | null
    recommendations?: NullableStringFieldUpdateOperationsInput | string | null
    readyAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingCreateWithoutTestsInput = {
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLabBookingsInput
    report?: LabReportCreateNestedOneWithoutBookingInput
  }

  export type LabBookingUncheckedCreateWithoutTestsInput = {
    id?: number
    uuid?: string
    userId: number
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    report?: LabReportUncheckedCreateNestedOneWithoutBookingInput
  }

  export type LabBookingCreateOrConnectWithoutTestsInput = {
    where: LabBookingWhereUniqueInput
    create: XOR<LabBookingCreateWithoutTestsInput, LabBookingUncheckedCreateWithoutTestsInput>
  }

  export type LabTestCreateWithoutBookingsInput = {
    uuid?: string
    name: string
    category?: string | null
    price: number
    description?: string | null
    preparation?: string | null
    parameters?: string | null
    turnaroundTime?: string | null
    available?: boolean
    createdAt?: Date | string
  }

  export type LabTestUncheckedCreateWithoutBookingsInput = {
    id?: number
    uuid?: string
    name: string
    category?: string | null
    price: number
    description?: string | null
    preparation?: string | null
    parameters?: string | null
    turnaroundTime?: string | null
    available?: boolean
    createdAt?: Date | string
  }

  export type LabTestCreateOrConnectWithoutBookingsInput = {
    where: LabTestWhereUniqueInput
    create: XOR<LabTestCreateWithoutBookingsInput, LabTestUncheckedCreateWithoutBookingsInput>
  }

  export type LabBookingUpsertWithoutTestsInput = {
    update: XOR<LabBookingUpdateWithoutTestsInput, LabBookingUncheckedUpdateWithoutTestsInput>
    create: XOR<LabBookingCreateWithoutTestsInput, LabBookingUncheckedCreateWithoutTestsInput>
    where?: LabBookingWhereInput
  }

  export type LabBookingUpdateToOneWithWhereWithoutTestsInput = {
    where?: LabBookingWhereInput
    data: XOR<LabBookingUpdateWithoutTestsInput, LabBookingUncheckedUpdateWithoutTestsInput>
  }

  export type LabBookingUpdateWithoutTestsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabBookingsNestedInput
    report?: LabReportUpdateOneWithoutBookingNestedInput
  }

  export type LabBookingUncheckedUpdateWithoutTestsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    report?: LabReportUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type LabTestUpsertWithoutBookingsInput = {
    update: XOR<LabTestUpdateWithoutBookingsInput, LabTestUncheckedUpdateWithoutBookingsInput>
    create: XOR<LabTestCreateWithoutBookingsInput, LabTestUncheckedCreateWithoutBookingsInput>
    where?: LabTestWhereInput
  }

  export type LabTestUpdateToOneWithWhereWithoutBookingsInput = {
    where?: LabTestWhereInput
    data: XOR<LabTestUpdateWithoutBookingsInput, LabTestUncheckedUpdateWithoutBookingsInput>
  }

  export type LabTestUpdateWithoutBookingsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabTestUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    description?: NullableStringFieldUpdateOperationsInput | string | null
    preparation?: NullableStringFieldUpdateOperationsInput | string | null
    parameters?: NullableStringFieldUpdateOperationsInput | string | null
    turnaroundTime?: NullableStringFieldUpdateOperationsInput | string | null
    available?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingCreateWithoutReportInput = {
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutLabBookingsInput
    tests?: LabBookingTestCreateNestedManyWithoutBookingInput
  }

  export type LabBookingUncheckedCreateWithoutReportInput = {
    id?: number
    uuid?: string
    userId: number
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
    tests?: LabBookingTestUncheckedCreateNestedManyWithoutBookingInput
  }

  export type LabBookingCreateOrConnectWithoutReportInput = {
    where: LabBookingWhereUniqueInput
    create: XOR<LabBookingCreateWithoutReportInput, LabBookingUncheckedCreateWithoutReportInput>
  }

  export type LabBookingUpsertWithoutReportInput = {
    update: XOR<LabBookingUpdateWithoutReportInput, LabBookingUncheckedUpdateWithoutReportInput>
    create: XOR<LabBookingCreateWithoutReportInput, LabBookingUncheckedCreateWithoutReportInput>
    where?: LabBookingWhereInput
  }

  export type LabBookingUpdateToOneWithWhereWithoutReportInput = {
    where?: LabBookingWhereInput
    data: XOR<LabBookingUpdateWithoutReportInput, LabBookingUncheckedUpdateWithoutReportInput>
  }

  export type LabBookingUpdateWithoutReportInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLabBookingsNestedInput
    tests?: LabBookingTestUpdateManyWithoutBookingNestedInput
  }

  export type LabBookingUncheckedUpdateWithoutReportInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tests?: LabBookingTestUncheckedUpdateManyWithoutBookingNestedInput
  }

  export type UserCreateWithoutHealthRecordsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutHealthRecordsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutHealthRecordsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutHealthRecordsInput, UserUncheckedCreateWithoutHealthRecordsInput>
  }

  export type UserUpsertWithoutHealthRecordsInput = {
    update: XOR<UserUpdateWithoutHealthRecordsInput, UserUncheckedUpdateWithoutHealthRecordsInput>
    create: XOR<UserCreateWithoutHealthRecordsInput, UserUncheckedCreateWithoutHealthRecordsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutHealthRecordsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutHealthRecordsInput, UserUncheckedUpdateWithoutHealthRecordsInput>
  }

  export type UserUpdateWithoutHealthRecordsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutHealthRecordsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutForumPostsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumPostsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumPostsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
  }

  export type ForumCommentCreateWithoutPostInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumCommentsInput
    parentComment?: ForumCommentCreateNestedOneWithoutRepliesInput
    replies?: ForumCommentCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUncheckedCreateWithoutPostInput = {
    id?: number
    uuid?: string
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentCreateOrConnectWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentCreateManyPostInputEnvelope = {
    data: ForumCommentCreateManyPostInput | ForumCommentCreateManyPostInput[]
  }

  export type PostUpvoteCreateWithoutPostInput = {
    voteType: string
    user: UserCreateNestedOneWithoutPostUpvotesInput
  }

  export type PostUpvoteUncheckedCreateWithoutPostInput = {
    id?: number
    userId: number
    voteType: string
  }

  export type PostUpvoteCreateOrConnectWithoutPostInput = {
    where: PostUpvoteWhereUniqueInput
    create: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput>
  }

  export type PostUpvoteCreateManyPostInputEnvelope = {
    data: PostUpvoteCreateManyPostInput | PostUpvoteCreateManyPostInput[]
  }

  export type UserUpsertWithoutForumPostsInput = {
    update: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
    create: XOR<UserCreateWithoutForumPostsInput, UserUncheckedCreateWithoutForumPostsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumPostsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumPostsInput, UserUncheckedUpdateWithoutForumPostsInput>
  }

  export type UserUpdateWithoutForumPostsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumPostsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
    create: XOR<ForumCommentCreateWithoutPostInput, ForumCommentUncheckedCreateWithoutPostInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutPostInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutPostInput, ForumCommentUncheckedUpdateWithoutPostInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutPostInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutPostInput>
  }

  export type PostUpvoteUpsertWithWhereUniqueWithoutPostInput = {
    where: PostUpvoteWhereUniqueInput
    update: XOR<PostUpvoteUpdateWithoutPostInput, PostUpvoteUncheckedUpdateWithoutPostInput>
    create: XOR<PostUpvoteCreateWithoutPostInput, PostUpvoteUncheckedCreateWithoutPostInput>
  }

  export type PostUpvoteUpdateWithWhereUniqueWithoutPostInput = {
    where: PostUpvoteWhereUniqueInput
    data: XOR<PostUpvoteUpdateWithoutPostInput, PostUpvoteUncheckedUpdateWithoutPostInput>
  }

  export type PostUpvoteUpdateManyWithWhereWithoutPostInput = {
    where: PostUpvoteScalarWhereInput
    data: XOR<PostUpvoteUpdateManyMutationInput, PostUpvoteUncheckedUpdateManyWithoutPostInput>
  }

  export type ForumPostCreateWithoutCommentsInput = {
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumPostsInput
    upvotesByUser?: PostUpvoteCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutCommentsInput = {
    id?: number
    uuid?: string
    userId: number
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    upvotesByUser?: PostUpvoteUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutCommentsInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
  }

  export type UserCreateWithoutForumCommentsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutForumCommentsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutForumCommentsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
  }

  export type ForumCommentCreateWithoutRepliesInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutForumCommentsInput
    parentComment?: ForumCommentCreateNestedOneWithoutRepliesInput
    upvotesByUser?: CommentUpvoteCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUncheckedCreateWithoutRepliesInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    upvotesByUser?: CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentCreateOrConnectWithoutRepliesInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutRepliesInput, ForumCommentUncheckedCreateWithoutRepliesInput>
  }

  export type ForumCommentCreateWithoutParentCommentInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutForumCommentsInput
    replies?: ForumCommentCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentUncheckedCreateWithoutParentCommentInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput
    upvotesByUser?: CommentUpvoteUncheckedCreateNestedManyWithoutCommentInput
  }

  export type ForumCommentCreateOrConnectWithoutParentCommentInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type ForumCommentCreateManyParentCommentInputEnvelope = {
    data: ForumCommentCreateManyParentCommentInput | ForumCommentCreateManyParentCommentInput[]
  }

  export type CommentUpvoteCreateWithoutCommentInput = {
    voteType: string
    user: UserCreateNestedOneWithoutCommentUpvotesInput
  }

  export type CommentUpvoteUncheckedCreateWithoutCommentInput = {
    id?: number
    userId: number
    voteType: string
  }

  export type CommentUpvoteCreateOrConnectWithoutCommentInput = {
    where: CommentUpvoteWhereUniqueInput
    create: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput>
  }

  export type CommentUpvoteCreateManyCommentInputEnvelope = {
    data: CommentUpvoteCreateManyCommentInput | CommentUpvoteCreateManyCommentInput[]
  }

  export type ForumPostUpsertWithoutCommentsInput = {
    update: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
    create: XOR<ForumPostCreateWithoutCommentsInput, ForumPostUncheckedCreateWithoutCommentsInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutCommentsInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutCommentsInput, ForumPostUncheckedUpdateWithoutCommentsInput>
  }

  export type ForumPostUpdateWithoutCommentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    upvotesByUser?: PostUpvoteUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotesByUser?: PostUpvoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutForumCommentsInput = {
    update: XOR<UserUpdateWithoutForumCommentsInput, UserUncheckedUpdateWithoutForumCommentsInput>
    create: XOR<UserCreateWithoutForumCommentsInput, UserUncheckedCreateWithoutForumCommentsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutForumCommentsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutForumCommentsInput, UserUncheckedUpdateWithoutForumCommentsInput>
  }

  export type UserUpdateWithoutForumCommentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutForumCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumCommentUpsertWithoutRepliesInput = {
    update: XOR<ForumCommentUpdateWithoutRepliesInput, ForumCommentUncheckedUpdateWithoutRepliesInput>
    create: XOR<ForumCommentCreateWithoutRepliesInput, ForumCommentUncheckedCreateWithoutRepliesInput>
    where?: ForumCommentWhereInput
  }

  export type ForumCommentUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ForumCommentWhereInput
    data: XOR<ForumCommentUpdateWithoutRepliesInput, ForumCommentUncheckedUpdateWithoutRepliesInput>
  }

  export type ForumCommentUpdateWithoutRepliesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    parentComment?: ForumCommentUpdateOneWithoutRepliesNestedInput
    upvotesByUser?: CommentUpvoteUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutRepliesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    upvotesByUser?: CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUpsertWithWhereUniqueWithoutParentCommentInput = {
    where: ForumCommentWhereUniqueInput
    update: XOR<ForumCommentUpdateWithoutParentCommentInput, ForumCommentUncheckedUpdateWithoutParentCommentInput>
    create: XOR<ForumCommentCreateWithoutParentCommentInput, ForumCommentUncheckedCreateWithoutParentCommentInput>
  }

  export type ForumCommentUpdateWithWhereUniqueWithoutParentCommentInput = {
    where: ForumCommentWhereUniqueInput
    data: XOR<ForumCommentUpdateWithoutParentCommentInput, ForumCommentUncheckedUpdateWithoutParentCommentInput>
  }

  export type ForumCommentUpdateManyWithWhereWithoutParentCommentInput = {
    where: ForumCommentScalarWhereInput
    data: XOR<ForumCommentUpdateManyMutationInput, ForumCommentUncheckedUpdateManyWithoutParentCommentInput>
  }

  export type CommentUpvoteUpsertWithWhereUniqueWithoutCommentInput = {
    where: CommentUpvoteWhereUniqueInput
    update: XOR<CommentUpvoteUpdateWithoutCommentInput, CommentUpvoteUncheckedUpdateWithoutCommentInput>
    create: XOR<CommentUpvoteCreateWithoutCommentInput, CommentUpvoteUncheckedCreateWithoutCommentInput>
  }

  export type CommentUpvoteUpdateWithWhereUniqueWithoutCommentInput = {
    where: CommentUpvoteWhereUniqueInput
    data: XOR<CommentUpvoteUpdateWithoutCommentInput, CommentUpvoteUncheckedUpdateWithoutCommentInput>
  }

  export type CommentUpvoteUpdateManyWithWhereWithoutCommentInput = {
    where: CommentUpvoteScalarWhereInput
    data: XOR<CommentUpvoteUpdateManyMutationInput, CommentUpvoteUncheckedUpdateManyWithoutCommentInput>
  }

  export type ForumPostCreateWithoutUpvotesByUserInput = {
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutForumPostsInput
    comments?: ForumCommentCreateNestedManyWithoutPostInput
  }

  export type ForumPostUncheckedCreateWithoutUpvotesByUserInput = {
    id?: number
    uuid?: string
    userId: number
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ForumCommentUncheckedCreateNestedManyWithoutPostInput
  }

  export type ForumPostCreateOrConnectWithoutUpvotesByUserInput = {
    where: ForumPostWhereUniqueInput
    create: XOR<ForumPostCreateWithoutUpvotesByUserInput, ForumPostUncheckedCreateWithoutUpvotesByUserInput>
  }

  export type UserCreateWithoutPostUpvotesInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPostUpvotesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPostUpvotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPostUpvotesInput, UserUncheckedCreateWithoutPostUpvotesInput>
  }

  export type ForumPostUpsertWithoutUpvotesByUserInput = {
    update: XOR<ForumPostUpdateWithoutUpvotesByUserInput, ForumPostUncheckedUpdateWithoutUpvotesByUserInput>
    create: XOR<ForumPostCreateWithoutUpvotesByUserInput, ForumPostUncheckedCreateWithoutUpvotesByUserInput>
    where?: ForumPostWhereInput
  }

  export type ForumPostUpdateToOneWithWhereWithoutUpvotesByUserInput = {
    where?: ForumPostWhereInput
    data: XOR<ForumPostUpdateWithoutUpvotesByUserInput, ForumPostUncheckedUpdateWithoutUpvotesByUserInput>
  }

  export type ForumPostUpdateWithoutUpvotesByUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumPostsNestedInput
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutUpvotesByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
  }

  export type UserUpsertWithoutPostUpvotesInput = {
    update: XOR<UserUpdateWithoutPostUpvotesInput, UserUncheckedUpdateWithoutPostUpvotesInput>
    create: XOR<UserCreateWithoutPostUpvotesInput, UserUncheckedCreateWithoutPostUpvotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPostUpvotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPostUpvotesInput, UserUncheckedUpdateWithoutPostUpvotesInput>
  }

  export type UserUpdateWithoutPostUpvotesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPostUpvotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ForumCommentCreateWithoutUpvotesByUserInput = {
    uuid?: string
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    post: ForumPostCreateNestedOneWithoutCommentsInput
    user: UserCreateNestedOneWithoutForumCommentsInput
    parentComment?: ForumCommentCreateNestedOneWithoutRepliesInput
    replies?: ForumCommentCreateNestedManyWithoutParentCommentInput
  }

  export type ForumCommentUncheckedCreateWithoutUpvotesByUserInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    replies?: ForumCommentUncheckedCreateNestedManyWithoutParentCommentInput
  }

  export type ForumCommentCreateOrConnectWithoutUpvotesByUserInput = {
    where: ForumCommentWhereUniqueInput
    create: XOR<ForumCommentCreateWithoutUpvotesByUserInput, ForumCommentUncheckedCreateWithoutUpvotesByUserInput>
  }

  export type UserCreateWithoutCommentUpvotesInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCommentUpvotesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCommentUpvotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCommentUpvotesInput, UserUncheckedCreateWithoutCommentUpvotesInput>
  }

  export type ForumCommentUpsertWithoutUpvotesByUserInput = {
    update: XOR<ForumCommentUpdateWithoutUpvotesByUserInput, ForumCommentUncheckedUpdateWithoutUpvotesByUserInput>
    create: XOR<ForumCommentCreateWithoutUpvotesByUserInput, ForumCommentUncheckedCreateWithoutUpvotesByUserInput>
    where?: ForumCommentWhereInput
  }

  export type ForumCommentUpdateToOneWithWhereWithoutUpvotesByUserInput = {
    where?: ForumCommentWhereInput
    data: XOR<ForumCommentUpdateWithoutUpvotesByUserInput, ForumCommentUncheckedUpdateWithoutUpvotesByUserInput>
  }

  export type ForumCommentUpdateWithoutUpvotesByUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    parentComment?: ForumCommentUpdateOneWithoutRepliesNestedInput
    replies?: ForumCommentUpdateManyWithoutParentCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutUpvotesByUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput
  }

  export type UserUpsertWithoutCommentUpvotesInput = {
    update: XOR<UserUpdateWithoutCommentUpvotesInput, UserUncheckedUpdateWithoutCommentUpvotesInput>
    create: XOR<UserCreateWithoutCommentUpvotesInput, UserUncheckedCreateWithoutCommentUpvotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCommentUpvotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCommentUpvotesInput, UserUncheckedUpdateWithoutCommentUpvotesInput>
  }

  export type UserUpdateWithoutCommentUpvotesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCommentUpvotesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutArticlesInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutArticlesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
  }

  export type ArticleCommentCreateWithoutArticleInput = {
    uuid?: string
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
  }

  export type ArticleCommentUncheckedCreateWithoutArticleInput = {
    id?: number
    uuid?: string
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
  }

  export type ArticleCommentCreateOrConnectWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    create: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCommentCreateManyArticleInputEnvelope = {
    data: ArticleCommentCreateManyArticleInput | ArticleCommentCreateManyArticleInput[]
  }

  export type SavedArticleCreateWithoutArticleInput = {
    savedAt?: Date | string
    user: UserCreateNestedOneWithoutSavedArticlesInput
  }

  export type SavedArticleUncheckedCreateWithoutArticleInput = {
    id?: number
    userId: number
    savedAt?: Date | string
  }

  export type SavedArticleCreateOrConnectWithoutArticleInput = {
    where: SavedArticleWhereUniqueInput
    create: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput>
  }

  export type SavedArticleCreateManyArticleInputEnvelope = {
    data: SavedArticleCreateManyArticleInput | SavedArticleCreateManyArticleInput[]
  }

  export type UserUpsertWithoutArticlesInput = {
    update: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
    create: XOR<UserCreateWithoutArticlesInput, UserUncheckedCreateWithoutArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutArticlesInput, UserUncheckedUpdateWithoutArticlesInput>
  }

  export type UserUpdateWithoutArticlesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ArticleCommentUpsertWithWhereUniqueWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    update: XOR<ArticleCommentUpdateWithoutArticleInput, ArticleCommentUncheckedUpdateWithoutArticleInput>
    create: XOR<ArticleCommentCreateWithoutArticleInput, ArticleCommentUncheckedCreateWithoutArticleInput>
  }

  export type ArticleCommentUpdateWithWhereUniqueWithoutArticleInput = {
    where: ArticleCommentWhereUniqueInput
    data: XOR<ArticleCommentUpdateWithoutArticleInput, ArticleCommentUncheckedUpdateWithoutArticleInput>
  }

  export type ArticleCommentUpdateManyWithWhereWithoutArticleInput = {
    where: ArticleCommentScalarWhereInput
    data: XOR<ArticleCommentUpdateManyMutationInput, ArticleCommentUncheckedUpdateManyWithoutArticleInput>
  }

  export type ArticleCommentScalarWhereInput = {
    AND?: ArticleCommentScalarWhereInput | ArticleCommentScalarWhereInput[]
    OR?: ArticleCommentScalarWhereInput[]
    NOT?: ArticleCommentScalarWhereInput | ArticleCommentScalarWhereInput[]
    id?: IntFilter<"ArticleComment"> | number
    uuid?: StringFilter<"ArticleComment"> | string
    articleId?: IntFilter<"ArticleComment"> | number
    userId?: IntFilter<"ArticleComment"> | number
    content?: StringFilter<"ArticleComment"> | string
    upvotes?: IntFilter<"ArticleComment"> | number
    createdAt?: DateTimeFilter<"ArticleComment"> | Date | string
  }

  export type SavedArticleUpsertWithWhereUniqueWithoutArticleInput = {
    where: SavedArticleWhereUniqueInput
    update: XOR<SavedArticleUpdateWithoutArticleInput, SavedArticleUncheckedUpdateWithoutArticleInput>
    create: XOR<SavedArticleCreateWithoutArticleInput, SavedArticleUncheckedCreateWithoutArticleInput>
  }

  export type SavedArticleUpdateWithWhereUniqueWithoutArticleInput = {
    where: SavedArticleWhereUniqueInput
    data: XOR<SavedArticleUpdateWithoutArticleInput, SavedArticleUncheckedUpdateWithoutArticleInput>
  }

  export type SavedArticleUpdateManyWithWhereWithoutArticleInput = {
    where: SavedArticleScalarWhereInput
    data: XOR<SavedArticleUpdateManyMutationInput, SavedArticleUncheckedUpdateManyWithoutArticleInput>
  }

  export type HealthArticleCreateWithoutCommentsInput = {
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutArticlesInput
    savedBy?: SavedArticleCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleUncheckedCreateWithoutCommentsInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    authorId?: number | null
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    savedBy?: SavedArticleUncheckedCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleCreateOrConnectWithoutCommentsInput = {
    where: HealthArticleWhereUniqueInput
    create: XOR<HealthArticleCreateWithoutCommentsInput, HealthArticleUncheckedCreateWithoutCommentsInput>
  }

  export type HealthArticleUpsertWithoutCommentsInput = {
    update: XOR<HealthArticleUpdateWithoutCommentsInput, HealthArticleUncheckedUpdateWithoutCommentsInput>
    create: XOR<HealthArticleCreateWithoutCommentsInput, HealthArticleUncheckedCreateWithoutCommentsInput>
    where?: HealthArticleWhereInput
  }

  export type HealthArticleUpdateToOneWithWhereWithoutCommentsInput = {
    where?: HealthArticleWhereInput
    data: XOR<HealthArticleUpdateWithoutCommentsInput, HealthArticleUncheckedUpdateWithoutCommentsInput>
  }

  export type HealthArticleUpdateWithoutCommentsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutArticlesNestedInput
    savedBy?: SavedArticleUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleUncheckedUpdateWithoutCommentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    savedBy?: SavedArticleUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserCreateWithoutSavedArticlesInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSavedArticlesInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSavedArticlesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSavedArticlesInput, UserUncheckedCreateWithoutSavedArticlesInput>
  }

  export type HealthArticleCreateWithoutSavedByInput = {
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    author?: UserCreateNestedOneWithoutArticlesInput
    comments?: ArticleCommentCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleUncheckedCreateWithoutSavedByInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    authorId?: number | null
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    comments?: ArticleCommentUncheckedCreateNestedManyWithoutArticleInput
  }

  export type HealthArticleCreateOrConnectWithoutSavedByInput = {
    where: HealthArticleWhereUniqueInput
    create: XOR<HealthArticleCreateWithoutSavedByInput, HealthArticleUncheckedCreateWithoutSavedByInput>
  }

  export type UserUpsertWithoutSavedArticlesInput = {
    update: XOR<UserUpdateWithoutSavedArticlesInput, UserUncheckedUpdateWithoutSavedArticlesInput>
    create: XOR<UserCreateWithoutSavedArticlesInput, UserUncheckedCreateWithoutSavedArticlesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSavedArticlesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSavedArticlesInput, UserUncheckedUpdateWithoutSavedArticlesInput>
  }

  export type UserUpdateWithoutSavedArticlesInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSavedArticlesInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type HealthArticleUpsertWithoutSavedByInput = {
    update: XOR<HealthArticleUpdateWithoutSavedByInput, HealthArticleUncheckedUpdateWithoutSavedByInput>
    create: XOR<HealthArticleCreateWithoutSavedByInput, HealthArticleUncheckedCreateWithoutSavedByInput>
    where?: HealthArticleWhereInput
  }

  export type HealthArticleUpdateToOneWithWhereWithoutSavedByInput = {
    where?: HealthArticleWhereInput
    data: XOR<HealthArticleUpdateWithoutSavedByInput, HealthArticleUncheckedUpdateWithoutSavedByInput>
  }

  export type HealthArticleUpdateWithoutSavedByInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneWithoutArticlesNestedInput
    comments?: ArticleCommentUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleUncheckedUpdateWithoutSavedByInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    authorId?: NullableIntFieldUpdateOperationsInput | number | null
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSymptomSessionsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSymptomSessionsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    coachSessions?: CoachSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSymptomSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSymptomSessionsInput, UserUncheckedCreateWithoutSymptomSessionsInput>
  }

  export type UserUpsertWithoutSymptomSessionsInput = {
    update: XOR<UserUpdateWithoutSymptomSessionsInput, UserUncheckedUpdateWithoutSymptomSessionsInput>
    create: XOR<UserCreateWithoutSymptomSessionsInput, UserUncheckedCreateWithoutSymptomSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSymptomSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSymptomSessionsInput, UserUncheckedUpdateWithoutSymptomSessionsInput>
  }

  export type UserUpdateWithoutSymptomSessionsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSymptomSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    coachSessions?: CoachSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutCoachSessionsInput = {
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorCreateNestedOneWithoutUserInput
    appointments?: AppointmentCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderCreateNestedManyWithoutUserInput
    labBookings?: LabBookingCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteCreateNestedManyWithoutUserInput
    articles?: HealthArticleCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCoachSessionsInput = {
    id?: number
    uuid?: string
    email: string
    phone?: string | null
    passwordHash?: string | null
    fullName?: string | null
    profilePhotoUrl?: string | null
    dateOfBirth?: Date | string | null
    gender?: string | null
    bloodGroup?: string | null
    city?: string | null
    state?: string | null
    country?: string | null
    address?: string | null
    abhaId?: string | null
    isVerified?: boolean
    isActive?: boolean
    role?: string
    lastLogin?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    healthProfile?: HealthProfileUncheckedCreateNestedOneWithoutUserInput
    doctorProfile?: DoctorUncheckedCreateNestedOneWithoutUserInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutUserInput
    appointmentsAsDoctor?: AppointmentUncheckedCreateNestedManyWithoutDoctorInput
    medicineOrders?: MedicineOrderUncheckedCreateNestedManyWithoutUserInput
    labBookings?: LabBookingUncheckedCreateNestedManyWithoutUserInput
    healthRecords?: HealthRecordUncheckedCreateNestedManyWithoutUserInput
    forumPosts?: ForumPostUncheckedCreateNestedManyWithoutUserInput
    forumComments?: ForumCommentUncheckedCreateNestedManyWithoutUserInput
    postUpvotes?: PostUpvoteUncheckedCreateNestedManyWithoutUserInput
    commentUpvotes?: CommentUpvoteUncheckedCreateNestedManyWithoutUserInput
    articles?: HealthArticleUncheckedCreateNestedManyWithoutAuthorInput
    savedArticles?: SavedArticleUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    reviews?: DoctorReviewUncheckedCreateNestedManyWithoutUserInput
    symptomSessions?: SymptomCheckSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCoachSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCoachSessionsInput, UserUncheckedCreateWithoutCoachSessionsInput>
  }

  export type UserUpsertWithoutCoachSessionsInput = {
    update: XOR<UserUpdateWithoutCoachSessionsInput, UserUncheckedUpdateWithoutCoachSessionsInput>
    create: XOR<UserCreateWithoutCoachSessionsInput, UserUncheckedCreateWithoutCoachSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCoachSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCoachSessionsInput, UserUncheckedUpdateWithoutCoachSessionsInput>
  }

  export type UserUpdateWithoutCoachSessionsInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCoachSessionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHash?: NullableStringFieldUpdateOperationsInput | string | null
    fullName?: NullableStringFieldUpdateOperationsInput | string | null
    profilePhotoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    bloodGroup?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    abhaId?: NullableStringFieldUpdateOperationsInput | string | null
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    role?: StringFieldUpdateOperationsInput | string
    lastLogin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    healthProfile?: HealthProfileUncheckedUpdateOneWithoutUserNestedInput
    doctorProfile?: DoctorUncheckedUpdateOneWithoutUserNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutUserNestedInput
    appointmentsAsDoctor?: AppointmentUncheckedUpdateManyWithoutDoctorNestedInput
    medicineOrders?: MedicineOrderUncheckedUpdateManyWithoutUserNestedInput
    labBookings?: LabBookingUncheckedUpdateManyWithoutUserNestedInput
    healthRecords?: HealthRecordUncheckedUpdateManyWithoutUserNestedInput
    forumPosts?: ForumPostUncheckedUpdateManyWithoutUserNestedInput
    forumComments?: ForumCommentUncheckedUpdateManyWithoutUserNestedInput
    postUpvotes?: PostUpvoteUncheckedUpdateManyWithoutUserNestedInput
    commentUpvotes?: CommentUpvoteUncheckedUpdateManyWithoutUserNestedInput
    articles?: HealthArticleUncheckedUpdateManyWithoutAuthorNestedInput
    savedArticles?: SavedArticleUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutUserNestedInput
    symptomSessions?: SymptomCheckSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppointmentCreateManyUserInput = {
    id?: number
    uuid?: string
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateManyDoctorInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicineOrderCreateManyUserInput = {
    id?: number
    uuid?: string
    orderDate?: Date | string
    deliveryAddress: string
    status?: string
    totalAmount: number
    paymentMethod?: string | null
    paymentStatus?: string
    prescriptionUrl?: string | null
    deliveryDate?: Date | string | null
    expectedDeliveryDate?: Date | string | null
    trackingNumber?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LabBookingCreateManyUserInput = {
    id?: number
    uuid?: string
    bookingDate: Date | string
    collectionType: string
    address?: string | null
    status?: string
    totalAmount: number
    paymentStatus?: string
    reportUrl?: string | null
    reportReadyDate?: Date | string | null
    createdAt?: Date | string
  }

  export type HealthRecordCreateManyUserInput = {
    id?: number
    uuid?: string
    recordType: string
    title: string
    description?: string | null
    fileUrl: string
    fileName: string
    fileType?: string | null
    fileSize?: number | null
    doctorId?: number | null
    appointmentId?: number | null
    documentDate?: Date | string | null
    isPublic?: boolean
    sharedWith?: string | null
    createdAt?: Date | string
  }

  export type ForumPostCreateManyUserInput = {
    id?: number
    uuid?: string
    title: string
    content: string
    category: string
    status?: string
    upvotes?: number
    downvotes?: number
    views?: number
    commentsCount?: number
    pinned?: boolean
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ForumCommentCreateManyUserInput = {
    id?: number
    uuid?: string
    postId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpvoteCreateManyUserInput = {
    id?: number
    postId: number
    voteType: string
  }

  export type CommentUpvoteCreateManyUserInput = {
    id?: number
    commentId: number
    voteType: string
  }

  export type HealthArticleCreateManyAuthorInput = {
    id?: number
    uuid?: string
    title: string
    slug: string
    content: string
    category: string
    featuredImageUrl?: string | null
    status?: string
    views?: number
    publishedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SavedArticleCreateManyUserInput = {
    id?: number
    articleId: number
    savedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    uuid?: string
    type: string
    title: string
    message: string
    data?: string | null
    read?: boolean
    actionUrl?: string | null
    createdAt?: Date | string
  }

  export type DoctorReviewCreateManyUserInput = {
    id?: number
    uuid?: string
    doctorId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type SymptomCheckSessionCreateManyUserInput = {
    id?: number
    uuid?: string
    conversation: string
    result?: string | null
    riskLevel?: string | null
    createdAt?: Date | string
  }

  export type CoachSessionCreateManyUserInput = {
    id?: number
    uuid?: string
    conversation: string
    savedPlan?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutDoctorInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineOrderUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MedicineOrderItemUpdateManyWithoutOrderNestedInput
  }

  export type MedicineOrderUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    items?: MedicineOrderItemUncheckedUpdateManyWithoutOrderNestedInput
  }

  export type MedicineOrderUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    orderDate?: DateTimeFieldUpdateOperationsInput | Date | string
    deliveryAddress?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    prescriptionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    deliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    expectedDeliveryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    trackingNumber?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabBookingUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tests?: LabBookingTestUpdateManyWithoutBookingNestedInput
    report?: LabReportUpdateOneWithoutBookingNestedInput
  }

  export type LabBookingUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tests?: LabBookingTestUncheckedUpdateManyWithoutBookingNestedInput
    report?: LabReportUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type LabBookingUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    bookingDate?: DateTimeFieldUpdateOperationsInput | Date | string
    collectionType?: StringFieldUpdateOperationsInput | string
    address?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalAmount?: FloatFieldUpdateOperationsInput | number
    paymentStatus?: StringFieldUpdateOperationsInput | string
    reportUrl?: NullableStringFieldUpdateOperationsInput | string | null
    reportReadyDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HealthRecordUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    recordType?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    fileUrl?: StringFieldUpdateOperationsInput | string
    fileName?: StringFieldUpdateOperationsInput | string
    fileType?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    doctorId?: NullableIntFieldUpdateOperationsInput | number | null
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    documentDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    sharedWith?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumPostUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUpdateManyWithoutPostNestedInput
    upvotesByUser?: PostUpvoteUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ForumCommentUncheckedUpdateManyWithoutPostNestedInput
    upvotesByUser?: PostUpvoteUncheckedUpdateManyWithoutPostNestedInput
  }

  export type ForumPostUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    downvotes?: IntFieldUpdateOperationsInput | number
    views?: IntFieldUpdateOperationsInput | number
    commentsCount?: IntFieldUpdateOperationsInput | number
    pinned?: BoolFieldUpdateOperationsInput | boolean
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ForumCommentUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    parentComment?: ForumCommentUpdateOneWithoutRepliesNestedInput
    replies?: ForumCommentUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpvoteUpdateWithoutUserInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    post?: ForumPostUpdateOneRequiredWithoutUpvotesByUserNestedInput
  }

  export type PostUpvoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpvoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    postId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteUpdateWithoutUserInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    comment?: ForumCommentUpdateOneRequiredWithoutUpvotesByUserNestedInput
  }

  export type CommentUpvoteUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    commentId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type HealthArticleUpdateWithoutAuthorInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ArticleCommentUpdateManyWithoutArticleNestedInput
    savedBy?: SavedArticleUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleUncheckedUpdateWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    comments?: ArticleCommentUncheckedUpdateManyWithoutArticleNestedInput
    savedBy?: SavedArticleUncheckedUpdateManyWithoutArticleNestedInput
  }

  export type HealthArticleUncheckedUpdateManyWithoutAuthorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    featuredImageUrl?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    views?: IntFieldUpdateOperationsInput | number
    publishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleUpdateWithoutUserInput = {
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    article?: HealthArticleUpdateOneRequiredWithoutSavedByNestedInput
  }

  export type SavedArticleUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    articleId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    actionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutReviewsNestedInput
    appointment?: AppointmentUpdateOneWithoutReviewsNestedInput
  }

  export type DoctorReviewUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SymptomCheckSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    result?: NullableStringFieldUpdateOperationsInput | string | null
    riskLevel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionUpdateWithoutUserInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CoachSessionUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    conversation?: StringFieldUpdateOperationsInput | string
    savedPlan?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyDoctorProfileInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    prescriptionId?: number | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DoctorReviewCreateManyDoctorInput = {
    id?: number
    uuid?: string
    userId: number
    appointmentId?: number | null
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type AppointmentUpdateWithoutDoctorProfileInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    prescription?: PrescriptionUpdateOneWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutDoctorProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutDoctorProfileInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    prescriptionId?: NullableIntFieldUpdateOperationsInput | number | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUpdateWithoutDoctorInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    appointment?: AppointmentUpdateOneWithoutReviewsNestedInput
  }

  export type DoctorReviewUncheckedUpdateWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUncheckedUpdateManyWithoutDoctorInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    appointmentId?: NullableIntFieldUpdateOperationsInput | number | null
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewCreateManyAppointmentInput = {
    id?: number
    uuid?: string
    doctorId: number
    userId: number
    rating: number
    review?: string | null
    verified?: boolean
    helpfulCount?: number
    createdAt?: Date | string
  }

  export type DoctorReviewUpdateWithoutAppointmentInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    doctor?: DoctorUpdateOneRequiredWithoutReviewsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type DoctorReviewUncheckedUpdateWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DoctorReviewUncheckedUpdateManyWithoutAppointmentInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    doctorId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    rating?: IntFieldUpdateOperationsInput | number
    review?: NullableStringFieldUpdateOperationsInput | string | null
    verified?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyPrescriptionInput = {
    id?: number
    uuid?: string
    userId: number
    doctorId: number
    appointmentDate: Date | string
    consultationType: string
    status?: string
    reason?: string | null
    notes?: string | null
    meetingLink?: string | null
    recordingUrl?: string | null
    paymentId?: string | null
    paymentStatus?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateWithoutPrescriptionInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAppointmentsNestedInput
    doctor?: UserUpdateOneRequiredWithoutAppointmentsAsDoctorNestedInput
    doctorProfile?: DoctorUpdateOneRequiredWithoutAppointmentsNestedInput
    callSession?: CallSessionUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    callSession?: CallSessionUncheckedUpdateOneWithoutAppointmentNestedInput
    reviews?: DoctorReviewUncheckedUpdateManyWithoutAppointmentNestedInput
  }

  export type AppointmentUncheckedUpdateManyWithoutPrescriptionInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    doctorId?: IntFieldUpdateOperationsInput | number
    appointmentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    consultationType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    recordingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentStatus?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicineOrderItemCreateManyMedicineInput = {
    id?: number
    orderId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemUpdateWithoutMedicineInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    order?: MedicineOrderUpdateOneRequiredWithoutItemsNestedInput
  }

  export type MedicineOrderItemUncheckedUpdateWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineOrderItemUncheckedUpdateManyWithoutMedicineInput = {
    id?: IntFieldUpdateOperationsInput | number
    orderId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineOrderItemCreateManyOrderInput = {
    id?: number
    medicineId: number
    quantity: number
    price: number
  }

  export type MedicineOrderItemUpdateWithoutOrderInput = {
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
    medicine?: MedicineUpdateOneRequiredWithoutOrderItemsNestedInput
  }

  export type MedicineOrderItemUncheckedUpdateWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type MedicineOrderItemUncheckedUpdateManyWithoutOrderInput = {
    id?: IntFieldUpdateOperationsInput | number
    medicineId?: IntFieldUpdateOperationsInput | number
    quantity?: IntFieldUpdateOperationsInput | number
    price?: FloatFieldUpdateOperationsInput | number
  }

  export type LabBookingTestCreateManyTestInput = {
    id?: number
    bookingId: number
  }

  export type LabBookingTestUpdateWithoutTestInput = {
    booking?: LabBookingUpdateOneRequiredWithoutTestsNestedInput
  }

  export type LabBookingTestUncheckedUpdateWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type LabBookingTestUncheckedUpdateManyWithoutTestInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
  }

  export type LabBookingTestCreateManyBookingInput = {
    id?: number
    testId: number
  }

  export type LabBookingTestUpdateWithoutBookingInput = {
    test?: LabTestUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type LabBookingTestUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type LabBookingTestUncheckedUpdateManyWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    testId?: IntFieldUpdateOperationsInput | number
  }

  export type ForumCommentCreateManyPostInput = {
    id?: number
    uuid?: string
    userId: number
    parentCommentId?: number | null
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PostUpvoteCreateManyPostInput = {
    id?: number
    userId: number
    voteType: string
  }

  export type ForumCommentUpdateWithoutPostInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    parentComment?: ForumCommentUpdateOneWithoutRepliesNestedInput
    replies?: ForumCommentUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    parentCommentId?: NullableIntFieldUpdateOperationsInput | number | null
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PostUpvoteUpdateWithoutPostInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutPostUpvotesNestedInput
  }

  export type PostUpvoteUncheckedUpdateWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type PostUpvoteUncheckedUpdateManyWithoutPostInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type ForumCommentCreateManyParentCommentInput = {
    id?: number
    uuid?: string
    postId: number
    userId: number
    content: string
    upvotes?: number
    helpfulCount?: number
    verifiedDoctor?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CommentUpvoteCreateManyCommentInput = {
    id?: number
    userId: number
    voteType: string
  }

  export type ForumCommentUpdateWithoutParentCommentInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    post?: ForumPostUpdateOneRequiredWithoutCommentsNestedInput
    user?: UserUpdateOneRequiredWithoutForumCommentsNestedInput
    replies?: ForumCommentUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateWithoutParentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    replies?: ForumCommentUncheckedUpdateManyWithoutParentCommentNestedInput
    upvotesByUser?: CommentUpvoteUncheckedUpdateManyWithoutCommentNestedInput
  }

  export type ForumCommentUncheckedUpdateManyWithoutParentCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    postId?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    helpfulCount?: IntFieldUpdateOperationsInput | number
    verifiedDoctor?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CommentUpvoteUpdateWithoutCommentInput = {
    voteType?: StringFieldUpdateOperationsInput | string
    user?: UserUpdateOneRequiredWithoutCommentUpvotesNestedInput
  }

  export type CommentUpvoteUncheckedUpdateWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type CommentUpvoteUncheckedUpdateManyWithoutCommentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    voteType?: StringFieldUpdateOperationsInput | string
  }

  export type ArticleCommentCreateManyArticleInput = {
    id?: number
    uuid?: string
    userId: number
    content: string
    upvotes?: number
    createdAt?: Date | string
  }

  export type SavedArticleCreateManyArticleInput = {
    id?: number
    userId: number
    savedAt?: Date | string
  }

  export type ArticleCommentUpdateWithoutArticleInput = {
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCommentUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ArticleCommentUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    uuid?: StringFieldUpdateOperationsInput | string
    userId?: IntFieldUpdateOperationsInput | number
    content?: StringFieldUpdateOperationsInput | string
    upvotes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleUpdateWithoutArticleInput = {
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSavedArticlesNestedInput
  }

  export type SavedArticleUncheckedUpdateWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SavedArticleUncheckedUpdateManyWithoutArticleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    savedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorCountOutputTypeDefaultArgs instead
     */
    export type DoctorCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentCountOutputTypeDefaultArgs instead
     */
    export type AppointmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionCountOutputTypeDefaultArgs instead
     */
    export type PrescriptionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicineCountOutputTypeDefaultArgs instead
     */
    export type MedicineCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicineCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicineOrderCountOutputTypeDefaultArgs instead
     */
    export type MedicineOrderCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicineOrderCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabTestCountOutputTypeDefaultArgs instead
     */
    export type LabTestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabTestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabBookingCountOutputTypeDefaultArgs instead
     */
    export type LabBookingCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabBookingCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumPostCountOutputTypeDefaultArgs instead
     */
    export type ForumPostCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumPostCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumCommentCountOutputTypeDefaultArgs instead
     */
    export type ForumCommentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumCommentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthArticleCountOutputTypeDefaultArgs instead
     */
    export type HealthArticleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthArticleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthProfileDefaultArgs instead
     */
    export type HealthProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorDefaultArgs instead
     */
    export type DoctorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DoctorReviewDefaultArgs instead
     */
    export type DoctorReviewArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DoctorReviewDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PrescriptionDefaultArgs instead
     */
    export type PrescriptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PrescriptionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CallSessionDefaultArgs instead
     */
    export type CallSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CallSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicineDefaultArgs instead
     */
    export type MedicineArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicineDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicineOrderDefaultArgs instead
     */
    export type MedicineOrderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicineOrderDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicineOrderItemDefaultArgs instead
     */
    export type MedicineOrderItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicineOrderItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabTestDefaultArgs instead
     */
    export type LabTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabBookingDefaultArgs instead
     */
    export type LabBookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabBookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabBookingTestDefaultArgs instead
     */
    export type LabBookingTestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabBookingTestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LabReportDefaultArgs instead
     */
    export type LabReportArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LabReportDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthRecordDefaultArgs instead
     */
    export type HealthRecordArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthRecordDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumPostDefaultArgs instead
     */
    export type ForumPostArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumPostDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ForumCommentDefaultArgs instead
     */
    export type ForumCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ForumCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PostUpvoteDefaultArgs instead
     */
    export type PostUpvoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PostUpvoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CommentUpvoteDefaultArgs instead
     */
    export type CommentUpvoteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CommentUpvoteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HealthArticleDefaultArgs instead
     */
    export type HealthArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HealthArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ArticleCommentDefaultArgs instead
     */
    export type ArticleCommentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ArticleCommentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SavedArticleDefaultArgs instead
     */
    export type SavedArticleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SavedArticleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SymptomCheckSessionDefaultArgs instead
     */
    export type SymptomCheckSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SymptomCheckSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CoachSessionDefaultArgs instead
     */
    export type CoachSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CoachSessionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}